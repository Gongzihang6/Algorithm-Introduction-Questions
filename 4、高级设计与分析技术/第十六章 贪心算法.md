## 第十六章 贪心算法

### 练习 16.1

>**\d{1,2}\.\d-\d** 根据递归式(16.2)为活动选择问题设计一个动态规划算法。算法应该按前文定义计算最大兼容活动集的大小 $c[i, j]$ 并生成最大集本身。假定输入的活动已按公式(16.1)排好序。比较你的算法和 GREEDY-ACTIVITY-SELECTOR 的运行时间。

>**\d{1,2}\.\d-\d** 假定我们不再一直选择最早结束的活动，而是选择最晚开始的活动，前提仍然是与之前选出的所有活动均兼容。描述如何利用这一方法设计贪心算法，并证明算法会产生最优解。

>**\d{1,2}\.\d-\d** 对于活动选择问题，并不是所有贪心方法都能得到最大兼容活动子集。请举例说明，在剩余兼容活动中选择持续时间最短者不能得到最大集。类似地，说明在剩余兼容活动中选择与其他剩余活动重叠最少者，以及选择最早开始者均不能得到最优解。

>**\d{1,2}\.\d-\d** 假定有一组活动，我们需要将它们安排到一些教室，任意活动都可以在任意教室进行。我们希望使用最少的教室完成所有活动。设计一个高效的贪心算法求每个活动应该在哪个教室进行。

（这个问题称为区间图着色问题 (interval-graph color problem)。我们可以构造一个区间图，顶点表示给定的活动，边连接不兼容的活动。要求用最少的颜色对顶点进行着色，使得所有相邻顶点颜色均不相同——这与使用最少的教室完成所有活动的问题是对应的。）

>**\d{1,2}\.\d-\d** 考虑活动选择问题的一个变形：每个活动 $a_i$ 除了开始和结束时间外，还有一个值 $v_i$。目标不再是求规模最大的兼容活动子集，而是求值之和最大的兼容活动子集。也就是说，选择一个兼容活动子集 $A$，使得 $\sum_{a_k \in A} v_k$ 最大。设计一个多项式时间的算法求解此问题。

### 练习 16.2

>**\d{1,2}\.\d-\d** 证明：分数背包问题具有贪心选择性质。

>**\d{1,2}\.\d-\d** 设计动态规划算法求解 0-1 背包问题，要求运行时间为 $O(nW)$，$n$ 为商品数量，$W$ 是小偷能放进背包的最大商品总重量。

>**\d{1,2}\.\d-\d** 假定在 0-1 背包问题中，商品的重量递增序与价值递减序完全一样。设计一个高效算法求此背包问题的变形的最优解，证明你的算法是正确的。

>**\d{1,2}\.\d-\d** Gekko 教授一直梦想用直排轮滑的方式横穿北达科他州。他计划沿 U.S. 2 号高速公路横穿，这条高速公路从明尼苏达州东部边境的大福克斯市到靠近蒙大拿州西部边境的威利斯顿市。教授计划带两公升水，在喝光水之前能滑行 $m$ 英里（由于北达科他州地势相对平坦，教授无需担心在上坡路段喝水速度比平地或下坡路段快）。教授从大福克斯市出发时带整整两公升水。他携带的北达科他州官方地图显示了 U.S. 2 号公路上所有可以补充水的地点，以及这些地点间的距离。

教授的目标是最小化横穿途中补充水的次数。设计一个高效的方法，以帮助教授确定应该在哪些地点补充水。证明你的策略会生成最优解，分析其运行时间。

>**\d{1,2}\.\d-\d** 设计一个高效算法，对实数线上给定的一个点集 $\{x_1, x_2, \cdots, x_n\}$，求一个单位长度闭区间的集合，包含所有给定的点，并要求此集合最小。证明你的算法是正确的。

*>* *\d{1,2}\.\d-\d** 设计算法，在 $O(n)$ 时间内求解分数背包问题。

>**\d{1,2}\.\d-\d** 给定两个集合 $A$ 和 $B$，各包含 $n$ 个正整数。你可以按需要任意重排每个集合。重排后，令 $a_i$ 为集合 $A$ 的第 $i$ 个元素，$b_i$ 为集合 $B$ 的第 $i$ 个元素。于是你得到回报 $\prod_{i=1}^{n} a_i b_i$。设计算法最大化你的回报。证明你的算法是正确的，并分析运行时间。

### 练习 16.3

>**\d{1,2}\.\d-\d** 请解释，在引理 16.2 的证明中，为什么若 $x.freq = b.freq$，则有 $a.freq = b.freq$ 且 $x.freq = y.freq$。

>**\d{1,2}\.\d-\d** 证明：一棵不满的二叉树不可能对应一个最优前缀码。

>**\d{1,2}\.\d-\d** 如下所示，8 个字符对应的出现频率是斐波那契数列的前 8 个数，此频率集合的赫夫曼编码是怎样的？

- $a: 1$ $b: 1$ $c: 2$ $d: 3$ $e: 5$ $f: 8$ $g: 13$ $h: 21$

​	你能推广你的结论，求频率集为前 $n$ 个斐波那契数的最优前缀码吗？

>**\d{1,2}\.\d-\d** 证明：编码树的总代价还可以表示为所有内部结点的两个孩子结点的联合频率之和。

>**\d{1,2}\.\d-\d** 证明：如果我们将字母表中字符按频率单调递减排序，那么存在一个最优编码，其码字长度是单调递增的。

>**\d{1,2}\.\d-\d** 假定我们有字母表 $C = \{0, 1, \cdots, n-1\}$ 上的一个最优前缀码，我们希望用最少的二进制位传输此编码。说明如何仅用 $2n-1 + n \lceil\log n$ 位表示 $C$ 上的任意最优前缀码。（提示：通过对树的遍历，用 $2n-1$ 位说明编码树的结构。）

>**\d{1,2}\.\d-\d** 推广赫夫曼算法，使之能生成三进制的码字（即码字由符号 0、1、2 组成），并证明你的算法能生成最优三进制码。

>**\d{1,2}\.\d-\d** 假定一个数据文件由 8 位字符组成，其中所有 256 个字符出现的频率大致相同：最高的频率也低于最低频率的 2 倍。证明：在此情况下，赫夫曼编码并不比 8 位固定长度编码更高效。

>**\d{1,2}\.\d-\d** 证明：对于一个由随机生成的 8 位字符组成的文件，没有任何压缩方法可以望将其压缩，哪怕只是压缩一位。（提示：比较可能的文件数量和可能的编码文件数量。）

### 练习 16.4

>**\d{1,2}\.\d-\d** 证明：若 $S$ 是任意一个有限集，$\mathcal{I}_k$ 是 $S$ 的所有规模不超过 $k$ 的子集的集合 $(k \leq |S|)$，则 $(S, \mathcal{I}_k)$ 是一个拟阵。

*>* *\d{1,2}\.\d-\d** 给定某个域（如实数域）上的 $m \times n$ 矩阵 $T$，证明：$(S, \mathcal{I})$ 是一个拟阵，其中 $S$ 是 $T$ 的列的集合，且 $A \in \mathcal{I}$ 当且仅当 $A$ 中的列是线性无关的。

*>* *\d{1,2}\.\d-\d** 证明：若 $(S, \mathcal{I})$ 是一个拟阵，则 $(S, \mathcal{I}^{\prime})$ 也是一个拟阵，其中
$$\mathcal{I}^{\prime} = \{A^{\prime}: S - A^{\prime} \text{包含某些最大独立子集} A \in \mathcal{I}\}$$，即 $(S, \mathcal{I}^{\prime})$ 的最大独立子集恰好是 $(S, \mathcal{I})$ 的最大独立子集的补集。

*>* *\d{1,2}\.\d-\d** 令 $S$ 是一个有限集，$S_1, S_2, \cdots, S_k$ 是 $S$ 的一个划分，这些集合都是非空且不相交的。定义结构 $(S, \mathcal{I})$ 满足条件 $\mathcal{I} = \{A: |A \cap S_i| \leqslant 1, i = 1, 2, \cdots, k\}$。证明：$(S, \mathcal{I})$ 是一个拟阵。也就是说，与划分中所有子集都最多有一个共同元素的集合 $A$ 组成的集合构成了拟阵的独立集。

>**\d{1,2}\.\d-\d** 对于一个所需最优化解为最小权重最大独立子集的加权拟阵问题，如何将其权重函数进行转换，使其变为标准的加权拟阵问题。详细论证你的转换方法是正确的。

### 练习 16.5

>**\d{1,2}\.\d-\d** 对图 16-7 给出的调度问题的实例，将每个惩罚值 $w_i$ 替换为 $80 - w_i$，求解修改后的问题。

>**\d{1,2}\.\d-\d** 说明如何利用引理 16.12 的性质 2 在 $O(|A|)$ 时间内确定一个给定任务集合 $A$ 是独立的。

### 思考题

16-1 （找零问题）考虑用最少的硬币找 $\pi$ 美分零钱的问题。假定每种硬币的面额都是整数。
a. 设计贪心算法求解找零问题，假定有 25 美分、10 美分、5 美分和 1 美分 4 种面额的硬币。证明你的算法能找到最优解。
b. 假定硬币面额是 $c$ 的幂，即面额为 $c^2, c^1, \cdots, c^k$ 和 $k$ 为整数，$c \geq 1, k \geq 1$。证明：贪心算法总能得到最优解。
c. 设计一组硬币面额。使得贪心算法不能保证得到最优解。这组硬币面额中应该包含 1 美分，使得对每个零钱值都存在找零方案。
d. 设计一个 $O(n k)$ 时间的找零算法，适用于任何 $k$ 种不同面额的硬币，假定总是包含 1 美分硬币。

16-2 （最小平均完成时间调度问题）假定给定任务集合 $S = \{a_1, a_2, \cdots, a_n\}$，其中任务 $a_i$ 在启动后需要 $p_i$ 个时间单位完成。你有一台计算机来运行这些任务，每个时刻只能运行一个任务。令 $c_i$ 表示任务 $a_i$ 的完成时间，即任务 $a_i$ 被执行完的时间。你的目标是最小化平均完成时间，即最小化 $(1/n) \sum_{i=1}^{n} c_i$。例如，假定有两个任务 $a_1$ 和 $a_2$，$p_1 = 3, p_2 = 5$，如果 $a_1$ 首先运行，然后运行 $a_2$，则 $c_2 = 5, c_1 = 8$，平均完成时间为 $(5 + 8)/2 = 6.5$。如果 $a_2$ 先于 $a_1$ 执行，则 $c_1 = 3, c_2 = 8$，平均完成时间为 $(3 + 8)/2 = 5.5$。

a. 设计算法，求平均完成时间最小的调度方案。任务的执行都是非抢占的，即一旦 $a_i$ 开始运行，它就持续运行 $p_i$ 个时间单位。证明你的算法能最小化平均完成时间，并分析算法的运行时间。

b. 现在假定任务并不是在任意时刻都可以开始执行，每个任务都有一个释放时间 $r_i$，在此时间之后才可以开始。此外假定任务执行是可以抢占的 (preemption)，这样任务可以被挂起，稍后再重新开始。例如，一个任务 $a_i$ 的运行时间为 $p_i = 6$，释放时间为 $r_i = 1$，它可能在时刻 1 开始运行，在时刻 4 被抢占。然后在时刻 10 恢复运行，在时刻 11 再次被抢占，最后在时刻 13 恢复运行，在时刻 15 运行完毕。任务 $a_i$ 共运行了 6 个时间单位，但运行时间被分割成三部分。在此情况下，$a_i$ 的完成时间为 15。设计算法，对此问题求解平均运行时间最小的调度方案。证明你的算法确实能最小化完成时间，分析算法的运行时间。

16-3 （无环子图）

a. 一个无向图 $G = (V, E)$ 的关联矩阵 (incidence matrix) 是一个 $|V| \times |E|$ 的矩阵 $M$，若边 $e$ 关联于顶点 $v$，则 $M_{uv} = 1$，否则 $M_{uv} = 0$。论证 $M$ 的一个列集合在整数模 2 的城上线性无关当且仅当对应的边集无环。

b. 假定我们对一个无向图 $G = (V, E)$ 的每条边都关联一个非负权重 $w(e)$。设计一个高效算法，求权重之和最大的无环边集。

c. 令 $G = (V, E)$ 是任意的有向图，定义 $(E, I)$ 满足 $A \in I$ 当且仅当 $A$ 不包含任何有向环。给出一个有向图 $G$ 的例子，使得关联的系统 $(E, I)$ 不是一个拟阵。指出定义中哪个条件使得系统 $(E, I)$ 不是拟阵。

d. 无自环的有向图 $G = (V, E)$ 的关联矩阵是一个 $|V| \times |E|$ 的矩阵 $M$，若边 $e$ 从顶点 $v$ 发出，则 $M_{uv} = -1$，若边 $e$ 指向顶点 $v$，则 $M_{uv} = 1$，否则 $M_{uv} = 0$，证明：如果 $M$ 的一个列集合线性无关，那么对应的边集不包含有向环。

e. 练习 > **\d{1,2}\.\d-\d** 告诉我们任意矩阵 $M$ 的线性无关的列集合的集合构成一个拟阵。仔细解释 (c) 和 (e) 的结果为什么不矛盾。什么情况下边集无环与关联矩阵中对应列集合线性无关这两个问题间没有完美的对应关系？

16-4 （调度问题变形）对 16.5 节中带截止时间和惩罚的单位时间任务调度问题，考虑如下算法。初始时令 $n$ 个时间槽均为空，时间槽 $i$ 为单位时间长度，结束于时刻 $i$。我们按惩罚值单调递减的顺序处理所有任务。当处理任务 $a_i$ 时，如果存在不晚于 $a_i$ 的截止时间 $d_i$ 的空时间槽，则将 $a_i$ 分配到其中最晚的那个。如果不存在这样的时间槽，将 $a_i$ 分配到最晚的空时间槽。

a. 证明：此算法总能得到最优解。

b. 利用 21.3 节提出的快速不相交集合森林来高效实现此算法。假定输入任务集合已经按惩罚值单调递减的顺序排序。分析实现程序的运行时间。

16-5 （离线缓存）现代计算机使用缓存技术将少量数据保存于快速内存中。虽然程序可能访问大量数据，但通过将主存中少量数据保存在缓存（cache）一容量小但更快的内存中，还是可以大幅度降低访问时间。当一个计算机程序运行时，它对内存进行 $n$ 次内存访问 $(r_1, \cdots, r_n)$，每个请求访问一个特定数据元素。例如，一个程序访问 4 个不同元素 $(a, b, c, d)$，访问请求序列为 $(d, b, d, b, a, c, d, b, a, c, b)$，令 $k$ 为缓存的规模，当缓存已经保存了 $k$ 个元素，而程序访问第 $(k+1)$ 个元素时，系统必须决定，对于此访问及之后的请求，要将哪 $k$ 个元素保存在缓存中。更准确地说，对每个请求，缓存管理算法检查元素 $r_i$ 是否在缓存中。如果已在，就产生一次缓存命中（cache hit）；否则，产生一次缓存未命中（cache miss）。若产生缓存未命中，系统从主存中提取 $r_i$，同时缓存管理算法必须决定是否将 $r_i$ 保留在缓存中。如果缓存决定保留 $r_i$，且缓存中已经保存了 $k$ 个元素，则它必须将某个元素逐出缓存来为 $r_i$ 腾出空间。缓存管理算法逐出数据的目标是在处理整个访问请求序列的过程中缓存未命中的次数最少。

通常，缓存管理是一个在线问题。也就是说，我们在决定将哪些数据保留在缓存中时，并不知道未来的访问请求是什么。但是，我们这里考虑此问题的离线版本，即预先知 道完整的请求序列（包含 $n$ 个访问请求）及缓存规模 $k$, 目标仍是最小化缓存未命中次数。 我们可以用一种称为将来最远(furthest-in-future) 的贪心策略求解离线缓存问题，此策略选择逐出缓存的数据的方法是选择在请求序列中下一次访问距离最远的数据。

a. 编写使用将来最远策略的缓存管理器的伪代码。输入是请求序列 $\langle r_1, r_2, \cdots, r_n \rangle$ 和缓存规模 $k$，输出为决策结果序列——处理每个请求时逐出缓存的是哪个数据（如果需要逐出）。分析算法的运行时间。

b. 证明：离线缓存问题具有最优子结构性质。

c. 证明：将来最远策略可以保证最小缓存未命中次数。