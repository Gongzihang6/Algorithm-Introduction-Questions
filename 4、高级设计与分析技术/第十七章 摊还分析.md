## 第十七章 摊还分析

#### 练习 17.1

>**\d{1,2}\.\d-\d** 如果栈操作包括 MULTIPUSH 操作，它将 $k$ 个数据项压入栈中，那么栈操作的摊还代价的界还是 $O(1)$ 吗？

>**\d{1,2}\.\d-\d** 证明：如果 $k$ 位计数器的例子中允许 DECREMENT 操作，那么 $n$ 个操作的运行时间可能达到 $\Theta(nk)$。

>**\d{1,2}\.\d-\d** 假定我们对一个数据结构执行一个由 $n$ 个操作组成的操作序列，当 $i$ 严格为 2 的幂时，第 $i$ 个操作的代价为 $i$，否则代价为 1。使用聚合分析确定每个操作的摊还代价。

#### 练习 17.2

>**\d{1,2}\.\d-\d** 假定对一个规模永远不会超过 $k$ 的栈执行一个栈操作序列。执行 $k$ 个操作后，我们复制整个栈来进行备份。通过为不同的栈操作赋予适合的摊还代价，证明：$n$ 个栈操作（包括复制栈）的代价为 $O(n)$。

>**\d{1,2}\.\d-\d** 用核算法重做练习 > **\d{1,2}\.\d-\d**。

>**\d{1,2}\.\d-\d** 假定我们不仅对计数器进行增 1 操作，还会进行置 0 操作（即将所有位复位）。设检测或修改一个位的时间为 $\Theta(1)$，说明如何用一个位数组来实现计数器，使得对一个初值为 0 的计数器执行一个由任意 $n$ 个 INCREMENT 和 RESET 操作组成的序列花费时间 $\Theta(n)$。（提示：维护一个指针一直指向最高位的 1。）

#### 练习 17.3

>**\d{1,2}\.\d-\d** 假定有势函数 $\Phi$，对所有 $i$ 满足 $\Phi(D_i) \geqslant \Phi(D_0)$，但 $\Phi(D_0) \neq 0$。证明：存在势函数 $\Phi'$，使得 $\Phi'(D_0) = 0$，对所有 $i \geqslant 1$ 满足 $\Phi'(D_i) \geqslant 0$，且使用 $\Phi'$ 的摊还代价与使用 $\Phi$ 的摊还代价相同。

>**\d{1,2}\.\d-\d** 使用势能法重做练习 > **\d{1,2}\.\d-\d**。

>**\d{1,2}\.\d-\d** 考虑一个包含 $n$ 个元素的普通二叉最小堆数据结构，它支持 INSERT 和 EXTRACT-MIN 操作，最坏情况时间均为 $O(\log n)$。给出一个势函数 $\Phi$，使得 INSERT 操作的摊还代价为 $O(\log n)$，而 EXTRACT-MIN 操作的摊还代价为 $O(1)$，证明它是正确的。

>**\d{1,2}\.\d-\d** 执行 $n$ 个 PUSH、POP 和 MULTIPOP 栈操作的总代价是多少？假定初始时栈中包含 $s_0$ 个对象，结束后包含 $s_n$ 个对象。

>**\d{1,2}\.\d-\d** 假定计数器初值不是 0，而是包含 $b$ 个 1 的二进制数。证明：若 $n = \Omega(b)$，则执行 $n$ 个 INCREMENT 操作的代价为 $O(n)$。（不要假定 $b$ 是常量。）

>**\d{1,2}\.\d-\d** 证明：如何用两个普通的栈实现一个队列（练习 > **\d{1,2}\.\d-\d**），使得每个 ENQUEUE 和 DEQUEUE 操作的摊还代价为 $O(1)$。

>**\d{1,2}\.\d-\d** 为动态整数多重集 $S$（允许包含重复值）设计一种数据结构，支持如下两个操作：

- INSERT($S, x$) 将 $x$ 插入 $S$ 中。
- DELETE-LARGER-HALF($S$) 将最大的 $\lceil|S|/2\rceil$ 个元素从 $S$ 中删除。

解释如何实现这种数据结构，使得任意 $m$ 个 INSERT 和 DELETE-LARGER-HALF 操作的序列能在 $O(m)$ 时间内完成。还要实现一个能在 $O(|S|)$ 时间内输出所有元素的操作。

#### 练习 17.4

>**\d{1,2}\.\d-\d** 假定我们希望实现一个动态的开地址散列表。为什么我们需要当装载因子达到一个严格小于 1 的值 $\alpha$ 时就认为表满？简要描述如何为动态开地址散列表设计一个插入算法，使得每个插入操作的摊还代价的期望值为 $O(1)$。为什么每个插入操作的实际代价的期望值不必对所有插入操作都是 $O(1)$？

>**\d{1,2}\.\d-\d** 证明：如果动态表的 $\alpha_{i-1} \geqslant 1/2$ 且第 $i$ 个操作是 TABLE-DELETE，那么用势函数公式 (17.6) 定义的操作的摊还代价的上界是一个常数。

>**\d{1,2}\.\d-\d** 假定我们改变表收缩的方式，不是当装载因子小于 $1/4$ 时将表规模减半，而是当装载因子小于 $1/3$ 时将表规模变为原来的 $2/3$​。使用势函数

$$
\Phi(T) = |2 \cdot T.num - T.size|
$$

证明：使用此策略，TABLE-DELETE 操作的摊还代价的上界是一个常数。



#### 思考题

17-1 （位逆序的二进制 FFT）第 30 章介绍了一个称为快速逆序重置位变换 (Fast Fourier Transform, FFT) 的重要算法。FFT 算法的第一步是对一维数组 $A[0..n-1]$ 执行一个称为位逆序置换 (bit-reversal permutation) 的操作，数组的长度 $n=2^k$，$k$ 是一个非负整数。这个置换操作下标的二进制数表示互为逆序的数组元素元素进行交换。

我们将每个下标 $a$ 表示为一个 $k$ 位二进制序列 $\langle a_{k-1}, a_{k-2}, \cdots, a_0 \rangle$，其中 $a = \sum_{i=0}^{k-1} a_i 2^i$。我们定义

$$
\text{rev}_x(\langle a_{k-1}, a_{k-2}, \cdots, a_0 \rangle) = \langle a_0, a_1, \cdots, a_{k-1} \rangle
$$

因此，

$$
\text{rev}_x(a) = \sum_{i = 0}^{k-1} a_{k-i-1} 2^i
$$

例如，若 $n=16$（或等价地，$k=4$），则 $\text{rev}_4(3) = 12$，因为对应的 4 位二进制表示为 0011，其逆序为 12，是 12 的 位二进制表示。

a. 设计一个运行时间为 $\Theta(k)$ 的函数，编写算法在 $O(nk)$ 时间内长度为 $n=2^k$ 的数组执行位逆序置换。

b. 假定你的计算机的每个机器字保存有 $k$ 位二进制数，而一个机器字中的值进行一次任意位移量的左移位、右移位、位与、位或等操作只需单位时间。设计一个 BIT-REVERSED-INCREMENT 过程，能使一个 $k$ 元素的数组上的位逆序置换操作在 $O(n)$ 时间内完成。

c. 假定在单位时间内你只能完成右移一位的操作，还可做至多 $O(n)$ 时间的位逆序置换操作吗？

17-2 （动态二分查找）有序数组上的二分查找花费花费对数时间，但插入一个新元素的运行时间与数组规模线性相关。我们希望维护一个有序数组来提高插入性能。

具体地，假定我们希望支持 $n$ 元素上的 SEARCH 和 INSERT 操作。令 $k = \lceil\log(n+1)\rceil$，令 $n$ 的二进制表示为 $\langle n_{k-1}, n_{k-2}, \cdots, n_0 \rangle$，$n_i$ 表示第 $i$ 个有符号值 $a_i$。$A_1, \cdots, A_{n-1}$ 对 $n$ 个数组 $A_i$ 进行编号，取其 $n_i=1$ 还是 $n_i=0$。因此，所有 $k$ 个数组中保存的元素总数为 $\sum_{i=0}^{k} n_i 2^i = n$。虽然单独每个数组都是有序的，但不同数组中的元素之间不存在特定的大小关系。

a. 设计算法，实现这种数据结构上的 SEARCH 操作，分析其最坏情况运行时间。

b. 设计 INSERT 算法。分析最坏情况运行时间和摊还运行时间。

c. 讨论如何实现 DELETE。

17-3 （摊还加权平衡树）考虑扩充普通二叉搜索树，为每个结点 $x$ 增加属性 $x.size$，此属性给出 $x$ 的子树中关键字的数量。令 $a_1 \leqslant a_2 \leqslant \cdots \leqslant a_n$，我们称结点 $x$ 是 $\alpha$ 平衡的。如果树中每个结点都是 $\alpha$ 平衡的，则称树整体是 $\alpha$ 平衡的。G. Varghese 定义了一种树，其中每个结点维护计数器。

a. 在某种意义上，一棵 1/2 平衡树达到了极限平衡。给定任意一棵二叉搜索树，证明：如何重组以 $\alpha$ 为根的子树，使得它变为 1/2 平衡的树。你的算法的运行时间应该为 $\Theta(x.size)$，可以使用 $O(x.size)$ 的辅助空间。

b. 证明：对于任意一棵 $n$ 个结点的二叉搜索树，可以在 $O(n)$ 时间内执行一次搜索操作的执行时间为 $O(\log n)$。

c. 证明：对于本问题的剩余部分，假定常数 $\alpha$ 严格大于 1/2。假定你实现的 INSERT 和 DELETE 操作与普通二叉搜索树的 INSERT 和 DELETE 操作的算法是一样的。证明：如果发现树中任何结点不平衡的，则在最高的不平衡结点，对以它为根的子树执行“重建”，使得每个数组的元素总数为 $n/2$ 平衡的。

d. 假定 $m$ 个单位的势能够支持重建 $m$ 结点子树的代价，相对于 $m$ 个结点，$\alpha$ 应该多大才能使得重建一棵非 $\alpha$ 平衡的子树的摊还代价为 $O(1)$。

e. 证明：在棵 $n$ 结点的 $\alpha$ 平衡树中插入一个结点或删除一个结点所花时间为 $O(\log n)$。

$17$-$4$ （重构红黑树的代价） 红黑树有 $4$ 种基本的结构性修改（structural modification）操作：结点插入、结点删除、旋转及更改颜色。我们已经看到 RB-INSERT 和 RB-DELETE 操作仅使用 $O(1)$ 次旋转、结点插入和结点删除操作来维持红黑树的性质，但它们可能需要很多次更改颜色操作。

​	a. 设计一个 $n$ 结点的合法的红黑树，使得调用 RB-INSERT 添加第 $n+1$ 个结点会引起 $O(\log n)$ 次颜色更改。然后设计一个 $n$ 结点的合法的红黑树，使得调用 RB-DELETE 删除一个特定结点会引起 $O(\log n)$ 次颜色更改。

虽然每个操作所引起的颜色更改的最坏情况次数可能是对数的，但我们仍可以证明，在一个空红黑树上执行任意 $m$ 个 RB-INSERT 和 RB-DELETE 操作构成的序列，最坏情况下只会引起 $O(m)$ 次结构性修改。注意，我们将每次颜色更改计为一次结构性修改。

​	b. RB-INSERT-FIXUP 和 RB-DELETE-FIXUP 的代码的主循环都处理一些终结性的情况：一旦遇到这些情况，会导致循环在常数次操作后终止。对于 RB-INSERT-FIXUP 和 RB-DELETE-FIXUP 中处理的各种情况，指出其中哪些是终结性的，哪些不是。（提示：参见图 $13$-$5$、图 $13$-$6$ 和图 $13$-$7$。）

我们首先分析仅仅执行插入操作所引起的结构性修改。令 $T$ 为一棵红黑树，定义 $\Phi(T)$ 是 $T$ 中红结点数量。假定一个单位的势可以支付 RB-INSERT-FIXUP 的三种情况的任意一种所引起的结构性修改的代价。

​	c. 令 $T'$ 表示对 $T$ 应用 RB-INSERT-FIXUP 的情况 $1$ 得到的结果。证明：$\Phi(T') \leq \Phi(T) - 1$。

​	d. 当使用 RB-INSERT 向一棵红黑树中插入一个结点时，我们可以将操作分为三部分。列出 RB-INSERT 的第 $1$-$16$ 行引起的结构性改变和势的变化，以及 RB-INSERT-FIXUP 的非终结性情况引起的变化和势的变化。

​	e. 使用 (d) 证明：任意一次 RB-INSERT 执行所导致的结构性修改的摊还次数为 $O(1)$。我们现在希望证明既执行插入也执行删除时，所引起的结构性修改次数为 $O(m)$。对每个结点 $x$，我们定义

$$
w(x) = 
\begin{cases} 
0 & \text{若 } x \text{ 是红结点} \\
1 & \text{若 } x \text{ 是黑结点且没有红孩子} \\
2 & \text{若 } x \text{ 是黑结点且有一个红孩子} \\
3 & \text{若 } x \text{ 是黑结点且有两个红孩子}
\end{cases}
$$
现在定义红黑树 $T$ 的势函数为

$$
\Phi(T) = \sum_{x \in T} w(x)
$$
且令 $T'$ 为对 $T$ 应用 RB-INSERT-FIXUP 或 RB-DELETE-FIXUP 的任意非终结性情况后的结果。

​	f. 证明：对 RB-INSERT-FIXUP 的任意非终结性情况，有 $\Phi(T') \leq \Phi(T) - 1$。证明：INSERT-FIXUP 的任意一次调用所引起的结构性修改次数为 $O(1)$。

​	g. 证明：对 RB-DELETE-FIXUP 的任意非终结性情况，有 $\Phi(T') \leq \Phi(T) - 1$。证明：RB-DELETE-FIXUP 的任意一次调用所引起的结构性修改的次数为 $O(1)$。

​	h. 证明：任意 $m$ 个 RB-INSERT 和 RB-DELETE 操作构成的序列最坏情况下执行 $O(m)$ 次结构性修改。

$17$-$5$ （移至前端自组织列表的竞争优势） 自组织列表是 $n$ 个元素的链表，每个元素有一个唯一的关键字。当我们在列表中搜索元素时，需要给定一个关键字，我们搜索的是具有这个关键字的元素。

一个自组织列表有两个重要性质：

1. 为了在列表中查找一个元素，我们必须从表头开始遍历列表，直至遇到具有给定关键字的元素位置。如果此元素是列表的第 $k$ 个元素，则查找代价为 $k$。
2. 我们可以在任意一个操作后根据给定规则重排列表元素，产生一定的代价。我们可以使用任何我们喜欢的启发式策略来决定如何重排列表。

假定从一个给定的 $n$ 个元素的列表开始，并且给定了一个访问序列一关键字搜索序列 $\sigma=\left\langle\sigma_1,\sigma_1,\cdots,\sigma_n\right\rangle$ 。序列的代价是序列中单个访问的代价之和。

在多种可能的列表重排方法中，本问题关注相邻元素转置操作——交换相邻元素在列表中的位置，一次转置的代价为单位时间。你可以用势函数证明：针对移至前端列表的重排问题，一种特定的启发式策略的代价最坏情况也不会超过任何其他启发式策略的代价的 $4$ 倍，即使其他启发式策略预先知道访问序列！我们称这种分析为竞争分析。

对于一个启发式策略 $H$ 和列表的一个给定的初始顺序，我们将序列 $\sigma$ 的访问代价记为 $C_{H}(\sigma)$ 。令 $m$ 表示 $\sigma$ 中访问的数量。

​	a. 证明：若启发式策略 $H$ 预先不知道访问序列，那么利用 $H$ 来处理访问序列 $\sigma$ 的最坏情况代价为 $C_H(\sigma)=\Omega(m m)$ 。

当使用移至前端启发式策略时，搜索到元素 $x$ 后，我们将 $x$ 移动到列表的第一个位置(即列表的前端)。

令 $\operatorname{rank}_L(x)$ 表示元素 $x$ 在列表 $L$ 中的序号，即 $x$ 在 $L$ 中的位置。例如，若 $x$ 是 $L$ 中第 $4$ 个元素，那么 $\operatorname{rank}_k(x)=4$ 。令 $c_i$ 表示用移至前端策略处理访问 $\sigma_i$ 的代价，包括在列表中查找元素的代价和通过一系列相邻元素转置操作将其移至列表前端的代价。

​	b. 证明：如果 $\sigma_i$ 使用移至前端策略在 $L$ 中访问元素 $x$，则 $c_i=2\cdot\operatorname{rank}_t(x)-1$ 。

现在我们比较移至前端策略与其他任何按照上述两个性质处理访问序列的启发式策略 $H$ 。策略 $H$ 可能按任何它想用的方式转置列表中的元素，它甚至可能预先知道整个访问序列。序列。

令 $L_i$ 表示使用移至前端策略处理访问 $\sigma_i$ 后得到的列表， $L_i^{\prime}$ 表示使用策略 $H$ 后得到的列表。我们用 $c_i$ 表示移动前端策略的代价， $c_i$ 表示策略 $H$ 的代价。假定策略 $H$ 在处理访问 $\sigma_i$ 时执行 $t_i^{*}$ 次转置。

​	c. 在(b)中，你证明了 $c_i=2\cdot\operatorname{rank}_{L_{i-1}}(x)-1$ 。现在证明： $c_i^{\prime}=\operatorname{rank}_{L_{i-1}}(x)+t_i^{\prime}$ 。

我们定义逆序(inversion)关系： $L_i$ 中一对元素 $y$ 和 $z$，在 $L_i$ 中 $y$ 在 $z$ 之前，在 $L_i^*$ 中 $z$ 在 $y$ 之前。假定处理完访问序列 $\left\langle\sigma_1,\sigma_2,\cdots,\sigma_i\right\rangle, L_i$ 中有 $q_i$ 个逆序关系。然后，我们定义一个势函数，将 $L$ 映射到实数 $\Phi\left(L_1\right)=2 q_i$ 。例如，如果 $L_i$ 有元素 $\langle e, c, a, d, b\rangle$ ，而 $L_i^*$ 有元素 $\langle c, a, b, d, e\rangle$ ，那么 $L_i$ 有 $5$ 个逆序( $(e, c),(e, a),(e, d),(e, b),(e, b),(d, b))$, 因此 $\Phi\left(L_i\right)=10$ 。观察到对所有 $i$，都有 $\Phi\left(L_i\right)\geqslant 0$ ，并且如果移至前端策略和策略 $H$ 从相同的列表 $L_0$ 开始，那么 $\Phi\left(L_0\right)=0$ 。

​	d. 证明：转置操作要么将势增加 $2$，要么减少 $2$。

假定访问 $\sigma_i$ 查找元素 $x$。为了理解势是如何根据 $\sigma_i$ 来变化的，我们将除 $x$ 之外的元素划分为 $4$ 个集合，划分的依据是在第 $i$ 次访问之前它们在列表中的位置：

● 集合 $A$ 包含在 $L_{i-1}$ 和 $L_{i-1}$ 中都位于 $x$ 之前的元素。

● 集合 $B$ 包含在 $L_{i-1}$ 中位于 $x$ 之前的元素，在 $L_{i-1}$ 中位于 $x$ 之后的元素。

● 集合 $C$ 包含在 $L_{r-1}$ 中位于 $x$ 之后的元素，在 $L_r$ ; 中位于 $x$ 之前的元素。

● 集合 $D$ 包含在 $L_{i-1}$ 和 $L_{i-1}$ 中都位于 $x$ 之后的元素。

​	e. 证明： $\operatorname{rank}_{L_n}(x)=|A|+|B|+1$ 且 $\operatorname{rank}_{L_n}(x)=|A|+|C|+1$ 。

​	f. 证明：处理访问 $\sigma_i$ 会引起势的变化

$$
\Phi\left(L_1\right)-\Phi\left(L_{r-1}\right)\leqslant 2\left(|A|-|B|+t_1^*\right)
$$

其中，表示用启发式策略 $H$ 处理访问 $\sigma_i$ 期间执行的转置操作次数。

我们定义处理访问 $\sigma_i$ 的摊还代价为 $\hat{c}_i=c_i+\Phi\left(L_i\right)-\Phi\left(L_{i-1}\right)$ 。

​	g. 证明：处理访问 $\sigma_i$ 的摊还代价的上界为 $4 c_i^{*}$ 。

​	h. 证明：使用移至前端策略处理访问序列 $\sigma$ 的代价 $C_{MTF}(\sigma)$ 至多是用其他任何启发式策略 $H$ 处理 $\sigma$ 的代价 $C_H(\sigma)$ 的 $4$ 倍，假定两种启发式策略都是从相同的列表开始处理访问序列。