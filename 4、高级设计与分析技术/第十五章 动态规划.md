## 第十五章 动态规划

### 练习 15.1

>**15.1-1** 由公式(15.3)和初始条件 $T(0) = 1$，证明公式(15.4)成立。

公式 15.3 如下：
$$
T(n)= 1+\sum_{j = 0}^{n-1}T(j)
$$
所以：
$$
\begin{aligned}T(n)&= 1+T(0)+T(1)+\cdots+T(n-1)    \\
T(n+1)&= 1+T(0)+T(1)+\cdots+T(n-1)+T(n)\end{aligned}
$$
下式减去上式，$T(n+1)=2T(n)$，而 $T(0)=1$，所以:
$$
T(n)= 2^n
$$

---

>**15.1-2** 举反例证明下面的“贪心”策略不能保证总是得到最优切割方案。定义长度为 $i$ 的钢条的密度为 $p_i/i$，即每英寸的价值。贪心策略将长度为 $n$ 的钢条切割下长度为 $i (1 \leqslant i \leqslant n)$ 的一段，其密度最高。接下来继续使用相同的策略切割长度为 $n-i$ 的剩余部分。

假设钢条总长度为 4，钢条各个长度段的价值如下：

| 长度 | 价值 | 密度 |
| :--: | :--: | :--: |
|  1   |  1   | 1.0  |
|  2   |  5   | 2.5  |
|  3   |  8   | 2.67 |
|  4   |  9   | 2.25 |

按照题给的贪心策略，每次切割密度最高的一段，第一次切割长度为 3 的一段，然后剩下长度为 1 的一段无法切割，总价值为 8+1 = 9；

但是实际最优切割方案应该是切割成长度为 2 的两段，此时总价值为 5+5 = 10 > 9

>**15.1-3** 我们对钢条切割问题进行一点修改，除了切割下的钢条段具有不同价格 $p_i$ 外，每次切割还要付出固定的成本 $c$。这样，切割方案的收益就等于钢条段的价格之和减去切割的成本。设计一个动态规划算法解决修改后的钢条切割问题。

伪代码实现：

```python
def cut_rod_with_cost(p, n, c):  
    # p: 价格数组，n: 钢条长度，c: 切割成本  
    r = [0] * (n + 1)  # 收益数组  
    
    for j in range(1, n + 1):  
        # 遍历长度为1到n的钢条，求解不同长度钢条的最优切割价值（至少要优于不切割的情况）
        max_revenue = p[j]  # 不切割的情况  
        
        for i in range(1, j):  
            # 考虑切割的情况  
            max_revenue = max(max_revenue, p[i] + r[j-i] - c)  
        
        r[j] = max_revenue  
    
    return r[n]  
```

相较于原始钢条切割问题，只是多出了每次切割的固定成本，所以在考虑切割的情况的时候，切割后的收益应当减去固定的切割成本，再来和不切割的情况做比较，只有切割后的收益减去固定切割成本后的净收益仍然大于不切割，才决定切割。

>**15.1-4** 修改 MEMOIZED-CUT-ROD，使之不仅返回最优收益值，还返回切割方案。

```c++
MEMORIZED-CUT-ROD(p,n) 	
	let r[0 .. n]be a new array // 存储长度为0到n的钢条的最优切割收益
	for j = 0 to n
        r[i] = -∞	// 初始化长度为1到n的钢条的最优切割收益都为负无穷
   return MEMOIZED-CUT-ROD-AUX(p,n,r) 
        
MEMOIZED-CUT-ROD-AUX(p,n,r) // 辅助函数，输入钢条不同长度价值数组p、钢条长度n、最优切割收益数组r
    if r[n]>=O 		// 大于等于0说明已经求过了最优切割收益，直接返回
    	return r[n] 
    if n == O 		// 长度为0的钢条切割收益为0
    	q = 0 
    else	// 如果没有求过最优切割收益，遍历1到n，求出最佳切割方案
        q = —∞
    	for i = 1 to n 
    		q = max(q, p[i] + MEMOIZED-CUT-ROD-AUX(p, n—i, r)) // 比较每种切割方案下切割不切割的收益，选择收益大的
    r[n] = q 	// 将最终获取的最优切割收益存入最优切割收益数组r中
    return q 	// 返回当前长度为n的钢条的最优切割收益
```

以上为原始的 MEMOIZED-CUT-ROD 切割方法，只返回最优收益，没有返回切割方案，以下给出既返回最优收益值、又返回切割方案的伪代码

```c++
MEMORIZED-CUT-ROD(p,n) 	
	let r[0 .. n]be a new array // 存储长度为0到n的钢条的最优切割收益
    let s[0 .. n]be a new array // 存储最优切割方案
	for j = 0 to n
        r[i] = -∞	// 初始化长度为1到n的钢条的最优切割收益都为负无穷
   return MEMOIZED-CUT-ROD-AUX(p,n,r) 
        
MEMOIZED-CUT-ROD-AUX(p,n,r) // 辅助函数，输入钢条不同长度价值数组p、钢条长度n、最优切割收益数组r
    if r[n]>=O 		// 大于等于0说明已经求过了最优切割收益，直接返回
    	return r[n] 
    if n == O 		// 长度为0的钢条切割收益为0
    	q = 0 
    else	// 如果没有求过最优切割收益，遍历1到n，求出最佳切割方案
        q = —∞
    	for i = 1 to n 
           if q < p[i] + MEMOIZED-CUT-ROD-AUX(p, n—i, r)	// 说明该切割方案下切割的额收益更大
    			q = p[i] + MEMOIZED-CUT-ROD-AUX(p, n—i, r)
              s[n] = i	// 当前长度为n的钢条的最佳切割方案为在i处切割
    r[n] = q 	// 将最终获取的最优切割收益存入最优切割收益数组r中
    return q 	// 返回当前长度为n的钢条的最优切割收益
```

> **15.1-5** 斐波那契数列可以用递归式(3.22)定义。设计一个 $O(n)$ 时间的动态规划算法计算第 $n$ 个斐波那契数。画出子问题图。图中有多少顶点和边？

<img src="F:\software\Typora\images\image-20250321202142059.png" alt="image-20250321202142059" style="zoom:67%;" />

递归式（3.22）如上图所示，递归公式为：
$$
F_{n+2}= F_n+F_{n+1}	\quad (n\ge0)
$$
根据递归公式绘制子问题图如下：

<img src="F:\software\Typora\images\a6f2b1e81c9bfaacedb834c0051d8bad.jpg" alt="img" style="zoom: 25%;" />

这里绘制了计算到第 $n+2$ 个斐波拉且数的图，实际上问题是求解计算到第 n 个斐波拉且数的子问题图中的边和顶点的数量。

显然顶点有 $n+1$ 个，从 $F_0$ 到 $F_n$，共 $n+1$ 个；对于边的数量，$F_0$ 和 $F_1$ 两个顶点没有任何出边，$F_2$ 到 $F_n$ 这 $n-1$ 个顶点，每个顶点有 2 条出边，所以边的总数是 $2n-2$ 条；

### 练习 15.2

>**15.2-1** 对矩阵规模序列 $\langle 5, 10, 3, 12, 5, 50, 6 \rangle$，求矩阵链最优括号化方案。

矩阵规模序列 $\langle 5, 10, 3, 12, 5, 50, 6 \rangle$ 对应 == A1(5\*10)、A2(10*3)、A3(3\*12)、A4(12\*5)、A5(5\*50)、A6(50\*6)== **这样的 6 个矩阵连续相乘**，求对应的矩阵链最优括号化方案。

```cpp
MATRIX-CHAIN-ORDER(p)
    n = p.length - 1	// 矩阵规模序列长度减一，也就是实际连乘的矩阵数量
    let m[1..n,1..n] and s[1..n-1,2..n] be new tables
    for i = 1 to n
        m[i,i] = 0	// 单个矩阵不需要乘法运算，标量乘法次数为0
    for l = 2 to n          // l是子链长度
        for i = 1 to n-l+1	// i是子链在原始矩阵链中的起点
            j = i + l - 1	// j是根据子链长度l和子链起点i确定的子链终点
            m[i,j] = ∞
            for k = i to j-1
                q = m[i,k] + m[k+1,j] + p[i-1]*p[k]*p[j]
                if q < m[i,j]
                    m[i,j] = q	// 存储子问题的解，也就是具体的标量乘法次数
                    s[i,j] = k	// 存储具体括号方案，也就是括号具体位置
    return m and s
```

上述伪代码的 C++实现：

```cpp
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

// 辅助函数：打印最优括号方案
void PrintOptimalParens(const vector<vector<int>>& s, int i, int j) {
    if (i == j) {
        cout << "A" << i;
    }
    else {
        cout << "(";
        PrintOptimalParens(s, i, s[i][j]);
        PrintOptimalParens(s, s[i][j] + 1, j);
        cout << ")";
    }
}

// 矩阵链乘法最优解算法
void MatrixChainOrder(const vector<int>& p) {
    int n = p.size() - 1;  // 矩阵数量

    // 创建动态规划数组
    vector<vector<int>> m(n + 1, vector<int>(n + 1, 0));
    vector<vector<int>> s(n + 1, vector<int>(n + 1, 0));

    // 子链长度从2开始，最大到n
    for (int l = 2; l <= n; l++) {
        // 遍历所有可能的子链起点
        for (int i = 1; i <= n - l + 1; i++) {
            int j = i + l - 1;  // 子链终点
            m[i][j] = INT_MAX;  // 初始化为最大值

            // 尝试所有可能的分割点k
            for (int k = i; k < j; k++) {
                int q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];
                if (q < m[i][j]) {
                    m[i][j] = q;     // 更新最小代价
                    s[i][j] = k;     // 记录最优分割点
                }
            }
        }
    }

    // 打印最小代价
    cout << "最小标量乘法次数: " << m[1][n] << endl;

    // 打印最优括号方案
    cout << "最优括号方案: ";
    PrintOptimalParens(s, 1, n);
    cout << endl;
}

int main() {
    // 给定的矩阵维度序列：5, 10, 3, 12, 5, 50, 6
    vector<int> p = { 5, 10, 3, 12, 5, 50, 6 };

    MatrixChainOrder(p);

    return 0;
}

```

```
当子链长度为：2时：
m[1,2]:
  k取1时:
    q = m[1,1] + m[2,2] + p[0]p[1]p[2]
    q = 0 + 0 + 150 = 150
    更新: m[1,2] = 150

m[2,3]:
  k取2时:
    q = m[2,2] + m[3,3] + p[1]p[2]p[3]
    q = 0 + 0 + 360 = 360
    更新: m[2,3] = 360

m[3,4]:
  k取3时:
    q = m[3,3] + m[4,4] + p[2]p[3]p[4]
    q = 0 + 0 + 180 = 180
    更新: m[3,4] = 180

m[4,5]:
  k取4时:
    q = m[4,4] + m[5,5] + p[3]p[4]p[5]
    q = 0 + 0 + 3000 = 3000
    更新: m[4,5] = 3000

m[5,6]:
  k取5时:
    q = m[5,5] + m[6,6] + p[4]p[5]p[6]
    q = 0 + 0 + 1500 = 1500
    更新: m[5,6] = 1500

-------------------------------------------
当子链长度为：3时：
m[1,3]:
  k取1时:
    q = m[1,1] + m[2,3] + p[0]p[1]p[3]
    q = 0 + 360 + 600 = 960
    更新: m[1,3] = 960
  k取2时:
    q = m[1,2] + m[3,3] + p[0]p[2]p[3]
    q = 150 + 0 + 180 = 330
    更新: m[1,3] = 330

m[2,4]:
  k取2时:
    q = m[2,2] + m[3,4] + p[1]p[2]p[4]
    q = 0 + 180 + 150 = 330
    更新: m[2,4] = 330
  k取3时:
    q = m[2,3] + m[4,4] + p[1]p[3]p[4]
    q = 360 + 0 + 600 = 960

m[3,5]:
  k取3时:
    q = m[3,3] + m[4,5] + p[2]p[3]p[5]
    q = 0 + 3000 + 1800 = 4800
    更新: m[3,5] = 4800
  k取4时:
    q = m[3,4] + m[5,5] + p[2]p[4]p[5]
    q = 180 + 0 + 750 = 930
    更新: m[3,5] = 930

m[4,6]:
  k取4时:
    q = m[4,4] + m[5,6] + p[3]p[4]p[6]
    q = 0 + 1500 + 360 = 1860
    更新: m[4,6] = 1860
  k取5时:
    q = m[4,5] + m[6,6] + p[3]p[5]p[6]
    q = 3000 + 0 + 3600 = 6600

-------------------------------------------
当子链长度为：4时：
m[1,4]:
  k取1时:
    q = m[1,1] + m[2,4] + p[0]p[1]p[4]
    q = 0 + 330 + 250 = 580
    更新: m[1,4] = 580
  k取2时:
    q = m[1,2] + m[3,4] + p[0]p[2]p[4]
    q = 150 + 180 + 75 = 405
    更新: m[1,4] = 405
  k取3时:
    q = m[1,3] + m[4,4] + p[0]p[3]p[4]
    q = 330 + 0 + 300 = 630

m[2,5]:
  k取2时:
    q = m[2,2] + m[3,5] + p[1]p[2]p[5]
    q = 0 + 930 + 1500 = 2430
    更新: m[2,5] = 2430
  k取3时:
    q = m[2,3] + m[4,5] + p[1]p[3]p[5]
    q = 360 + 3000 + 6000 = 9360
  k取4时:
    q = m[2,4] + m[5,5] + p[1]p[4]p[5]
    q = 330 + 0 + 2500 = 2830

m[3,6]:
  k取3时:
    q = m[3,3] + m[4,6] + p[2]p[3]p[6]
    q = 0 + 1860 + 216 = 2076
    更新: m[3,6] = 2076
  k取4时:
    q = m[3,4] + m[5,6] + p[2]p[4]p[6]
    q = 180 + 1500 + 90 = 1770
    更新: m[3,6] = 1770
  k取5时:
    q = m[3,5] + m[6,6] + p[2]p[5]p[6]
    q = 930 + 0 + 900 = 1830

-------------------------------------------
当子链长度为：5时：
m[1,5]:
  k取1时:
    q = m[1,1] + m[2,5] + p[0]p[1]p[5]
    q = 0 + 2430 + 2500 = 4930
    更新: m[1,5] = 4930
  k取2时:
    q = m[1,2] + m[3,5] + p[0]p[2]p[5]
    q = 150 + 930 + 750 = 1830
    更新: m[1,5] = 1830
  k取3时:
    q = m[1,3] + m[4,5] + p[0]p[3]p[5]
    q = 330 + 3000 + 3000 = 6330
  k取4时:
    q = m[1,4] + m[5,5] + p[0]p[4]p[5]
    q = 405 + 0 + 1250 = 1655
    更新: m[1,5] = 1655

m[2,6]:
  k取2时:
    q = m[2,2] + m[3,6] + p[1]p[2]p[6]
    q = 0 + 1770 + 180 = 1950
    更新: m[2,6] = 1950
  k取3时:
    q = m[2,3] + m[4,6] + p[1]p[3]p[6]
    q = 360 + 1860 + 720 = 2940
  k取4时:
    q = m[2,4] + m[5,6] + p[1]p[4]p[6]
    q = 330 + 1500 + 300 = 2130
  k取5时:
    q = m[2,5] + m[6,6] + p[1]p[5]p[6]
    q = 2430 + 0 + 3000 = 5430

-------------------------------------------
当子链长度为：6时：
m[1,6]:
  k取1时:
    q = m[1,1] + m[2,6] + p[0]p[1]p[6]
    q = 0 + 1950 + 300 = 2250
    更新: m[1,6] = 2250
  k取2时:
    q = m[1,2] + m[3,6] + p[0]p[2]p[6]
    q = 150 + 1770 + 90 = 2010
    更新: m[1,6] = 2010
  k取3时:
    q = m[1,3] + m[4,6] + p[0]p[3]p[6]
    q = 330 + 1860 + 360 = 2550
  k取4时:
    q = m[1,4] + m[5,6] + p[0]p[4]p[6]
    q = 405 + 1500 + 150 = 2055
  k取5时:
    q = m[1,5] + m[6,6] + p[0]p[5]p[6]
    q = 1655 + 0 + 1500 = 3155

-------------------------------------------
最小标量乘法次数: 2010
最优括号方案: ((A1A2)((A3A4)(A5A6)))
```

根据 P213 的伪代码，==先遍历子链长度为 2== 的情况，m [1,2], 此时可能的括号方案 k 只能取 1，q = p [0]*p [1]\*p [2] = 150 < m [1,2] = $\infty$，所以 m [1,2] = 150; 依此类推，m [2,3] = 360、m [3,4] = 180、m [4,5] = 3000、m [5,6] = 1500，两个矩阵相乘，不存在更优括号方案，就是直接相乘的运算量；==再遍历子链长度为 3 的情况==，m [1,3]，此时可能的括号方案 k 可能取 1 或 2，k 取 1 时，q = m [1,1]+m [2,3]+p [0] p [1] p [3] = 960 < m [1,3] = $\infty$，所以 m [1,3] = 960；k 取 2 时，q = m [1,2]+m [3,3]+p [0] p [2] p [3] = 330 < m [1,3] = 960，所以 m [1,3] = 330；依此类推，对 m [2,4]、m [3,5]、m [4,6] 依次取 k = 1、k = 2（遍历当前子链长度下的所有可能括号方案），然后存储更优的标量乘法次数 m [i, j] 和具体括号方案 s [i, j].

m [2,4]，k 取 2 时，q = m [2,2]+m [3,4]+p [1] p [2] p [4] = 330 <m[2,4]=$\infty$，所以m[2,4]=330；k取3时，q=m[2,3]+m[4,4]+p[1]p[3]p[4]=960> m [2,4] = 330，所以 m [2,4] = 330；

m [3,5]，k 取 3 时，q = m [3,3]+m [4,5]+p [2] p [3] p [5] = 4800 < m [3,5] = $\infty$，所以 m [3,5] = 4800；k 取 4 时，q = m [3,4]+m [5,5]+p [2] p [4] p [5] = 930 < 4800，所以 m [3,5] = 930；

m [4,6]，k 取 4 时，q = m [4,4]+m [5,6]+p [3] p [4] p [6] = 1860 <m[4,6]=$\infty$，所以m[4,6]=1860；k取5时，q=m[4,5]+m[6,6]+p[3]p[5]p[6]=6600> 1860，所以 m [4,6] = 1860；

==再遍历子链长度为 4 的情况==

m [1,4]，k 取 1 时，q = m [1,1]+m [2,4]+p [0] p [1] p [4] = 580 <m[1,4]=$\infty$，所以m[1,4]=580；k取2时，q=m[1,2]+m[3,4]+p[0]p[2]p[4]=405<580，所以m[1,4]=405；k取3时，q=m[1,3]+m[4,4]+p[0]p[3]p[4]=630> 405，所以 m [1,4] = 405;

m [2,5]，k 取 2 时，q = m [2,2]+m [3,5]+p [1] p [2] p [5] = 1770 <m[2,5]=$\infty$，所以m[2,5]=1770；k取3时，q=m[2,3]+m[4,5]+p[1]p[3]p[5]=9360> 1770，所以 m [2,5] = 1770；k 取 4 时，q = m [2,4]+m [5,5]+p [1] p [4] p [5] = 2830 > 1770，所以 m [2,5] = 1770;

m [3,6]，k 取 3 时，q = m [3,3]+m [4,6]+p [2] p [3] p [6] = 2076 <m[3,6]=$\infty$，所以m[3,6]=2076；k取4时，q=m[3,4]+m[5,6]+p[2]p[4]p[6]=1770<2076，所以m[3,6]=1770；k取5时，q=m[3,5]+m[6,6]+p[2]p[5]p[6]=1830> 1770，所以 m [3,6] = 1770;

==再遍历子链长度为 5 的情况==

m [1,5]，k 取 1 时，q = m [1,1]+m [2,5]+p [0] p [1] p [5] = 4930 <m[1,5]=$\infty$，所以m[1,5]=4930；k取2时，q=m[1,2]+m[3,5]+p[0]p[2]p[5]=1830<4930，所以m[1,5]=1830；k取3时，q=m[1,3]+m[4,5]+p[0]p[3]p[5]=6330> 1830；所以 m [1,5] = 1830；k 取 4 时，q = m [1,4]+m [5,5]+p [0] p [4] p [5] = 1655 < 1830，所以 m [1,5] = 1655；

m [2,6]，k 取 2 时，q = m [2,2]+m [3,6]+p [1] p [2] p [6] = 1950 <m[2,6]=$\infty$，所以m[2,6]=1950；k取3时，q=m[2,3]+m[4,6]+p[1]p[3]p[6]=2940> 1950，所以 m [2,6] = 1950；k 取 4 时，q = m [2,4]+m [5,6]+p [1] p [4] p [6] = 2130 > 1950；所以 m [2,6] = 1950；k 取 5 时，q = m [2,5]+m [6,6]+p [1] p [5] p [6] = 5430 > 1950，所以 m [2,6] = 1950；

==再遍历子链长度为 6 的情况==

m [1,6]，k 取 1 时，q = m [1,1]+m [2,6]+p [0] p [1] p [6] = 2250 <m[1,6]=$\infty$，所以m[1,6]=2250；k取2时，q=m[1,2]+m[3,6]+p[0]p[2]p[6]=2010<2250，所以m[1,6]=2010；k取3时，q=m[1,3]+m[4,6]+p[0]p[3]p[6]=2550> 2010，所以 m [1,6] = 2010；k 取 4 时，q = m [1,4]+m [5,6]+p [0] p [4] p [6] = 2055 > 2010，所以 m [1,6] = 2010；k 取 5 时，q = m [1,5]+m [6,6]+p [0] p [5] p [6] = 3155 > 2010，所以 **m [1,6] = 2010；**

|  5   |  10  |  3   |  12  |  5   |  50  |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  1   |  2   |  3   |  4   |  5   |  6   |

| 子链长度 l | 子问题的解 m [i, j] | k 的可能取值 | s [i, j] = k 取值 | m [i, j] 对应取值 |
| :-------: | :--------------: | :---------: | :----------: | :------------: |
|     2     |      m [1,2]      |      1      |    **1**     |    **150**     |
|           |      m [2,3]      |      2      |    **1**     |    **360**     |
|           |      m [3,4]      |      3      |    **1**     |    **180**     |
|           |      m [4,5]      |      4      |    **1**     |    **3000**    |
|           |      m [5,6]      |      5      |    **1**     |    **1500**    |
|     3     |      m [1,3]      |    1，2     |      1       |      960       |
|           |                  |             |    **2**     |    **330**     |
|           |      m [2,4]      |    2，3     |    **2**     |    **330**     |
|           |                  |             |      3       |      960       |
|           |      m [3,5]      |     3,4     |      3       |      4800      |
|           |                  |             |    **4**     |    **930**     |
|           |      m [4,6]      |     4,5     |    **4**     |    **1860**    |
|           |                  |             |      5       |      6600      |
|     4     |      m [1,4]      |    1,2,3    |      1       |      580       |
|           |                  |             |    **2**     |    **405**     |
|           |                  |             |      3       |      630       |
|           |      m [2,5]      |    2,3,4    |    **2**     |    **2430**    |
|           |                  |             |      3       |      9360      |
|           |                  |             |      4       |      2830      |
|           |      m [3,6]      |    3,4,5    |      3       |      2076      |
|           |                  |             |    **4**     |    **1770**    |
|           |                  |             |      5       |      1830      |
|     5     |      m [1,5]      |   1,2,3,4   |      1       |      4930      |
|           |                  |             |      2       |      1830      |
|           |                  |             |      3       |      6330      |
|           |                  |             |    **4**     |    **1655**    |
|           |      m [2,6]      |   2,3,4,5   |    **2**     |    **1950**    |
|           |                  |             |      3       |      2940      |
|           |                  |             |      4       |      2130      |
|           |                  |             |      5       |      5430      |
|     6     |      m [1,6]      |  1,2,3,4,5  |      1       |      2250      |
|           |                  |             |    **2**     |    **2010**    |
|           |                  |             |      3       |      2550      |
|           |                  |             |      4       |      2055      |
|           |                  |             |      5       |      3155      |

根据最终 m [1,6] 的执行过程，在 k = 2 分割时计算量最小，所以分为 m [1,2] 和 m [3,6]，m [1,2] 为两个矩阵相乘，已经无法再分割，m [3,6] 可以在 k = 4 分割时计算量最小，所以最终总的方案就是在 k = 2 和 k = 4 两处分割

因此最终最优方案如下：最小标量乘法次数: 2010；最优括号方案: ((A1A2)((A3A4)(A5A6)))

---

> **15.2-2** 设计递归算法 MATRIX-CHAIN-MULTIPLY($A$, $s$, $i$, $j$)，实现矩阵链最优代价乘法计算的真正计算过程，其输入参数为矩阵序列 $\left(A_1, A_2, \cdots, A_n\right)$，MATRIX-CHAIN-ORDER 得到的表 $s$，以及下标 $i$ 和 $j$。（初始调用应为 MATRIX-CHAIN-MULTIPLY($A$, $s$, 1, $n$)。）

以 15.2-1 为例， == A1(5\*10)、A2(10*3)、A3(3\*12)、A4(12\*5)、A5(5\*50)、A6(50\*6)== **这样的 6 个矩阵连续相乘** 的最优括号方案为 ((A1A2)((A3A4)(A5A6)))，对应的 $A=(A_1、A_2、A_3、A_4、A_5、A_6)$，

```cpp
// 伪代码实现
MATRIX-CHAIN-MULTIPLY(A, s, 1, n)  
    if 1 == n 
        return A[1]  
    else   
        k = s[1, n]  			
        // 分割点为 k  
        left = MATRIX-CHAIN-MULTIPLY(A, s, 1, k)  					    // 递归调用，直到分割为单个矩阵
        right = MATRIX-CHAIN-MULTIPLY(A, s, k+1, n)  
        // 执行矩阵乘法  
        return Multiply(left, right)
```

以下是以 15.2-1 为例的 MATRIX-CHAIN-MULTIPLY(A, s, 1, n) 的 C++代码实现

```cpp
#include <iostream>  
#include <vector>  
using namespace std;

// 定义矩阵结构体  
struct Matrix {
    int rows, cols;
    vector<vector<int>> data;
    // 矩阵构造函数，初始化为全0矩阵
    Matrix(int r, int c) : rows(r), cols(c), data(r, vector<int>(c, 0)) {}
};

// 矩阵乘法函数  
Matrix Multiply(const Matrix& A, const Matrix& B) {
    if (A.cols != B.rows) {
        throw runtime_error("不可进行矩阵乘法");
    }

    Matrix result(A.rows, B.cols);
    for (int i = 0; i < A.rows; ++i) {
        for (int j = 0; j < B.cols; ++j) {
            for (int k = 0; k < A.cols; ++k) {
                result.data[i][j] += A.data[i][k] * B.data[k][j];
            }
        }
    }
    return result;
}

// 矩阵链乘法递归实现  
Matrix MATRIX_CHAIN_MULTIPLY(vector<Matrix>&A, vector<vector<int>>&s, int i, int j) {
    if (i == j) {
        return A[i - 1];  // 注意下标从0开始  
    }
    else {
        int k = s[i][j];
        Matrix left = MATRIX_CHAIN_MULTIPLY(A, s, i, k);
        Matrix right = MATRIX_CHAIN_MULTIPLY(A, s, k + 1, j);
        return Multiply(left, right);
    }
}

// 15.2-1中的矩阵链乘法最优解算法，返回最优括号方案s
vector<vector<int>> MatrixChainOrder(const vector<int>& p) {
    int n = p.size() - 1;  // 矩阵数量

    // 创建动态规划数组
    vector<vector<int>> m(n + 1, vector<int>(n + 1, 0));
    vector<vector<int>> s(n + 1, vector<int>(n + 1, 0));

    // 子链长度从2开始，最大到n
    for (int l = 2; l <= n; l++) {
        // 遍历所有可能的子链起点
        for (int i = 1; i <= n - l + 1; i++) {
            int j = i + l - 1;  // 子链终点
            m[i][j] = INT_MAX;  // 初始化为最大值

            // 尝试所有可能的分割点k
            for (int k = i; k < j; k++) {
                int q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];
                if (q < m[i][j]) {
                    m[i][j] = q;     // 更新最小代价
                    s[i][j] = k;     // 记录最优分割点
                }
            }
        }
    }
    return s;
}

int main() {
    // 示例：A1(5*10)、A2(10*3)、A3(3*12)、A4(12*5)、A5(5*50)、A6(50*6)  
    // 矩阵只给出了形状，没有具体数值，具体数值默认初始化全部为0
    vector<Matrix> matrices = {
        Matrix(5, 10),   // A1  
        Matrix(10, 3),   // A2  
        Matrix(3, 12),   // A3  
        Matrix(12, 5),   // A4  
        Matrix(5, 50),   // A5  
        Matrix(50, 6)    // A6  
    };
    vector<int> p = { matrices[0].rows, matrices[1].rows, matrices[2].rows, matrices[3].rows, matrices[4].rows, matrices[5].rows, matrices[0].cols };
    // 预先计算的最优分割点表  
    vector<vector<int>> s = MatrixChainOrder(p);

    // 计算最终结果  
    Matrix result = MATRIX_CHAIN_MULTIPLY(matrices, s, 1, 6);

    // 输出结果维度，通过最终结果矩阵的维度判断计算是否正确
    cout << "最终结果矩阵维度: " << result.rows << " x " << result.cols << endl;

    return 0;
}
```





> **15.2-3** 用代入法证明递归公式 (15.6) 的结果为 $\Omega(2^n)$。

<img src="F:\software\Typora\images\image-20250325202654690.png" alt="image-20250325202654690" style="zoom: 67%;" />

这里是为了说明，如果不采用动态规划求解，直接遍历所有括号话方案来求解的话，需要求解的总方案的个数是指数级的，说明动态规划在矩阵链乘法问题上的优势。

证明 $$P(n)$$ 的下界 $$P(n) \geq c \cdot 2^n$$，我们的目标是证明 $$P(n)$$ 的下界是 $$\Omega(2^n)$$，即存在一个常数 $$c > 0$$，使得对于所有 $$n \geq n_0$$（某个合适的起始值），都有：

$$
P(n) \geq c \cdot 2^n
$$
首先，我们从最小情况开始：
- 当 $$n = 1$$ 时：

$$
P(1) = 1 \geq c \cdot 2^1
$$

我们可以选择 $$c < \frac{1}{2}$$ 来满足这个条件。

现在假设对所有 $$k < n$$ 都成立，即：

$$
P(k) \geq c \cdot 2^k \quad \text{对于 } k = 1, 2, \ldots, n - 1
$$
递归关系应用, 根据递归关系，我们有：

$$
P(n) = \sum_{k = 1}^{n-1} P(k)P(n-k)
$$
根据归纳假设代入 $$P(k)$$ 和 $$P(n-k)$$：

$$
P(n) \geq \sum_{k = 1}^{n-1} (c \cdot 2^k)(c \cdot 2^{n-k})
$$
化简右侧：

$$
P(n) \geq c^2 \sum_{k = 1}^{n-1} 2^n
$$
注意到 $$2^n$$ 是一个常数，与求和无关，所以我们可以将 $$2^n$$ 提出来：

$$
P(n) \geq c^2 \cdot 2^n \cdot \sum_{k = 1}^{n-1} 1 = c^2 \cdot 2^n \cdot (n - 1)
$$
为了保证 $$P(n) \geq c \cdot 2^n$$，我们可以选择 $$c$$ 足够小以适应 $$c^2 (n - 1) \geq c$$。换句话说，如果 $$c^2 (n - 1)$$ 至少等于 $$c$$，那么取 $$c$$ 为小于 $$\frac{1}{n-1}$$ 就可以保证这个不等式成立。

因此，通过归纳法和递归关系的应用，我们可以证明假设成立，即：

$$
P(k) \geq c \cdot 2^k \quad \text{对于所有 } k \geq 1
$$
从而得出对于 $$n \geq n_0$$，我们最终根据上述结果得出：

$$
P(n) \geq c \cdot 2^n
$$
这个结果证明了我们对 $$P(n)$$ 的下界是成立的，因此最终可以得出 $$P(n)$$ 的复杂度为 $$\Omega(2^n)$$。

---

> **15.2-4** 对输入链长度为 $n$ 的矩阵链乘法问题，描述其子问题图：它包含多少个顶点？包含多少条边？这些边分别连接哪些顶点？

对于输入链长度为 $$n$$ 的矩阵链乘法问题，**子问题图的顶点数** 是 $$\frac{n(n+1)}{2}$$ 。

原因：

1. 子问题通过区间 $$[i, j]$$ 来定义，其中 $$1 \leq i \leq j \leq n$$
2. 对角线上的区间代表单个矩阵，从 $$m[1, 1]$$ 到 $$m[n, n]$$
3. 上三角区间代表不同长度和起点的子链

例如，当 $$n = 4$$ 时，子问题图包含的顶点有：
- $$m[1, 1], m[2, 2], m[3, 3], m[4, 4]$$ （对角线上的单矩阵）（长度为 1 的子链有 n 个）
- $$m[1, 2], m[2, 3], m[3, 4]$$ （长度为 2 的子链）（长度为 2 的子链有 n-1 个）
- $$m[1, 3], m[2, 4]$$ （长度为 3 的子链）（长度为 3 的子链有 n-2 个）
- $$m[1, 4]$$ （全链）

依此类推，总的顶点个数应该为 $\sum\limits_{i=1}^n n-i+1 = \frac{n(n+1)}{2}$，其中 $i$ 表示子链的长度，$n-i+1$ 表示子链长度为 i 对应的子问题个数（也就是顶点数）

**子问题图的边数**

子问题图的边数为 $$O(n^2)$$，具体来说是 $$\sum_{l=2}^{n}(n-l+1)$$ 条边。

边的连接规则：对于一个子问题 $$m[i, j]$$，它与以下顶点相连：
- $$m[i, k]$$ （子问题左半部分）
- $$m[k+1, j]$$ （子问题右半部分）
- 其中 $$i \leq k < j$$

以 n = 4 为例，可以推出，子问题图中顶点数为 $$\frac{n(n+1)}{2}$$，对于子问题图中边的个数，可以这样思考，以 n = 3 为例，m [1,3] 可能会利用到的子问题有 m [1,1]、m [2,3] 或者 m [1,2]、m [3,3]，这两种情况都有可能，对于 m [1, n] 的问题规模，这样可能的情况有 n-1 种（其实也就是可能的括号方案），每种情况下都需要利用两个子问题，也就是连接两条边，所以 m [1, n] 的问题规模直接相连的子问题形成的边数就是 2(n-1)，而子问题又会有直接相连的子问题，对应的子问题情况分类个数与当前问题的规模（子链长度）有关，具体而言，对问题规模为 m [i, j] 的问题，其直接相连的子问题形成的边个数为 2(j-i)，所以总的边数就是 $\sum\limits_{l=2}^n 2(l-1)=n^2-n$

子问题图的特征

1. 每个顶点表示一个子问题（计算特定区间矩阵链乘法的最小代价）
2. 边表示子问题之间的递推关系
3. 图是有向无环图（DAG）
4. 最终目标是求解 $$m[1, n]$$，即整个矩阵链的最小乘法次数

算法执行流程解释

代码实现了动态规划求解矩阵链乘法最优括号方案：

1. 初始化
   - $$n$$ 是实际矩阵数量
   - $$m[i, j]$$ 存储 $$A_i \cdots A_j$$ 的最小乘法代价
   - $$s[i, j]$$ 存储最优分割点

2. 对角线初始化
   - $$m[i, i] = 0$$：单个矩阵不需要乘法

3. 嵌套循环遍历子问题
   - 外层循环 $$i$$：子链长度（2 到 $$n$$）
   - 中层循环 $$j$$：子链起点
   - 内层循环 $$k$$：尝试所有可能的分割点

4. 状态转移方程

$$
m [i, j] = min(m [i, k] + m [k+1, j] + p [i-1] *p [k]* p [j])
$$

   - 合并左右两个子问题的代价，加上左右子链的乘法代价

5. 记录最优解
   - 更新 $$m[i, j]$$ 为最小代价
   - 记录对应的分割点 $$s[i, j]$$

复杂度分析

- 时间复杂度：$$O(n^3)$$
- 空间复杂度：$$O(n^2)$$

---

**15.2-5** 令 $R(i, j)$ 表示在一次调用 MATRIX-CHAIN-ORDER 过程中，计算其他表项时访问表项 $m[i, j]$ 的次数。证明：
$$
\sum_{i = 1}^{n}\sum_{j = i}^{n} R(i, j) = \frac{n^3 - n}{3}
$$
（提示：证明中可用到公式 (A.3)。）

R(i, j)表示一次调用 MATRIX-CHAIN-ORDER 过程中 m [i, j] 的访问次数，所以 $\sum\limits_{i = 1}^{n}\sum\limits_{j = i}^{n} R(i, j)$ 表示在一次 MATRIX-CHAIN-ORDER 过程中对 $m$ 的访问总次数。

```cpp
MATRIX-CHAIN-ORDER(p)
    n = p.length - 1	// 矩阵规模序列长度减一，也就是实际连乘的矩阵数量
    let m[1..n,1..n] and s[1..n-1,2..n] be new tables
    for i = 1 to n
        m[i,i] = 0	// 单个矩阵不需要乘法运算，标量乘法次数为0
    for l = 2 to n          // l是子链长度
        for i = 1 to n-l+1	// i是子链在原始矩阵链中的起点
            j = i + l - 1	// j是根据子链长度l和子链起点i确定的子链终点
            m[i,j] = ∞
            for k = i to j-1
                q = m[i,k] + m[k+1,j] + p[i-1]*p[k]*p[j]
                if q < m[i,j]
                    m[i,j] = q	// 存储子问题的解，也就是具体的标量乘法次数
                    s[i,j] = k	// 存储具体括号方案，也就是括号具体位置
    return m and s
```

从 MATRIX-CHAIN-ORDER 伪代码执行过程种可以看出，访问表项 m [i, j] 的次数由 3 层 for 循环遍历次数决定，核心在于 `q = m[i,k] + m[k+1,j] + p[i-1]*p[k]*p[j]` 被调用的次数，这一行每被调用一次，对 m 的访问次数就加 2，所以整个 MATRIX-CHAIN-ORDER 的执行过程中对 m 的访问总次数应该为：
$$
\sum_{i = 1}^{n}\sum_{j = i}^{n} R(i, j)=\sum_{l = 2}^n 2*(n-l+1)(l-1)
$$
最外面的求和从 l = 2 到 n，表示第一层 for 循环执行次数，对每个子链长度 l，`q = m[i,k] + m[k+1,j] + p[i-1]*p[k]*p[j]` 被调用 $(n-l+1)(l-1)$ 次，这是由中层、内层的 for 循环决定的；再利用公式 A.3
$$
\sum_{k = 0}^{n} k^2 = \frac{n(n + 1)(2n + 1)}{6} \tag{A.3}
$$
带入到式（16）中即可，计算得到最终结果 $\sum_{i = 1}^{n}\sum_{j = i}^{n} R(i, j) = \frac{n^3 - n}{3}$

---

> **15.2-6** 证明：对 $n$ 个元素的表达式进行完全括号化，恰好需要 $n-1$ 对括号。

我们称有如下性质的矩阵乘积链为完全括号化的(fully parenthesized) : 它是单一矩阵，或者是两个完全括号化的矩阵乘积链的积，且已外加括号。

证明：对于 1 个矩阵的表达式进行完全括号化，不需要括号，也就是恰需要 1-1 = 0 个括号；对于 2 个矩阵的表达式进行完全括号化，只需要 2-1 = 1 个括号，只需要给左矩阵或者右矩阵加上括号即可满足完全括号化的定义；

据此可以得到递推公式：
$$
d [n] = d [i]+d [j]+1
$$
  其中 d [n] 表示将 n 个元素的表达式完全括号化需要的括号对数，公式（17）满足 i+j = n，也就是将 n 个元素的表达式完全括号化需要的括号对数，等于将其分为左边 i 个元素和右边 j 个元素两个表达式完全括号化需要的括号数之和，再加 1（也就是外加括号）

假设 n-1 个元素的表达式进行完全括号化时成立，也就是恰好需要 n-2 对括号，则 n 个元素的表达式完全括号化时需要的括号对数应该等于
$$
d [n] = d [n-1]+d [1]+1 =(n-2)+0+1 = n-1
$$


---

### 练习 15.3

> **15.3-1** 对于矩阵链乘法问题，下面两种确定最优代价的方法哪种更高效？第一种方法是穷举所有可能的括号化方案，对每种方案计算乘法运算次数，第二种方法是运行 RECURSIVE-MATRIX-CHAIN。证明你的结论。

**方法一：穷举所有可能的括号化方案**

矩阵链乘法的括号化方案的数量等于第 $n-1$ 个卡特兰数（Catalan Number），记作 $C(n-1)$。卡特兰数的定义为：

$$
C(n) = \frac{1}{n+1} \binom{2n}{n}
$$

卡特兰数的渐近增长为：

$$
C(n) \approx \frac{4^n}{n^{3/2} \sqrt{\pi}}
$$

因此，穷举所有括号化方案的时间复杂度为 $\Omega\left(\frac{4^n}{n^{3/2}}\right)$。

**方法二：纯递归的 RECURSIVE-MATRIX-CHAIN**

纯递归的矩阵链乘法算法的伪代码如下：

```cpp
RECURSIVE-MATRIX-CHAIN(p, i, j)
1   if i == j
2       return 0
3   m[i][j] = ∞
4   for k = i to j - 1
5       q = RECURSIVE-MATRIX-CHAIN(p, i, k) +
6           RECURSIVE-MATRIX-CHAIN(p, k + 1, j) +
7           p[i-1] * p[k] * p[j]
8       if q < m[i][j]
9           m[i][j] = q
10  return m[i][j]
```

**递归的时间复杂度分析**

设 $T(n)$ 为计算长度为 $n$ 的矩阵链的递归调用次数。对于长度为 $n$ 的链，递归会尝试所有可能的分割点 $k$，然后递归求解左半部分和右半部分：

$$
T(n) = 
\begin{cases} 
1 & \text{if } n = 1, \\
\sum_{k = 1}^{n-1}(T(k) + T(n-k)) + 1 & \text{if } n \geq 2.
\end{cases}
$$

其中 $+1$ 是当前递归调用的开销。可以观察到：

$$
T(n) = \sum_{k = 1}^{n-1}(T(k) + T(n-k)) + 1 = 2 \sum_{k = 1}^{n-1} T(k) + 1
$$

这是一个递推关系，其解为 $T(n) = \Omega(2^n)$。具体来说，可以证明 $T(n) \geq 2^{n-1}$。

**证明 $T(n) \geq 2^{n-1}$**

- 基例：$n = 1$，$T(1) = 1 \geq 2^0 = 1$ 成立。
- 假设对于所有 $m < n$，$T(m) \geq 2^{m-1}$ 成立。
- 对于 $n$：

$$
T(n) = 2 \sum_{k = 1}^{n-1} T(k) + 1 \geq 2 \sum_{k = 1}^{n-1} 2^{k-1} + 1 = 2(2^{n-1} - 1) + 1 = 2^n - 2 + 1 = 2^n - 1 \geq 2^{n-1}
$$

因此，$T(n) = \Omega(2^n)$。

**两种方法的比较**

| 方法                          | 时间复杂度                               | 空间复杂度                          |
| ----------------------------- | ---------------------------------------- | ----------------------------------- |
| 穷举所有括号化方案            | $\Omega\left(\frac{4^n}{n^{3/2}}\right)$ | $O\left(\frac{4^n}{n^{3/2}}\right)$ |
| 纯递归 RECURSIVE-MATRIX-CHAIN | $\Omega(2^n)$                            | $O(n)$                              |

显然，$2^n$ 的增长速度远慢于 $\frac{4^n}{n^{3/2}}$，因为 $4^n = (2^2)^n = 2^{2n}$。因此，纯递归的方法比穷举法更高效。

**为什么穷举法比纯递归法更慢？**

穷举法需要枚举所有可能的括号化方案，其数量是卡特兰数 $C(n-1) \approx \frac{4^n}{n^{3/2}}$，而纯递归法虽然重复计算了很多子问题，但其递归调用的总次数是指数级的 $\Omega(2^n)$，比穷举法的 $\Omega(4^n)$ 低。

**结论**

纯递归的 RECURSIVE-MATRIX-CHAIN 方法比穷举所有括号化方案的方法更高效。因为纯递归的时间复杂度是 $\Omega(2^n)$，而穷举法是 $\Omega\left(\frac{4^n}{n^{3/2}}\right)$，后者增长更快。

**空间复杂度和空间开销的比较**

我们需要分别分析穷举所有括号化方案和纯递归的 RECURSIVE-MATRIX-CHAIN 的空间复杂度（Space Complexity）和空间开销（Space Overhead）。

**1. 穷举所有括号化方案的空间复杂度**

**方法描述**：生成所有可能的括号化方案，计算每种方案的乘法次数，并记录最优解。

**空间开销分析**：
- 存储括号化方案：每个括号化方案可以表示为一个树结构或分割点序列。对于长度为 $n$ 的矩阵链，括号化方案的数量是第 $(n-1)$ 个卡特兰数 $C(n-1) \approx \frac{4^n}{n^{3/2}}$。
- 存储中间结果：需要为每个方案存储其乘法次数，因此空间复杂度为：

$$
\text{Space} = O\left(\frac{4^n}{n^{3/2}}\right)
$$

（因为需要存储所有可能的括号化方案及其代价）。

**额外空间**：
- 递归调用栈（如果使用递归生成括号化方案）：深度最多为 $n$，因此栈空间为 $O(n)$。
- 但主要空间开销来自于存储所有方案，因此：

总空间 = $O\left(\frac{4^n}{n^{3/2}}\right)$

**2. 纯递归的 RECURSIVE-MATRIX-CHAIN 的空间复杂度**

**方法描述**：直接递归计算所有可能的分割点，不存储子问题的解（无备忘）。

**空间开销分析**：
- 递归调用栈：在最坏情况下，递归树的深度为 $n$（每次分割一个矩阵），因此栈空间的最大深度为 $O(n)$。
- 每层递归的局部变量：每次递归调用需要存储 $i, j, k, q$ 等变量，占用 $O(1)$ 空间。
- 总空间：

$$
\text{Space} = O(n)
$$

（因为递归深度是线性的，且每层空间是常数的）。

**关键点**：
- 纯递归方法不存储子问题的解，因此空间开销仅来自递归调用栈，远小于穷举法。

**3. 对比总结**

|             方法              |                时间复杂度                |             空间复杂度              |
| :---------------------------: | :--------------------------------------: | :---------------------------------: |
|      穷举所有括号化方案       | $\Omega\left(\frac{4^n}{n^{3/2}}\right)$ | $O\left(\frac{4^n}{n^{3/2}}\right)$ |
| 纯递归 RECURSIVE-MATRIX-CHAIN |              $\Omega(2^n)$               |               $O(n)$                |

**结论**：

1. **空间复杂度**：
   - 穷举法的空间开销是指数级的（与卡特兰数成正比），远高于纯递归的线性栈空间。
   - 纯递归的空间复杂度仅为 $O(n)$，非常高效。
2. **空间开销的实际影响**：
   - 穷举法在 $n$ 较大时会消耗巨大的内存（如 $n = 20$ 时需存储约百万种方案）。
   - 纯递归即使在大 $n$ 时也只需线性栈空间，但会因为时间复杂度过高而无法运行。

**补充说明**：
- 动态规划（带备忘的递归或自底向上）的空间复杂度为 $O(n^3)$（用于存储子问题解），是时间和空间的平衡选择。
- 但题目明确要求比较的是无优化的纯递归和穷举法，因此动态规划不在讨论范围内。

**最终答案**

纯递归的 RECURSIVE-MATRIX-CHAIN 方法比穷举所有括号化方案的方法在空间复杂度上显著优于穷举法：
- 穷举法的空间复杂度为 $O\left(\frac{4^n}{n^{3/2}}\right)$，需要存储所有括号化方案。
- 纯递归的空间复杂度为 $O(n)$，仅需维护递归调用栈。

尽管纯递归的时间复杂度仍是指数级的 $\Omega(2^n)$，但其空间开销远低于穷举法，更适合处理较大的 $n$（前提是时间可接受）。

---

> **15.3-2** 对一个 16 个元素的数组，画出 2.3.1 节中 MERGE-SORT 过程运行的递归调用树。解释备忘技术为什么对 MERGE-SORT 这种分治算法无效。

<img src="F:\software\Typora\images\image-20250331192334246.png" alt="image-20250331192334246" style="zoom: 67%;" />

如图绘制了 8 个元素的数组使用 MERGE-SORT 进行排序运行过程的递归调用树。MERGE-SORT 这种排序过程的分治算法中，**所有的子问题一般都不同**，因为子问题中数字都不同，无法通过备忘技术使用查询备忘表的方式来代替需要多次重复求解子问题。

---

> **15.3-3** 考虑矩阵链乘法问题的一个变形：目标改为最大化矩阵序列括号化方案的标量乘法运算次数，而非最小化。此问题具有最优子结构性质吗？

现在，我们需要探讨在最大化标量乘法次数的情况下，是否仍然具有最优子结构性质。

**假设**：为了最大化整个矩阵链的标量乘法次数，我们需要选择一种分割方式，使得左半部分和右半部分的乘法次数尽可能大，然后将它们相乘得到的乘法次数也尽可能大。

**具体来说**：
对于矩阵链 $A_1 \ldots A_j$，选择分割点 $k$，使得：

$$
\text{max\_cost}(i, j) = \max_{i \leq k < j} (\text{max\_cost}(i, k) + \text{max\_cost}(k + 1, j) + p_{i-1} \cdot p_k \cdot p_j)
$$

这里，$\text{max\_cost}(i, j)$ 表示计算 $A_i \ldots A_j$ 的最大标量乘法次数。

**验证最优子结构：**

为了证明最优子结构性质，我们需要说明：

- 对于矩阵链 $A_1 \ldots A_j$ 的最大乘法次数的括号化方案，其任何子链的括号化方案也必须是对应子链的最大乘法次数方案。

**反证法**：

假设存在一个分割点 $k$，使得 $A_1 \ldots A_j$ 的最大乘法次数方案是通过 $(A_1 \ldots A_k)(A_{k+1} \ldots A_j)$ 得到的，但 $A_1 \ldots A_k$ 或 $A_{k+1} \ldots A_j$ 的乘法次数不是最大的。

那么，我们可以用更大的乘法次数的括号化方案来替代 $A_1 \ldots A_k$ 或 $A_{k+1} \ldots A_j$ 的方案，从而得到更大的 $A_1 \ldots A_j$ 的乘法次数。这与原方案是最大的矛盾。

因此，最大乘法次数的括号化方案必须由子链的最大乘法次数方案组成。即具有最优子结构性质。

**与最小化问题的对比**

在最小化问题中，我们需要选择分割点 $k$ 使得左右两部分的乘法次数之和加上合并的乘法次数最小。类似地，在最大化问题中，我们需要选择 $k$ 使得这个总和最大。两者的结构是对称的，只是取值方向不同。

**动态规划的应用**

既然最大化问题也具有最优子结构性质，我们可以使用动态规划来解决它。定义 $m[i,j]$ 为计算 $A_i \ldots A_j$ 的最大标量乘法次数。递归关系为：

$$
m [i, j] = 
\begin{cases} 
0 & \text{if } i = j, \\
\min_{i \leq k < j} (m [i, k] + m [k + 1, j] + p_{i-1} \cdot p_k \cdot p_j) & \text{if } i < j.
\end{cases}
$$

这与最小化问题的动态规划方案类似，只是将“min”改为“max”。

**示例验证**

让我们通过一个简单的例子来验证这一点。

**例子**：三个矩阵 $A_1(10 \times 100), A_2(100 \times 5), A_3(5 \times 50)$。

计算所有可能的分割方式：

1. $(A_1 A_2) A_3$:
   - $A_1 A_2$: $10 \times 100 \times 5 = 5000$
   - 结果矩阵 $(10 \times 5)$ 与 $A_3(5 \times 50)$: $10 \times 5 \times 50 = 2500$
   - 总乘法次数：$5000 + 2500 = 7500$

2. $A_1(A_2 A_3)$:
   - $A_2 A_3$: $100 \times 5 \times 50 = 25000$
   - $A_1(10 \times 100)$ 与结果 $(100 \times 50)$: $10 \times 100 \times 50 = 50000$
   - 总乘法次数：$25000 + 50000 = 75000$

最大化乘法次数的方案是第二种，为 $75000$。可以看到，为了最大化总次数，我们需要选择使得子链的乘法次数也最大的分割方式。

**可能的误区**

在思考这个问题时，可能会有以下误区：

1. **认为最大化问题不具有最优子结构**：可能会觉得为了最大化总次数，可能需要选择某些子问题的非最优解来“放大”乘法次数。然而，实际上任何非最优的子问题解都会限制总的最大值，因为更大的子问题解总是可以构成更大的总乘法次数。

2. **混淆最优的方向**：最小化和最大化在动态规划中是对称的，只是选择“min”或“max”的区别。因此，如果最小化具有最优子结构，最大化通常也具有。

---



> **15.3-4** 如前所述，使用动态规划方法，我们首先求解子问题，然后选择哪些子问题用来构造原问题的最优解。Capulet 教授认为，我们不必为了求原问题的最优解而总是求解出所有子问题。她建议，在求矩阵链乘法问题的最优解时，我们总是可以在求解子问题之前选定 $A_i A_{i+1} \cdots A_j$ 的划分位置 $A_k$（选定的 $k$ 使得 $p_{i-1} p_k p_j$ 最小）。请找出一个反例，证明这个贪心方法可能生成次优解。

为了证明贪心方法可能产生次优解，我们需要构造一个矩阵链的例子，使得：

- 贪心方法选择的分割点 $k$（即最小化 $p_{i-1} p_k p_j$ 导致的解不是全局最优。
- 存在另一个分割点 $k'$，使得按 $k'$ 分割的总代价比按 $k$ 分割的更小。

换句话说，贪心选择的局部最优（当前 $p_{i-1} p_k p_j$ 最小）并不一定导致全局最优。

**构造反例**

我们需要选择矩阵的维度序列 $p_0, p_1, p_2, \ldots, p_n$，使得贪心策略在某个步骤做出错误的选择。让我们尝试构造一个简单的例子，比如 3 个矩阵：

设矩阵链为 $A_1(p_0 \times p_1), A_2(p_1 \times p_2), A_3(p_2 \times p_3)$。

我们需要选择 $p_0, p_1, p_2, p_3$ 使得：

1. 贪心方法选择的分割点（最小化 $p_0 p_k p_3$）不是全局最优。
2. 另一个分割点实际上更好。

**反例验证**

矩阵链：$A_1(10 \times 5), A_2(5 \times 100), A_3(100 \times 50)$。

- 贪心选择：
  - 选择 $k = 1$（因为 $10 \times 5 \times 50 = 2500$ 比 $10 \times 100 \times 50 = 50000$ 小）。
  - 分割为 $(A_1 A_2) A_3$，总代价：$55000$。
- 全局最优：
  - 选择 $k = 2$，分割为 $A_1(A_2 A_3)$，总代价：$27500$。

显然，$55000 > 27500$，贪心方法没有找到最优解。

**为什么贪心策略失败？**

贪心策略在每一步选择局部最优（即最小化当前的 $p_{i-1} p_k p_j$），但忽略了子问题的结构。在上面的例子中：

- 贪心选择 $k = 1$ 是因为 $p_0 p_1 p_3$ 较小，但这导致 $A_1 A_2$ 的结果是一个 $10 \times 100$ 的矩阵，与 $A_3$ 相乘的代价很高（$50000$）。
- 而选择 $k = 2$ 虽然 $p_0 p_2 p_3$ 较大，但 $A_2 A_3$ 的结果是 $5 \times 50$，与 $A_1$ 相乘的代价低（$2500$），总代价更优。

**结论**

通过构造矩阵维度序列 $(10, 5, 100, 50)$（即矩阵 $A_1: 10 \times 5, A_2: 5 \times 100, A_3: 100 \times 50$），我们证明了 Capulet 教授的贪心方法可能生成次优解：

- 贪心方法选择的分割方式：$(A_1 A_2) A_3$，总乘法次数：$275000$。
- 最优分割方式：$A_1(A_2 A_3)$，总乘法次数：$27500$。

因此，贪心策略在这种情况下无法得到全局最优解。

---

> **15.3-5** 对 15.1 节的钢条切割问题加入限制条件：假定对于每种钢条长度 $i (i=1,2,\cdots,n-1)$，最多允许切割出 $l_i$ 段长度为 $i$ 的钢条。证明：15.1 节所描述的最优子结构性质不再成立。

设：$n = 3$。$p_1 = 1, p_2 = 5, p_3 = 8$。限制：$l_1 = 1, l_2 = 1$。

**原问题的最优解：**

- 可能的切割方案：
  1. 3：收益 8。
  2. 1 + 2：收益 $1 + 5 = 6$。
  3. 1 + 1 + 1：不允许（$l_1 = 1$）。
- 最优解为 3，收益 8。

**子问题的最优解**：

- 子问题 $n = 2$：
  - 可以切割为 2（收益 5）或 1 + 1（不允许）。
  - 最优解为 2（收益 5）。
- 子问题 $n = 1$：
  - 只能切割为 1（收益 1）。

**组合子问题的最优解**：

- 选择第一刀为 1，剩下 2：
  - 子问题 $n = 2$ 的最优解是 2（收益 5）。
  - 总收益：$1 + 5 = 6$。
  - 检查限制：
    - 使用 1 段 1 和 1 段 2（均允许）。
    - 可行。
- 选择第一刀为 2，剩下 1：
  - 子问题 $n = 1$ 的最优解是 1（收益 1）。
  - 总收益：$5 + 1 = 6$。
  - 检查限制：
    - 使用 1 段 2 和 1 段 1（均允许）。
    - 可行。
- 最优解 3（不切割）无法通过组合子问题的最优解得到。

**结论**：

- 子问题的最优解组合只能得到收益 6。
- 原问题的最优解是 8（不切割）。
- 因此，最优子结构不成立。

**正式证明**

为了更正式地证明最优子结构不成立，我们需要说明：

- 存在原问题的最优解，不能通过组合子问题的最优解得到。

- 在上面的反例中：
  - 原问题 $n = 3$ 的最优解是 3（收益 8）。
  - 子问题 $n = 2$ 的最优解是 2（收益 5），子问题 $n = 1$ 的最优解是 1（收益 1）。
  - 组合子问题的最优解只能得到 $1 + 2$ 或 $2 + 1$，收益 6。
  - 无法通过组合子问题的最优解得到原问题的最优解 3（因为 3 不是由于子问题组合而来）。

因此，最优子结构性质不再成立。

**从理论上说明**：

为了从理论上证明当引入切割段数限制后，钢条切割问题的最优子结构性质不再成立，我们需要说明以下几点：

1. **最优子结构的定义**：一个问题具有最优子结构性质，当且仅当其最优解可以通过组合其子问题的最优解来构造。
2. **限制条件的影响**：限制每种长度的切割段数会引入全局约束，使得子问题的解之间相互依赖。
3. **子问题独立性**：原始问题中，子问题的解是独立的；但在限制条件下，子问题的解会影响其他子问题的可行性。

以下是理论证明的步骤：

1. **原始问题的最优子结构**

原始钢条切割问题（无限制）的动态规划递归式为：

$$
r(n) = \max_{1 \leq i \leq n} (p_i + r(n - i))
$$

其中：
- $r(n)$：长度为 $n$ 的钢条的最大收益。
- $p_i$：长度为 $i$ 的钢条的价格。

**最优子结构成立**：因为 $r(n)$ 的解仅依赖于子问题 $r(n-i)$ 的解，且子问题之间完全独立。

2. **限制条件下的问题描述**

加入限制后：

- 设 $l_i$ 为长度 $i$ 的钢条最多可切割的段数。
- 定义状态不仅要记录剩余长度，还需要记录各长度的钢条可用段数。

此时，问题的状态为 $(L, c)$，其中：
- $L$：剩余钢条长度。
- $c = (c_1, c_2, \ldots, c_{n-1})$：长度为 $i$ 的钢条剩余可切割段数（初始时 $c = l_i$）。

递归式需修改为：

$$
r(L, c) = \max_{1 \leq i \leq L} (p_i + r(L - i, c - e_i))
$$

其中 $e_i$ 是第 $i$ 个位置为 1 的单位向量（表示消耗一段长度为 $i$ 的钢条）。

3. **最优子结构性质的破坏**

在限制条件下，以下性质导致最优子结构不成立：

(1) **子问题的解受全局约束影响**
   - 子问题 $r(L - i, c - e_i)$ 的解依赖于父问题对 $c$ 的修改。
   - 父问题的切割选择会限制子问题的可用切割方式，反之亦然。

(2) **子问题的最优解无法自由组合**
   - 设父问题的最优解为切割长度为 $i$ 和 $j$ 的钢条。
   - 子问题 $r(n - i, c - e_i)$ 的最优解可能使用了长度为 $j$ 的钢条，导致父问题无法再切割长度为 $j$ 的钢条（因为 $c_j$ 已耗尽）。
   - 因此，父问题可能需要选择子问题的非最优解（避免使用 $j$），从而无法通过子问题的最优解组合得到全局最优解。

(3) **反例的理论抽象**
   从反例中抽象出一般规律：
   - 设存在长度 $i$ 和 $j$，且 $l_i = l_j = 1$。
   - 父问题的最优解需要同时切割 $i$ 和 $j$（例如 $n = i + j$）。
   - 子问题 $r(i)$ 的最优解可能是直接使用 $i$（不切割），而子问题 $r(j)$ 的最优解可能是直接取 $p_j$（不切割）。
   - 但父问题的最优解需要切割为 $i + j$，而子问题的最优解未提供这种切割方式。

4. **形式化矛盾**

假设最优子结构成立，则：

$$
r(n, l) = \max (p_i + r(n - i, l - e_i))
$$

但实际上可能存在：

$$
r(n, l) = p_k + r(n - k, l - e_k)
$$

其中 $r(n - k, l - e_k)$ 不是子问题 $r(n - k, l)$ 的最优解（因为后者未考虑 $e_k$ 的限制）。

5. **结论**

- 由于子问题的解依赖于父问题的切割选择（即全局约束 $c$），而子问题的最优解无法预知父问题的约束，因此：
  - 无法保证子问题的最优解能组合出原问题的最优解。
- **最优子结构性质被破坏**。

这与无限制问题的性质形成鲜明对比：在无限制问题中，子问题完全独立；而在限制问题中，子问题相互耦合。

---

>**15.3-6** 假定你希望兑换外汇，你意识到与其直接兑换，不如进行多种外币的一系列兑换，最后兑换到你想要的那种外币，可能会获得更大收益。假定你可以交易 $n$ 种不同的货币，编号为 1, 2, …, $n$，兑换从 1 号货币开始，最终兑换为 $n$ 号货币。对每两种货币 $i$ 和 $j$，给定汇率 $r_{ij}$，意味着你如果有 $d$ 个单位的货币 $i$，可以兑换 $d \cdot r_{ij}$ 个单位的货币 $j$。进行一系列的交易需要支付一定的佣金，金额取决于交易的次数。令 $c_k$ 表示 $k$ 次交易需要支付的佣金。证明：如果对所有 $k=1,2,\cdots, n$，$c_k=0$，那么寻找最优兑换序列的问题具有最优子结构性质。然后请证明：如果佣金 $c_k$ 为任意值，那么问题不一定具有最优子结构性质。

==证明问题具有最优子结构性质：==

**情况 1：$c_k = 0$（无佣金）**

证明问题具有最优子结构性质：

假设从货币 1 到货币 $n$ 的最优兑换序列为 $1 \rightarrow i_2 \rightarrow \ldots \rightarrow i_m \rightarrow n$，其总兑换量为 $d = r_{1i_2} \cdot r_{i_2i_3} \cdot \ldots \cdot r_{i_mn}$。

我们需要证明：

- **子序列 $1 \rightarrow i_1 \rightarrow \ldots \rightarrow k$ 必须是从 1 到 k 的最优兑换序列。**
- **子序列 $k \rightarrow \ldots \rightarrow n$ 必须是从 k 到 n 的最优兑换序列。**

**反证法**：

假设存在一个子序列 $1 \rightarrow \ldots \rightarrow k$ 不是最优的，即存在另一个兑换序列 $1 \rightarrow \ldots \rightarrow k$ 能获得更多的货币 $k$。那么我们可以用这个更优的子序列替换原序列中的对应部分，从而得到从 1 到 $n$ 的最优兑换序列，这与原序列为最优的假设矛盾。因此，子序列必须是最优的。

同理，子序列 $k \rightarrow \ldots \rightarrow n$ 也必须是最优的。

因此，当 $c_k = 0$ 时，问题具有最优子结构性质。

**情况 2：$c_k$ 为任意值**

证明问题不一定具有最优子结构性质：

我们需要构造一个例子，说明最优解不能简单地通过组合子问题的最优解得到。

构造反例：

设 $n = 3$（货币 1, 2, 3），汇率如下：

- $r_{12} = 1, r_{13} = 2, r_{23} = 1$。

佣金定义：

- $c_1 = 0$（直接兑换，无交易，佣金为 0）。
- $c_2 = 0.5$（进行一次交易，佣金为 0.5）。
- $c_3 = 1$（进行两次交易，佣金为 1）。

初始持有 $d = 1$ 单位货币 1。

可能的兑换序列：

1. 直接兑换 $1 \rightarrow 3$：
   - 交易次数：1（$c_2 = 0.5$）。
   - 最终金额：$1 \cdot r_{13} - c_2 = 2 - 0.5 = 1.5$。
2. 间接兑换 $1 \rightarrow 2 \rightarrow 3$：
   - 交易次数：2（$c_3 = 1$）。
   - 最终金额：$1 \cdot r_{12} \cdot r_{23} - c_3 = 1 \cdot 1 \cdot 1 - 1 = 0$。

显然，直接兑换 $1 \rightarrow 3$ 是最优的，最终金额为 1.5。

**子问题分析：**

- 子问题 1 → 2：
  - 直接兑换：$1 \cdot r_{12} - c_2 = 1 - 0.5 = 0.5$。
  - 无其他兑换方式。
  - 最优解为 0.5。
- 子问题 2 → 3：
  - 直接兑换：$1 \cdot r_{23} - c_2 = 1 - 0.5 = 0.5$。
  - 无其他兑换方式。
  - 最优解为 0.5。

尝试组合子问题的最优解：

从 1 → 2 的最优解是 0.5，然后从 2 → 3 的最优解是 0.5：

- 初始 1 兑换为 0.5 货币 2，然后 0.5 货币 2 兑换为 $0.5 \cdot 1 - 0.5 = 0$ 货币 3。
- 总佣金：$c_3 = 1$（两次交易）。
- 最终金额：0。

这与直接兑换 $1 \rightarrow 3$ 的最优解 1.5 矛盾。因此，组合子问题的最优解无法得到全局最优解。

**结论**：

- 当佣金 $c_k$ 为任意值时，子问题的最优解在组合时可能无法得到全局最优解，因为佣金的引入破坏了子问题的独立性。因此，问题不一定具有最优子结构性质。

**总结**

1. **无佣金（$c_k = 0$）**：
   - 最优兑换序列可以通过组合子问题的最优解构造。
   - 具有最优子结构性质。
2. **有佣金（$c_k$ 任意）**：
   - 佣金的存在使得子问题的解相互依赖。
   - 组合子问题的最优解可能无法得到全局最优解。
   - 不一定具有最优子结构性质。

通过构造具体的反例，我们验证了佣金对最优子结构性质的影响。

---

### 练习 15.4

>**15.4-1** 求 $\langle 1, 0, 0, 1, 0, 1, 0, 1 \rangle$ 和 $\langle 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0 \rangle$ 的一个 LCS。

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class Solution {
public:
    string longestCommonSubsequence(string text1, string text2) {
        int m = text1.length();     // m为text1的长度
        int n = text2.length();     // n为text2的长度
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));     // dp[i][j]表示text1的前i个字符和text2的前j个字符的最长公共子序列的长度
        for(int i=0;i<=m;i++){
            for(int j=0;j<=n;j++){
                if(i==0 || j==0){       // 边界条件,dp[0][j]和dp[i][0]都为0
                    dp[i][j] = 0;
                }else if(text1[i-1] == text2[j-1]){     // 如果text1[i-1]和text2[j-1]相同,则最长公共子序列长度为dp[i-1][j-1]+1
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{// 如果text1[i-1]和text2[j-1]不同,则最长公共子序列长度为max(dp[i-1][j],dp[i][j-1])
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        int index = dp[m][n];
        string result(index,' ');
        int i = m, j = n;
        while(i>0 && j>0){
            if(text1[i-1] == text2[j-1]){
                result[index-1] = text1[i-1];
                i--;
                j--;
                index--;
            }else if(dp[i-1][j] > dp[i][j-1]){
                i--;
            }else{
                j--;
            }
        }
        return result;
    }
};

int main() {
    Solution s;
    string text1 = "10010101";
    string text2 = "010110110110";
    cout << s.longestCommonSubsequence(text1, text2) << endl;
    return 0;
}
```

0010101

运行上面代码，得到二者 LCS 为“0010101”，主要思想是采用动态规划，通过避免重复求解相同子问题来简化计算量。用二维数组 dp [i][j] 来表示字符串 text1 的前 i 个字符和字符串 text2 的前 j 个字符的最长公共子序列长度，则可以得到递推关系，如果 `text1[i-1]==text2[j-1]`，也就是两个字符串当前对应元素相等，则 `dp[i][j]=dp[i-1][j-1]+1`，也就是两个字符串的最长公共子序列长度比之前加 1；如果 `text1[i-1]!=text2[j-1]`，也就是两个字符串当前对应元素不相等，则 `dp[i][j] = max(dp[i-1][j],dp[i][j-1])`，也就是选择不使用 text1 或不使用 text2 当前元素的情况下的最长公共子序列长度的较大者。

---

> **15.4-2** 设计伪代码，利用完整的表 $c$ 及原始序列 $X = \langle x_1, x_2, \cdots, x_m \rangle$ 和 $Y = \langle y_1, y_2, \cdots, y_n \rangle$ 来重构 LCS，要求运行时间为 $O(m+n)$，不能使用表 $b$。

以下是通过表 $c$ 来重构获取最长公共子序列的伪代码，运行时间为 $O(max(m,n))$，不超过 $m+n$

核心原理是如果当前 $X$ 和 $Y$ 的字符相等，则当前字符一定是最长公共子序列的一部分，如果不相等，根据 `c[i-1][j]` 和 `c[i][j-1]` 的大小关系，确定当时寻找最长公共子序列时是哪个字符串跳过了当前字符，就将哪个字符串对应的索引减 1，来跳过当前字符，向前寻找下一个 $X$ 和 $Y$ 对应相等的字符

```cpp
get_LCS(X, Y, c):
		    int i = X.length; int j = Y.lengrh;	  // 获取原始序列长度
		    int index = c[m][n];  // 原始序列X和Y的最长公共子序列长度
    string result(index,' ');  // 初始化X和Y的最长公共子序列为index个空格
	    while(i>0 && j>0){
	        if(X[i-1] == Y[j-1]){  // 倒序遍历X和Y，如果X和Y当前字符相等，则将当前字符加入到结果result中，同时i和j都减1
            result[index-1] = X[i-1];
            i--;
            j--;
            index--;
        }
        else if(c[i-1][j] > c[i][j-1]){  // 如果X和Y当前字符不相等，去掉X当前字符的情况下，最长公共子序列长度更大，则i--才能找到对应相等的字符
            i--;
        }
        else{
            j--;
        }
    return result;
```

---

> **15.4-3** 设计 LCS-LENGTH 的带备忘的版本，运行时间为 $O(mn)$。

```cpp
LCS-LENGTH(X,Y)
    m = X.length
    n = Y.length
    let b[1..m,1..n] and c[0..m,0..n] be new tables
    for i = 1 to m
        c[i,0] = 0
    for j = 0 to n
        c[0,j] = 0
    for i = 1 to m
        for j = 1 to n
            if x_i == y_j
                c[i,j] = c[i-1,j-1] + 1
                b[i,j] = "↖"
            else if c[i-1,j] >= c[i,j-1]
                c[i,j] = c[i-1,j]
                b[i,j] = "↑"
            else c[i,j] = c[i,j-1]
                b[i,j] = "←"
    return c and b
```

上面是书中 LCS-LENGTH 实现求两个字符串的最长公共子序列长度的动态规划版本，现在我们要实现带备忘的版本（可参考 P208 矩阵链乘法的带备忘实现），基本原理是初始化所有子问题解为一个特殊值，如果查到该子问题解为特殊值，说明当前子问题还没有经过计算，需要先经过计算得到该子问题的解，下次调用该子问题的解的时候就可以直接通过查表获取，而不需要重复计算。

```cpp
MEMOIZED-LCS-LENGTH(X, Y)
    m = X.length
    n = Y.length
    let c[0..m, 0..n] be a new table initialized with -1  // 初始化为-1表示未计算，无法通过查表简化计算
    let b[1..m, 1..n] be a new table for arrows
    
    // Initialize base cases
    for i = 0 to m
        c[i, 0] = 0
    for j = 0 to n
        c[0, j] = 0
    
    // Start the memoized calculation
    LCS-LENGTH-AUX(X, Y, m, n, c, b)
    
    return c and b

LCS-LENGTH-AUX(X, Y, i, j, c, b)
    if c[i, j] >= 0  // Already computed
        return c[i, j]
    
    if X[i-1] == Y[j-1]  // Strings are 0-indexed
        c[i, j] = LCS-LENGTH-AUX(X, Y, i-1, j-1, c, b) + 1
        b[i, j] = "↖"
    else
        left = LCS-LENGTH-AUX(X, Y, i-1, j, c, b)
        up = LCS-LENGTH-AUX(X, Y, i, j-1, c, b)
        if left >= up
            c[i, j] = left
            b[i, j] = "↑"
        else
            c[i, j] = up
            b[i, j] = "←"
    
    return c[i, j]
```

---

>**15.4-4** 说明如何只使用表 $c$ 中 $2 \times \min(m, n)$ 个表项及 $O(1)$ 的额外空间来计算 LCS 的长度。然后说明如何只用 $\min(m, n)$ 个表项及 $O(1)$ 的额外空间完成相同的工作。

**方法一：使用 2×min(m, n)表项和 O(1)额外空间**

**方法说明**

我们可以利用 LCS 问题的以下性质来优化空间：
1. 计算 c [i, j] 时只需要前一行的数据(c [i-1,·])和当前行已计算的数据(c [i,·])
2. 可以交替使用两行来存储当前和前一行数据

**实现步骤**

1. 假设 $m ≥ n$（否则交换 X 和 Y）
2. 创建两个长度为 $n$ 的数组：`prev` 和 `curr`，prev 表示前一行的数据，curr 表示当前行的数据
3. 初始化 `prev` 为全 0（对应 c [0, j]）
4. 按行处理：
   - 对于每行 i，`curr[0] = 0`（对应 c [i,0]）
   - 对于每列 j：
     - 如果 X [i-1] == Y [j-1]，`curr[j] = prev[j-1] + 1`
     - 否则 `curr[j] = max(prev[j], curr[j-1])`
5. 处理完行 i 后，交换 `prev` 和 `curr` 的角色

**伪代码**

```cpp
LCS-LENGTH-2ROWS(X, Y)
    m = X.length
    n = Y.length
    if m < n
        swap X and Y
        swap m and n
    
    let prev[0..n] and curr[0..n] be new arrays
    for j = 0 to n
        prev[j] = 0
    
    for i = 1 to m
        curr[0] = 0
        for j = 1 to n
            if X[i-1] == Y[j-1]
                curr[j] = prev[j-1] + 1
            else
                curr[j] = max(prev[j], curr[j-1])
        swap(prev, curr)
    
    return prev[n]
```

**空间分析**

- 使用 $2×(n+1)$ 表项（假设 $n ≤ m$）
- 额外空间：$O(1)$（仅用于交换等操作）

**方法二：使用 $min(m, n)$ 表项和 $O(1)$ 额外空间**

**方法说明**

进一步观察发现，我们可以在单行内完成计算，==通过从右向左更新来避免覆盖还未使用的数据==。

**实现步骤**

1. 假设 $m ≥ n$（否则交换 X 和 Y）
2. 创建一个长度为 $n$ 的数组 `dp`
3. 初始化 `dp` 为全 0
4. 按行处理：
   - 保存 `dp[0]` 的旧值（对应 **c [i-1, j-1]**）
   - 对于每列 j 从 1 到 n：
     - 保存 `dp[j]` 的旧值（将成为下一个 j 的左上值）
     - 如果 X [i-1] == Y [j-1]，`dp[j] = old_diagonal + 1`
     - 否则 `dp[j] = max(dp[j], dp[j-1])`
     - 更新 `old_diagonal` 为保存的旧值

**伪代码**

```cpp
LCS-LENGTH-1ROW(X, Y)
    m = X.length
    n = Y.length
    if m < n
        swap X and Y
        swap m and n
    
    let dp[0..n] be new array
    for j = 0 to n
        dp[j] = 0
    
    for i = 1 to m
        old_diagonal = dp[0]  // corresponds to c[i-1,0] = 0
        dp[0] = 0  // corresponds to c[i,0] = 0
        for j = 1 to n
            temp = dp[j]
            if X[i-1] == Y[j-1]
                dp[j] = old_diagonal + 1
            else
                dp[j] = max(dp[j], dp[j-1])
            old_diagonal = temp    // 作为下一轮循环的旧值，相当于dp[j-1]或c[i-1][j-1]
    
    return dp[n]
```

**空间分析**

- 使用 $n+1$ 表项（假设 $n ≤ m$）
- 额外空间：$O(1)$（仅用于 `old_diagonal` 和 `temp` 等临时变量）

**比较**

|  方法   |   表项使用   | 额外空间 |              特点              |
| :-----: | :----------: | :------: | :----------------------------: |
| 原始 DP  |   $O(mn)$    | $O(mn)$  |      简单直观，空间占用大      |
| 2 行方法 | $2×min(m,n)$ |  $O(1)$  |     空间减半，保持行序处理     |
| 1 行方法 |  $min(m,n)$  |  $O(1)$  | 最优空间，需要更复杂的更新顺序 |

这些优化方法在保持 $O(mn)$ 时间复杂度的同时，显著减少了空间使用，特别适合处理大规模字符串。

---

> **15.4-5** 设计一个 $O(n^2)$ 时间的算法，求一个 $n$ 个数的序列的最长单调递增子序列。

以下是实现求 n 个数的序列的最长单调递增子序列的 C++实现，求最长递增子序列的长度可以通过动态规划来实现，dp [i] 表示到第 i 个数为止的最长递增子序列长度，外部循环从 i = 1 开始遍历 nums 数组的每一个位置，内部循环从 j = 0 开始遍历到外部的 i，如果 nums [j] < nums [i]，则 dp [i] = max(dp [i], dp [j]+1)，也就是选择是不是用当前位置 j 的元素作为最长单调递增子序列的一部分，如果使用位置 j 的元素单调递增子序列长度更大，则使用位置 j 的元素，dp [i] 就等于 dp [j]+1，如果使用位置 j 的元素，则 dp [i] 不变；

第二部分是通过回溯算法来获取这 n 个数的序列的所有最长递增子序列，保存在 result 中，每个元素是最长单调递增子序列的一种。遍历 nums 中每一个元素，从每个位置 i 开始搜索，将当前位置 i 的元素 nums [i] 加入到当前组合中，然后调用回溯函数 `backtrack(i + 1, nums[i], 1)`，终止条件为当前组合长度等于最长递增子序列长度，如果还没达到最长递增子序列长度，则从 i+1 开始继续搜索，如果 i+1 位置元素比位置 i 元素大，也就是 `nums[i] > prevVal`（这里 nums [i] 就是 nums [i+1]，preVal 就是 nums [i]），则将当前 i+1 位置的元素加入到当前组合中，然后递归调用回溯函数，判断是否满足终止条件，如果不满足终止条件，则继续搜索下一个位置，看下一个元素是否更大，如果更大，就加入到当前组合 current 中，否则退出当前递归函数，并删除 current 末尾元素；如果 i+1 位置元素不比位置 i 元素大，则当前回溯函数结束，继续 for 循环，i 增加，也就是跳过当前元素，选择下一个元素加入到当前组合中，然后继续调用回溯函数。

```cpp
class Solution {
public:
    vector<vector<int>> findAllLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1);
        int maxLen = 1;
        
        // 计算最长递增子序列长度和每个位置的长度
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    if (dp[j] + 1 > dp[i]) {
                        dp[i] = dp[j] + 1;
                    }
                }
            }
            maxLen = max(maxLen, dp[i]);  // 截至到当前索引的最长递增子序列长度
        }
        
        // 回溯找出所有最长递增子序列
        vector<vector<int>> result;
        vector<int> current;
        
        function<void(int, int, int)> backtrack = [&](int index, int prevVal, int length) {
            // 成功找到一个最长子序列
            if (length == maxLen) {
                result.push_back(current);
                return;
            }
            
            // 继续搜索
            for (int i = index; i < n; i++) {
                // 满足递增条件
                if (nums[i] > prevVal) {
                    current.push_back(nums[i]);
                    backtrack(i + 1, nums[i], length + 1);
                    current.pop_back();
                }
            }
        };
        
        // 从每个可能的起点开始搜索
        for (int i = 0; i < n; i++) {
            current = {nums[i]};
            backtrack(i + 1, nums[i], 1);
        }
        
        return result;
    }
};
```

寻找最长递增子序列长度的时间复杂度为 $O(n^2)$，空间复杂度为 $O(n)$

获取所有最长递增子序列的时间复杂度为 $O(n^2)$，空间复杂度是 $O(n)$

---

**15.4-6** 设计一个 $O(n \log n)$ 时间的算法，求一个 $n$ 个数的序列的最长单调递增子序列。（提示：注意到，一个长度为 $i$ 的候选子序列的尾元素至少不比一个长度为 $i-1$ 候选子序列的尾元素小。因此，可以在输入序列中将候选子序列链接起来。）

使用二分查找的方式获取 n 个数的序列的最长单调递增子序列长度，时间复杂度为 $O(n\log(n))$

核心思想是使用 tails 容器存储 **相同长度的子序列中可能的最小末尾元素**，遍历完 nums 后，获取的 tails 的长度就是最长递增子序列的长度。初始情况下，tails 为空，首先将 nums 的第一个元素加入到 tails 中，然后继续遍历 nums 中每一个元素 num，如果当前 num 比 tails.back()也就是 tails 中最后一个元素大，则直接加入到 tails 中；如果当前 num 不大于 tails 中最后一个元素，则使用 lower_bound 函数找到 tails 中第一个大于等于 num 的元素的位置 it，然后使用 num 替换*it，替换是为了保持更多可能的递增子序列选择，相当于用后面出现的更小的元素替换前面较大的元素，以维持递增子序列的递增。

tails 中维护的数组一定是递增的，且元素是所有最长单调递增子序列中最小的，执行完毕后 tail 数组就是 nums 的最长单调递增子序列的一个

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// 返回最长递增子序列的长度
int lengthOfLIS(vector<int>& nums) {
    if (nums.empty()) return 0;
    
    vector<int> tail; // tail[i]表示长度为i+1的LIS的最小末尾元素
    
    for (int num : nums) {
        // 使用二分查找找到第一个不小于num的元素位置
        auto it = lower_bound(tail.begin(), tail.end(), num);
        
        if (it == tail.end()) {
            // num比所有末尾元素都大，可以扩展最长子序列
            tail.push_back(num);
        } else {
            // 替换第一个不小于num的元素，保持最小末尾性质
            *it = num;
        }
    }
    
    return tail.size();
}

// 如果需要返回具体的LIS序列
vector<int> getLIS(vector<int>& nums) {
    if (nums.empty()) return {};
    
    vector<int> tail; // 存储最小末尾元素
    vector<int> parent(nums.size()); // 记录前驱元素索引
    vector<int> indices(nums.size()); // tail中元素对应的原数组索引
    
    for (int i = 0; i < nums.size(); ++i) {
        int num = nums[i];
        auto it = lower_bound(tail.begin(), tail.end(), num);
        int pos = it - tail.begin();
        
        if (it == tail.end()) {
            tail.push_back(num);
        } else {
            *it = num;
        }
        
        indices[pos] = i;
        parent[i] = (pos > 0) ? indices[pos-1] : -1;
    }
    
    // 反向构建LIS序列
    vector<int> lis(tail.size());
    int curr = indices[tail.size()-1];
    for (int i = lis.size()-1; i >= 0; --i) {
        lis[i] = nums[curr];
        curr = parent[curr];
    }
    
    return lis;
}

int main() {
    vector<int> nums = {10, 9, 2, 5, 3, 7, 101, 18};
    
    int length = lengthOfLIS(nums);
    cout << "Length of LIS: " << length << endl;
    
    vector<int> lis = getLIS(nums);
    cout << "One possible LIS: ";
    for (int num : lis) {
        cout << num << " ";
    }
    cout << endl;
    
    return 0;
}
```



---

### 练习 15.5

>**15.5-1** 设计伪代码 CONSTRUCT-OPTIMAL-BST($root$)，输入为表 $root$，输出是最优二叉搜索树的结构。例如，对图 15-10 中的 $root$ 表，应输出
>
>- $k_2$ 为根
>- $k_1$ 为 $k_2$ 的左孩子
>- $d_0$ 为 $k_1$ 的左孩子
>- $d_1$ 为 $k_1$ 的右孩子
>- $k_5$ 为 $k_2$ 的右孩子
>- $k_4$ 为 $k_3$ 的左孩子
>- $k_3$ 为 $k_4$ 的左孩子
>- $d_2$ 为 $k_3$ 的左孩子
>- $d_3$ 为 $k_3$ 的右孩子
>- $d_4$ 为 $k_4$ 的右孩子
>- $d_5$ 为 $k_5$ 的右孩子
>
>与图 15-9(b) 中的最优二叉搜索树对应。

图 15-9 如下所示：

<img src="F:\software\Typora\images\image-20250403230316218.png" alt="image-20250403230316218" style="zoom:67%;" />

```cpp
OPTIMAL-BST(p, q, n)
    // e[i,j]为k_i到k_j节点构成的最优二叉搜索树的期望搜索代价，也就是子问题的最优解
    // w[i,j]为k_i到k_j节点的出现概率之和
    // root[i,j]保存根节点k_r在原数组中的下标，也就是k_i到k_j节点构成的最优二叉搜索树的根节点，相当于子问题最优解对应的具体构树方案
    let e[1..n+1, 0..n], w[1..n+1, 0..n], and root[1..n, 1..n] be new tables
    for i = 1 to n + 1
        e[i, i-1] = q_i-1
        w[i, i-1] = q_i-1
    for l = 1 to n
        for i = 1 to n - l + 1
            j = i + l - 1
            e[i, j] = ∞
            w[i, j] = w[i, j-1] + p_j + q_j
        for r = i to j
            t = e[i, r-1] + e[r+1, j] + w[i, j]
            if t < e[i, j]
                e[i, j] = t
                root[i, j] = r
    return e and root
```

上述是利用动态规划算法实现最优二叉搜索树的伪代码，基本原理是求解任意长度的子数组构成的最优二叉搜索树的期望搜索代价和根节点，作为子问题的最优解保存，从而实现自底向上，求解所有子问题（任意长度数组、选择任意节点为根节点）时避免某些子问题多次重复求解，从而提高效率。

下面讨论如何通过 `OPTIMAL-BST(p, q, n)` 求出的最优构树方案 root，来构建最优二叉搜索树，继而输出该最优二叉搜索树的树结构。很容易想到，root [1, n] = r 保存了 n 个关键字构成的序列可以构成的最优二叉搜索树的根节点，因此 root [1, n] 是整棵最优二叉搜索树的根节点，根据最优二叉搜索树的最优子结构性质，它的左子树和右子树也是最优二叉搜索树，且根节点分别为 root [1, r-1] 和 root [r+1, n]，这样就得到了整棵最优二叉搜索树的根节点和左、右子节点，依此类推，即可得到所有的节点和原序列中的关键点的对应关系。

具体实现伪代码如下：

```cpp
CONSTRUCT-OPTIMAL-BST(root)
    n = root.length  // 假设 root 是 n x n 的表，索引从 1 到 n
    return CONSTRUCT-SUBTREE(root, 1, n, NIL, NIL)  // NIL 表示无父节点或方向未定

CONSTRUCT-SUBTREE(root, i, j, parent, direction)
    if i > j
        if parent != NIL
            print "d_{j}" 为 "parent" 的 "direction" 孩子
        else
            print "d_{j}" 为根    //（仅当整棵树为空时可能，通常不会发生）
        return
    r = root[i][j]
    if parent == NIL
        print "k_{r}" 为根
    else
        print "k_{r}" 为 "parent" 的 "direction" 孩子
    CONSTRUCT-SUBTREE(root, i, r - 1, "k_{r}", "左")  // 左子树
    CONSTRUCT-SUBTREE(root, r + 1, j, "k_{r}", "右")  // 右子树
```

**具体C++实现如下：**

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <climits>

using namespace std;

// 构建最优二叉搜索树
void OPTIMAL_BST(const vector<double>& p, const vector<double>& q, int n,
                 vector<vector<double>>& e, vector<vector<double>>& w,
                 vector<vector<int>>& root) {
    // 初始化 e 和 w 表
    e.resize(n + 2, vector<double>(n + 1, 0));
    w.resize(n + 2, vector<double>(n + 1, 0));
    root.resize(n + 1, vector<int>(n + 1, 0));

    // 初始化 e[i][i-1] 和 w[i][i-1]
    for (int i = 1; i <= n + 1; ++i) {
        e[i][i - 1] = q[i - 1];
        w[i][i - 1] = q[i - 1];
    }

    // 动态规划填充 e, w 和 root 表
    for (int l = 1; l <= n; ++l) {  // l 是子问题的长度
        for (int i = 1; i <= n - l + 1; ++i) {
            int j = i + l - 1;
            e[i][j] = INT_MAX;
            w[i][j] = w[i][j - 1] + p[j] + q[j];

            // 尝试所有可能的根节点 r
            for (int r = i; r <= j; ++r) {
                double t = e[i][r - 1] + e[r + 1][j] + w[i][j];
                if (t < e[i][j]) {
                    e[i][j] = t;
                    root[i][j] = r;
                }
            }
        }
    }
}

// 递归构建最优二叉搜索树的结构
void CONSTRUCT_SUBTREE(const vector<vector<int>>& root, int i, int j,
                       const string& parent, const string& direction) {
    if (i > j) {
        if (parent != "NIL") {
            cout << "d_" << j << " 为 " << parent << " 的 " << direction << "孩子" << endl;
        } else {
            cout << "d_" << j << " 为根" << endl;  // 通常不会发生
        }
        return;
    }

    int r = root[i][j];
    if (parent == "NIL") {
        cout << "k_" << r << " 为根" << endl;
    } else {
        cout << "k_" << r << " 为 " << parent << " 的 " << direction << "孩子" << endl;
    }

    // 递归构建左子树和右子树
    CONSTRUCT_SUBTREE(root, i, r - 1, "k_" + to_string(r), "左");
    CONSTRUCT_SUBTREE(root, r + 1, j, "k_" + to_string(r), "右");
}

// 输出最优二叉搜索树的结构
void CONSTRUCT_OPTIMAL_BST(const vector<vector<int>>& root, int n) {
    CONSTRUCT_SUBTREE(root, 1, n, "NIL", "NIL");
}

int main() {
    // 示例数据（图15-10中的概率）
    vector<double> p = {0, 0.15, 0.10, 0.05, 0.10, 0.20};  // p[1..n]
    vector<double> q = {0.05, 0.10, 0.05, 0.05, 0.05, 0.10}; // q[0..n]
    int n = 5;  // 关键字的数量

    vector<vector<double>> e, w;
    vector<vector<int>> root;

    // 构建最优二叉搜索树
    OPTIMAL_BST(p, q, n, e, w, root);

    // 输出最优二叉搜索树的结构
    cout << "最优二叉搜索树的结构：" << endl;
    CONSTRUCT_OPTIMAL_BST(root, n);

    return 0;
}
```



---

>**15.5-2** 若 7 个关键字的概率如下所示，求其最优二叉搜索树的结构和代价。
>
>|  $i$  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
>| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
>| $p_i$ |      | 0.04 | 0.06 | 0.08 | 0.02 | 0.10 | 0.12 | 0.14 |
>| $q_i$ | 0.06 | 0.06 | 0.06 | 0.06 | 0.05 | 0.05 | 0.05 | 0.05 |

根据15.5-1实现的最优二叉搜索树的期望搜索代价和构树方案，带入表中数据即可得到如下输出

```
最优二叉搜索树的期望搜索代价为： 3.12
最优二叉搜索树的结构：
k_5 为根
k_2 为 k_5 的 左孩子
k_1 为 k_2 的 左孩子
d_0 为 k_1 的 左孩子
d_1 为 k_1 的 右孩子
k_3 为 k_2 的 右孩子
d_2 为 k_3 的 左孩子
k_4 为 k_3 的 右孩子
d_3 为 k_4 的 左孩子
d_4 为 k_4 的 右孩子
k_7 为 k_5 的 右孩子
k_6 为 k_7 的 左孩子
d_5 为 k_6 的 左孩子
d_6 为 k_6 的 右孩子
d_7 为 k_7 的 右孩子

F:\learn_source\lqb\算法导论思考题\code\算法导论代码实现\x64\Debug\算法导论代码实现.exe (进程 10668)已退出，代码为 0 (0x0)。
按任意键关闭此窗口. . .
```

---

> **15.5-3** 假设 OPTIMAL-BST 不维护表 $w[i, j]$，而是在第 9 行利用公式 (15.12) 直接计算 $w(i, j)$，然后在第 11 行使用此值。如此改动会对渐近时间复杂性有何影响？

<img src="F:\software\Typora\images\image-20250404194234894.png" alt="image-20250404194234894" style="zoom:67%;" />

<img src="F:\software\Typora\images\image-20250404194450329.png" alt="image-20250404194450329" style="zoom:67%;" />

第9行使用式15.12计算w[i.j]来代替存储表w直接查询，相当于在中层循环内增加了计算w[i,j]的复杂度，计算复杂度为O(l)，和最内层循环复杂度一致，所以整体上渐进复杂度不变。

---

> **15.5-4** Knuth [212] 已经证明，对所有 $1 \leqslant i < j \leqslant n$，存在最优二叉搜索树，其根满足 $root[i, j-1] \leqslant root[i, j] \leqslant root[i+1, j]$。利用这一特性修改算法 OPTIMAL-BST，使得运行时间减少为 $\Theta(n^2)$。

```cpp
OPTIMAL-BST-KNUTH(p, q, n):
    // Initialize tables
    let e[1..n+1, 0..n], w[1..n+1, 0..n], root[1..n, 1..n] be new tables

    // Base case: empty subtrees (only dummy keys)
    for i = 1 to n+1:
        e[i, i-1] = q[i-1]
        w[i, i-1] = q[i-1]

    // Fill tables for subtrees of length l = 1 to n
    for l = 1 to n:
        for i = 1 to n - l + 1:
            j = i + l - 1
            e[i, j] = ∞
            w[i, j] = w[i, j-1] + p[j] + q[j]

            // Use Knuth's optimization to narrow down root candidates
            if i == j:
                root[i, j] = i  // single key, root is itself
            else:
                // Search r only in [root[i, j-1], root[i+1, j]]
                lower = root[i, j-1]
                upper = root[i+1, j] if (i+1 <= j) else j

                for r = lower to upper:
                    t = e[i, r-1] + e[r+1, j] + w[i, j]
                    if t < e[i, j]:
                        e[i, j] = t
                        root[i, j] = r

    return e and root
```

**Knuth 优化后的时间复杂度证明（$O(n^2)$）**

为了证明 Knuth 优化后的 OPTIMAL-BST 算法的时间复杂度是 $O(n^2)$，我们需要分析其算法中根节点搜索范围的总和。以下是详细证明：

**1. 算法回顾（Knuth 优化版）**

- **输入**：关键字概率 $p[1..n]$，虚拟键概率 $q[0..n]$。
- **输出**：期望搜索成本表 $e[1..n+1, 0..n]$ 和根表 $root[1..n, 1..n]$。
- **关键优化**：
  - 计算 $root[i,j]$ 时，只需检查：
    - $r \in [root[i,j-1], root[i+1,j]]$
  - 而不是原始算法的 $r \in [i,j]$。

**2. 时间复杂度的核心：根搜索范围的总和**

我们需要计算所有子问题 $(i,j)$ 的根搜索范围的总和：

$$
T(n) = \sum_{i=1}^{n} \sum_{j=i+1}^{n+1} (root[i+1,j] - root[i,j-1] + 1)
$$

其中 $j = i + 1 - 1$。

**关键观察**

Knuth 的单调性性质保证：

- $$root[i,j-1] \leq root[i,j] \leq root[i+1,j]$$

这意味着：

1. 行单调性：$root[i,j] \leq root[i,j+1]$（固定 $i$，随 $j$ 递增）。
2. 列单调性：$root[i,j] \leq root[i+1,j]$（固定 $j$，随 $i$ 递增）。

因此，所有子问题的 $r$ 搜索范围不会重叠太多，总和为 $O(n^2)$。

**3. 严格证明**

**(1) 固定子问题长度 $l$，分析 $\sum_{i=1}^{n-l+1} (root[i+1,j] - root[i,j-1] + 1)$**

对于固定的 $l$，所有子问题 $(i,j)$ 的 $r$ 搜索范围：

$$
R(l) = \sum_{i=1}^{n-l+1} (root[i+1,j] - root[i,j-1] + 1)
$$

由于 $root[i,j]$ 满足行列单调性：

- $root[i,j-1] \leq root[i+1,j]$（Knuth 性质）。

- 因此，$R(l)$ 是一个望远镜求和：

$$
R(l) = root[n-l+2,n] - root[1,l-1] + (n-l+1)
$$

- 由于 $root[i,j] \in [1,n]$，所以 $R(l) \leq n + (n-l+1) = O(n)$。

**(2) 总和 $T(n) = \sum_{l=1}^{n} R(l) = O(n^2)$**

- 对 $l$ 从 1 到 $n$ 求和：

$$
T(n) = \sum_{l=1}^{n} R(l) \leq \sum_{l=1}^{n} (n + (n-l+1)) = O(n^2)
$$

- 更精确的计算：

  - $root[n-l+2,n] - root[1,l-1] \leq n$，
  - $\sum_{l=1}^{n} (n-l+1) = \frac{n(n+1)}{2} = O(n^2)$。

因此，所有子问题的 $r$ 搜索范围总和为 $O(n^2)$。

**4. 均摊分析（每个子问题的 $r$ 搜索是 $O(1)$）**

虽然单个子问题 $(i,j)$ 的 $r$ 搜索范围可能是 $O(n)$（如 $l = n$ 时），但所有子问题的 $r$ 搜索范围总和是 $O(n^2)$，因此：

- 每个子问题的均摊 $r$ 搜索次数是 $O(1)$。
- 总时间复杂度：

$$
O(n^2) \text{（子问题数量）} \times O(1) \text{（均摊搜索）} = O(n^2)
$$

**5. 对比原始算法**

| 算法       | 计算 $root[i,j]$ 的方式                   | 时间复杂度 |
| ---------- | ----------------------------------------- | ---------- |
| 原始算法   | 遍历所有 $r \in [i,j]$                    | $O(n^3)$   |
| Knuth 优化 | 仅遍历 $r \in [root[i,j-1], root[i+1,j]]$ | $O(n^2)$   |

**6. 结论**

- **Knuth 优化**：通过限制 $r$ 的搜索范围，将时间复杂度从 $O(n^3)$ 降为 $O(n^2)$。
- **关键点**：
  1. 单调性性质：$root[i,j-1] \leq root[i,j] \leq root[i+1,j]$。
  2. 填表顺序：按子问题长度 $l$ 从小到大计算，确保依赖的子问题已求解。
  3. 均摊分析：所有子问题的 $r$ 搜索范围总和为 $O(n^2)$。

因此，OPTIMAL-BST 算法的时间复杂度是 $O(n^2)$。



**Knuth 单调性定理的证明**

Knuth 在 1971 年证明了最优二叉搜索树（Optimal BST）的动态规划表中，根节点的选择具有单调性。具体表述为：

**定理（Knuth, 1971）**

对于所有 $1 \leq i < j \leq n$，存在一个最优二叉搜索树，其根节点满足：

$$
root[i, j - 1] \leq root[i, j] \leq root[i + 1, j]
$$

这个性质允许我们将动态规划的时间复杂度从 $O(n^3)$ 优化到 $O(n^2)$。以下是该定理的详细证明。

**1. 基本定义和记号**

- 给定关键字 $k_1 < k_2 < \cdots < k_n$，对应概率 $p_1, p_2, \ldots, p_n$（成功搜索概率）。
- 虚拟键 $d_0, d_1, \ldots, d_n$ 对应概率 $q_0, q_1, \ldots, q_n$（失败搜索概率）。
- $w(i, j) = \sum_{l=i}^{j} p_l + \sum_{l=i}^{j-1} q_l$ 是子树 $(i, j)$ 的总概率。
- $e(i, j)$ 是子树 $(i, j)$ 的最小期望搜索成本。
- $root[i, j]$ 是子树 $(i, j)$ 的最优根节点。

**2. 动态规划递推关系**

原始动态规划方程：

$$
e(i, j) = \min_{1 \leq r \leq j} \{e(i, r - 1) + e(r + 1, j) + w(i, j)\}
$$

其中，$root[i, j]$ 是使上式取最小值的 $r$。

**3. 单调性证明**

我们需要证明：

$$
root[i, j] \leq root[i + 1, j]
$$

设：

- $r_1 = root[i, j]$
- $r_2 = root[i + 1, j]$

假设 $r_1 > r_2$，即 $root[i, j] > root[i + 1, j]$，我们需要导出矛盾。

由于 $r_1$ 是 $(i, j)$ 的最优根，有：

$$
e(i, j) = e(i, r_1 - 1) + e(r_1 + 1, j) + w(i, j)
$$

而 $r_2$ 是 $(i + 1, j)$ 的最优根，有：

$$
e(i + 1, j) = e(i + 1, r_2 - 1) + e(r_2 + 1, j) + w(i + 1, j)
$$

由于 $r_1 > r_2$，可以构造一个新的 BST：

- 在 $(i, j)$ 中选择 $r_2$ 作为根。
- 其期望搜索成本为：

$$
e'(i, j) = e(i, r_2 - 1) + e(r_2 + 1, j) + w(i, j)
$$

由于 $r_2$ 是 $(i + 1, j)$ 的最优根，且 $r_1 > r_2$，可以证明：

$$
e(i, r_2 - 1) + e(r_2 + 1, j) \leq e(i, r_1 - 1) + e(r_1 + 1, j)
$$

（因为 $r_2$ 在 $(i + 1, j)$ 中更优，而 $r_1$ 在 $(i, j)$ 中更优，但 $r_1 > r_2$ 导致矛盾）。

因此，假设 $r_1 > r_2$ 不成立，必须有：

$$
root[i, j] \leq root[i + 1, j]
$$

**(2) 证明 $root[i, j - 1] \leq root[i, j]$**

类似地，设：

- $r_1 = root[i, j - 1]$
- $r_2 = root[i, j]$

假设 $r_1 > r_2$，即 $root[i, j - 1] > root[i, j]$，导出矛盾。

由于 $r_1$ 是 $(i, j - 1)$ 的最优根，有：

$$
e(i, j - 1) = e(i, r_1 - 1) + e(r_1 + 1, j - 1) + w(i, j - 1)
$$

而 $r_2$ 是 $(i, j)$ 的最优根，有：

$$
e(i, j) = e(i, r_2 - 1) + e(r_2 + 1, j) + w(i, j)
$$

由于 $r_1 > r_2$，可以构造一个新的 BST：

- 在 $(i, j)$ 中选择 $r_1$ 作为根。
- 其期望搜索成本为：

$$
e'(i, j) = e(i, r_1 - 1) + e(r_1 + 1, j) + w(i, j)
$$

由于 $r_1$ 是 $(i, j - 1)$ 的最优根，且 $r_1 > r_2$，可以证明：

$$
e(i, r_1 - 1) + e(r_1 + 1, j) \leq e(i, r_2 - 1) + e(r_2 + 1, j)
$$

（因为 $r_1$ 在 $(i, j - 1)$ 中更优，而 $r_2$ 在 $(i, j)$ 中更优，但 $r_1 > r_2$ 导致矛盾）。

因此，假设 $r_1 > r_2$ 不成立，必须有：

$$
root[i, j - 1] \leq root[i, j]
$$

**4. 总结**

- Knuth 的单调性定理表明，最优二叉搜索树的根节点选择满足：

$$
root[i, j - 1] \leq root[i, j] \leq root[i + 1, j]
$$

- 这一性质允许我们在动态规划中限制根节点的搜索范围，从而将时间复杂度从 $O(n^3)$ 优化到 $O(n^2)$。
- 证明的核心是 **反证法**，通过构造更优的 BST 导出矛盾。

**5. 算法优化后的伪代码**

利用 Knuth 单调性优化后的 OPTIMAL-BST 算法：

```python
def OPTIMAL_BST(p, q, n):
    # Initialize tables
    e = [[0] * (n+1) for _ in range(n+2)]
    w = [[0] * (n+1) for _ in range(n+2)]
    root = [[0] * (n+1) for _ in range(n+1)]

    # Base case: empty subtrees
    for i in range(1, n+2):
        e[i][i-1] = q[i-1]
        w[i][i-1] = q[i-1]

    # Fill tables for subtrees of length 1
    for l in range(1, n+1):
        for i in range(1, n-l+1):
            j = i + l - 1
            e[i][j] = float('inf')
            w[i][j] = w[i][j-1] + p[j] + q[j]
            # Use Knuth's optimization to narrow root candidates
            lower = root[i][j-1] if (j > i) else i
            upper = root[i+1][j] if (i < n) else j
            for r in range(lower, upper+1):
                t = e[i][r-1] + e[r+1][j] + w[i][j]
                if t < e[i][j]:
                    e[i][j] = t
                    root[i][j] = r
    return e, root
```

**6. 时间复杂度分析**

- 外层循环 *k*：*O*(*n*)。
- 内层循环 *i*：*O*(*n*)。
- 对于每个 (*i*,*j*)，*r* 的搜索范围是 *roo**t*[*i*,*j*−1] 到 *roo**t*[*i*+1,*j*]，均摊 *O*(1)。
- 因此，总时间复杂度为 Θ(*n*3)。

**7. 结论**

Knuth 的单调性定理不仅优化了算法效率，还揭示了最优二叉搜索树的结构性质。这一优化是动态规划中 **四边形不等式优化** 的经典案例，广泛应用于区间 DP 问题。









### 思考题

**15-1** （有向无环图中的最长简单路径）给定一个有向无环图 $G = (V, E)$，边权重为实数，给定图中两个顶点 $s$ 和 $t$。设计动态规划算法，求从 $s$ 到 $t$ 的最长加权简单路径。子问题图是怎样的？算法的效率如何？

**15-2** （最长回文子序列）回文 (palindrome) 是正序与逆序相同的非空字符串。例如，所有长度为 1 的字符串、civic、racecar、aibohphobia (害怕回文之意) 都是回文。
设计高效算法，求给定输入字符串的最长回文子序列。例如，给定输入 character，算法应该返回 carac。算法的运行时间是怎样的？

**15-3** （双调欧几里得旅行商问题）在欧几里得旅行商问题中，给定平面上 $n$ 个点作为输入，希望求出连接所有 $n$ 个点的最短巡游路线。图 15-11(a) 给出了一个 7 点问题的解。此问题是 NP 难问题，因此大家相信它并不存在多项式时间的求解算法 (参见第 34 章)。
J. L. Bentley 建议将问题简化，限制巡游路线为双调巡游 (bitonic tours)，即从最左边的点开始，严格向右前进，直至最右边的点，然后调头严格向左前进，直至回到起始点。图 15-11(b) 给出了相同 7 个点的最短双调巡游路线。问题简化之后，存在一个多项式时间的算法。

![image-20250117231122729](F:\software\Typora\images\image-20250117231122729.png)

设计一个 $O(n^2)$ 时间的最优双调巡游路线算法。你可以认为任何两个点的 $x$ 坐标均不同，且所有实数运算都花费单位时间。（提示：由左至右扫描，对巡游路线的两个部分分别维护可能的最优解。）

**15-4** （整齐打印）考虑整齐打印问题，即在打印机上用等宽字符打印一段文本。输入文本为 $n$ 个单词的序列，单词长度分别为 $l_1, l_2, \cdots, l_r$ 个字符。我们希望将此段文本整齐打印在若干行上，每行最多 $M$ 个字符。“整齐”的标准是这样的。如果某行包含第 $i$ 到第 $j (i \leq j)$ 个单词，且单词间隔为一个空格，则行尾的额外空格字符数量为 $M - j + 5 - \sum_{i}^{j} l_i$，此值必须为非负的，否则一行内无法容纳这些单词。我们希望能最小化所有行的（除最后一行外）额外空格数的立方之和。设计一个动态规划算法，在打印机上整齐打印一段 $n$ 个单词的文本。分析算法的时间和空间复杂性。

**15-5** （编辑距离）为了将一个文本串 $x[1 \cdots m]$ 转换为目标串 $y[1 \cdots n]$，我们可以使用多种变换操作。我们的目标是，给定 $x$ 和 $y$，求将 $x$ 转换为 $y$ 的一个变换操作序列。我们使用一个数组 $z$ 保存中间结果，假定它足够大，可存下中间结果的所有字符。初始时，$z$ 是空的，结束时，应有 $z[j] = y[1 \cdots n]$，$j = 1, 2, \cdots, n$。我们维护两个下标 $i$ 和 $j$，分别指向 $x$ 中位置和 $z$ 中位置，变换操作允许改变 $z$ 的内容和这两个下标。初始时，$i = j = 1$。在转换过程中处理 $x$ 的所有字符，这意味着在变换操作结束时，应有 $i = m + 1$。
我们可以使用如下 6 种变换操作：

- 复制 (copy) — 从 $x$ 复制一个字符到 $z$，即进行赋值 $z[j] = x[i]$，并将两个下标 $i$ 和 $j$ 都增 1。此操作处理了 $x[i]$。
- 替换 (replace) — 将 $x$ 中一个字符替换为另一个字符 $c$，$z[j] = c$，并将两个下标 $i$ 和 $j$ 都增 1。此操作处理了 $x[i]$。
- 删除 (delete) — 删除 $x$ 中一个字符，即将 $i$ 增 1，$j$ 不变。此操作处理了 $x[i]$。
- 插入 (insert) — 将字符 $c$ 插入 $x$ 中，$z[j] = c$，将 $j$ 增 1，$i$ 不变。此操作未处理 $x$ 中字符。
- 旋转 (twiddle, 即交换) — 将 $x$ 中下两个字符复制到 $z$ 中，但交换顺序，$z[j] = x[i+1]$ 且 $z[j+1] = x[i]$，将 $i$ 和 $j$ 都增 2。此操作处理了 $x[i]$ 和 $x[i+1]$。
- 终止 (kill) — 删除 $x$ 中剩余字符，令 $i = m + 1$。此操作处理了 $x$ 中所有尚未处理的字符。如果执行此操作，则转换过程结束。

下面给出了将源字符串 algorithm 转换为目标字符串 altruistic 的一种变换操作序列，下划线指出执行一个变换操作后两个下标的位置：

| 操作     | 初始字符串 | algorithm            | $z$    | $i$  | $j$  |
| -------- | ---------- | -------------------- | ------ | ---- | ---- |
| 插入 i   | algorithm  | altruistic_algorithm | a      | 0    | 1    |
| 复制     | algorithm  | altruistic_algorithm | alt    | 1    | 2    |
| 替换为 t | algorithm  | altruistic_algorithm | altt   | 2    | 3    |
| 删除     | algorithm  | altruistic_algorithm | altt   | 3    | 3    |
| 复制     | algorithm  | altruistic_algorithm | alttr  | 4    | 4    |
| 插入 u   | algorithm  | altruistic_algorithm | alttru | 5    | 5    |

注意，还有其他方法将 algorithm 转换为 altruistic。

每个变换操作都有相应的代价。具体的代价依赖于特定的应用，但我们假定每个操作的代价是一个已知的常量。我们还假定复制和替换的代价小于删除和插入的组合代价，否则复制和替换操作就没有意义了。一个给定的变换操作序列的代价为其中所有变换操作的代价之和。在上例中，将 algorithm 转换为 altruistic 的代价为
$$(3 \cdot \text{cost(复制)}) + \text{cost(替换)} + \text{cost(删除)} + (4 \cdot \text{cost(插入)}) + \text{cost(旋转)} + \text{cost(终止)}$$

a. 给定两个字符串 $x[1.. m]$ 和 $y[1.. n]$ 以及变换操作的代价，$x$ 到 $y$ 编辑距离 (edit distance) 是将 $x$ 转换为 $y$ 的最小代价的变换操作序列的代价值。设计动态规划算法，求 $x[1.. m]$ 到 $y[1.. n]$ 的编辑距离并打印最优变换操作序列。分析算法的时间和空间复杂度。

编辑距离问题是 DNA 序列对齐问题的推广（参考其他文献，如 Setubal 和 Meidanis [310, 3.2 节]）。已有多种方法可以通过对齐两个 DNA 序列来衡量它们的相似度。有一种对齐方法是将空格符插入到两个序列 $x$ 和 $y$ 中，可以插入到任何位置（包括两端），使得结果序列 $x'$ 和 $y'$ 具有相同的长度，但不会在相同的位置出现空格符（即不存在位置 $j$ 使得 $x'[j]$ 和 $y'[j]$ 都是空格符）。然后为每个位置“打分”，位置 $j$ 的分数为：
- +1，如果 $x'[j] = y'[j]$ 且不是空格符。
- -1，如果 $x'[j] \neq y'[j]$ 且都不是空格符。
- -2，$x'[j]$ 或 $y'[j]$ 是空格符。

对齐方案的分数为每个位置的分数之和。例如，给定序列 $x = \text{GATCGGCAT}$ 和 $y = \text{CAATGTGAATC}$，一种对齐方案为

```
G ATCG GCAT 
C AATGTGAATC
-*++*+*+-++*
```

+表示该位置分数为 +1，− 表示分数为 −1，* 表示分数为 −2，因此此方案的总分数为 $6 \cdot 1 - 2 \cdot 1 - 4 \cdot 2 = -4$。

b. 解释如何将最优对齐问题转换为编辑距离问题，使用的操作为变换操作复制、替换、删除、插入、旋转和终止的子集。

**15-6** （公司聚会计划）一位公司主席正在向 Stewart 教授咨询公司聚会的计划。公司的内部结构关系是层次化的，即员工按主管—下属关系构成一棵树，根结点为公司主席。人事部按“宴会交际能力”为每个员工打分，分值为实数。为了使所有参加聚会的员工都感到愉快，主席不希望员工及其直接主管同时出席。

公司主席向 Stewart 教授提供公司结构，采用 10.4 节介绍的左孩子右兄弟表示法描述。书中每个结点除了保存指针外，还保存员工的名字和宴会交际评分。设计算法，求宴会交际评分之和最大的宾客名单。分析算法的时间复杂度。

**15-7** （译码算法）我们可以通过在有向图 $G = (V, E)$ 上使用动态规划方法来实现语音识别。对每条边 $(u, v) \in E$ 打上一个声音标签 $\sigma(u, v)$，该声音来自于有限声音集 $\Sigma$。这样的标签图就成为一个特定人说限定语言的形式化模型。图中从特定顶点 $v_b \in V$ 开始的每条路径都对应模型产生的一个可能的声音序列。对于一条有向路径，我们定义其标签为路径中边的标签的简单连结。

a. 设计高效算法，对给定的带边标签的图 $G$、特定顶点 $v_b$ 及 $\Sigma$ 上的声音序列 $s = (\sigma_1, \sigma_2, \cdots)$，返回 $G$ 中从 $v_b$ 开始的一条路径，$s$ 为该路径的标签（如果存在这样的路径）。否则，算法应返回 NO-SUCH-PATH。分析算法的时间复杂度（提示：你可能发现第 2 章中的概念可以用于此题）。

b. 扩展 (a) 中的算法，使得返回的路径是从 $v_b$ 开始且标签为 $s$ 的路径中概率最大者。分析算法的时间复杂性。算法的时间复杂性。

**15-8** （基于接缝裁剪 (seam carving) 的图像压缩）给定一幅彩色图像，它由一个 $m \times n$ 的像素数组 $A[1.. m, 1.. n]$ 构成，每个像素是一个红绿蓝 (RGB) 亮度的三元组。假定我们希望轻度压缩这幅图像。具体地，我们希望从每一行中删除一个像素，使得图像变窄一个像素。但为了避免影响视觉效果，我们要求相邻两行中删除的像素必须位于同一列或相邻列。也就是说，删除的像素构成从顶端行到底端行的一条“接缝” (seam)，相邻像素均在垂直或对角线方向上相邻。
	a. 证明：可能的缝的数量是 $m$ 的指数函数，假定 $n > 1$。
	b. 假定现在对每个像素 $A[i, j]$ 我们都已计算出一个实型的“破坏度” $d[i, j]$，表示删除像素 $A[i,j]$ 对图像可视效果的破坏程度。直观地，一个像素的破坏度越低，它与相邻像素的相似度越高。再假定一条接缝的破坏度定义为它包含的像素的破坏度之和。设计算法，寻找破坏度最低的接缝。分析算法的时间复杂度。

**15-9** （字符串拆分）某种字符串处理语言允许程序员将一个字符串拆分为两段。由于此操作需要复制字符串，因此要花费 $n$ 个时间单位来将一个 $n$ 个字符的字符串拆为两段。假定一个程序员希望将一个字符串拆分为多段，拆分的顺序会影响所花费的总时间。例如，假定这个程序员希望将一个 20 个字符的字符串在第 2 个、第 8 个以及第 10 个字符后进行拆分（字符由左至右，从 1 开始升序编号）。如果她按由左至右的顺序进行拆分，则第一次拆分花费 20 个时间单位，第二次拆分花费 18 个时间单位（在第 8 个字符处拆分 3~20 间的字符串），而第三次拆分花费 12 个时间单位，共花费 50 个时间单位。但如果她按由右至左的顺序进行拆分，第一次拆分花费 20 个时间单位，第二次拆分花费 10 个时间单位，而第三次拆分花费 8 个时间单位，共花费 38 个时间单位。还可以按其他顺序，先在第 8 个字符处进行拆分（时间 20），接着在左边一段第 2 个字符处进行拆分（时间 8），最后在右边一段第 10 个字符处进行拆分（时间 12），总时间为 40。
	设计算法，对给定的拆分位置，确定最小代价的拆分顺序。更形式化地，给定一个 $n$ 个字符的字符串 $S$ 和一个保存 $m$ 个拆分点的数组 $L[1..m]$，计算拆分的最小代价，以及最优拆分序列。

**15-10** （投资策略规划）你所掌握的算法知识帮助你从 Acme 计算机公司获得了一份令人兴奋的工作，签约奖金 1 万美元。你决定利用这笔钱进行投资，目标是 10 年后获得最大回报。你决定请 Amalgamated 投资公司管理你的投资，该公司的投资回报规则如下。该公司提供 $n$ 种不同的投资，从 1~$n$ 编号。在第 $j$ 年，第 $i$ 种投资的回报率为 $r_{ij}$。换句话说，如果你在第 $j$ 年在第 $i$ 种投资投入 $d$ 美元，那么在第 $j$ 年年底，你会得到 $dr_{ij}$ 美元。回报率是有保证的，即未来 10 年每种投资的回报率均已知。你每年只能做出一次投资决定。在每年年底，你既可以将钱继续投入到上一年选择的投资种类中，也可以转移到其他投资中（转移到已有的投资种类，或者新的投资种类）。如果跨年时你不做投资转移，需要支付 $f_1$ 美元的费用，否则，需要支付 $f_2$ 美元的费用，其中 $f_2 > f_1$。

a. 如上所述，本问题允许你每年将钱投入到多种投资中。证明：存在最优投资策略，每年都将所有钱投入到单一投资中（记住最优投资策略只需最大化 10 年的回报，无需关心任何其他目标，如最小化风险）。

b. 证明：规划最优投资策略问题具有最优子结构性质。

c. 设计最优投资策略规划算法，分析算法时间复杂度。

d. 假定 Amalgamated 投资公司在上述规则上又加入了新的限制条款，在任何时刻你都不能在任何单一投资种类中投入 15 000 美元以上。证明：最大化 10 年回报问题不再具有最优子结构性质。

**15-11** （库存规划）Rinky Dink 公司是一家制造溜冰场冰面修整设备的公司。这种设备每个月的需求量都在变化，因此公司希望设计一种策略来规划生产，需求是给定的，即它虽然是波动的，但是可预测的。公司希望设计接下来 $n$ 个月的生产计划。对第 $i$ 个月，公司知道需求 $d_i$，即该月能够销售出去的设备的数量。令 $D = \sum_{i=1}^{n} d_i$ 为后 $n$ 个月的总需求。公司雇用的全职员工，可以提供一个月制造 $m$ 台设备的劳动力。如果公司希望一个月内制造多于 $m$ 台设备，可以雇用额外的兼职劳动力，雇用成本为每制造一台机器付出 $c$ 美元。而且，如果在月末有设备尚未售出，公司还要付出库存成本。保存 $j$ 台设备的成本可描述为一个函数 $h(j)$，$j=1, 2, \cdots, D$ 其中对所有 $1 \leqslant j \leqslant D$，$h(j) \geqslant 0$，对 $1 \leqslant j \leqslant D-1$，$h(j) \leqslant h(j+1)$。

设计库存规划算法，在满足所有需求的前提下最小化成本。算法运行时间应为 $n$ 和 $D$ 的多项式函数。

**15-12** （签约棒球自由球员）假设你是一支棒球大联盟球队的总经理。在赛季休季期间，你需要签入一些自由球员。球队老板给你的预算为 $X$ 美元，你可以使用少于 $X$ 美元来签人球员，但如果超支，球队老板就会解雇你。

你正在考虑在 $N$ 个不同位置签人球员，在每个位置上，有 $P$ 个该位置的自由球员供你选择。由于你不希望任何位置过于臃肿，因此每个位置最多签入一名球员（如果在某个特定位置上你没有签入任何球员，则意味着计划继续使用现有球员）。

为了确定一名球员的价值，你决定使用一种称为“VORP”，或“球员替换价值”（value over replacement player）的统计评价指标。球员的 VORP 值越高，其价值越高。但 VORP 值高的球员的签约费用并不一定比 VORP 值低的球员高，因为还有球员价值之外的因素影响签约费用。

对于每个可选择的自由球员，你知道他的三方面信息：
- 他打哪个位置。
- 他的签约费用。
- 他的 VORP。

设计一个球员选择算法，使得总签约费用不超过 $X$ 美元，而球员的总 VORP 最大。你可以假定每位球员的签约费用是 10 万美元的整数倍。算法应输出签约球员的总 VORP 值、总签约费用，以及球员名单。分析算法的时间和空间复杂度。



















**望远镜求和**

**Knuth 优化**

**Knuth-Yao 四边形不等式优化**







