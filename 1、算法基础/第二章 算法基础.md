## 第二章 算法基础

### 练习 2.1

> **2.1-1 以图 2-2 为模型，说明 INSERTION-SORT 在数组 $A=(31, 41, 59, 26, 41, 58)$ 上的执行过程。**

图2-2如下：展示了插入排序的执行过程

![image-20250121215626567](F:\software\Typora\images\image-20250121215626567.png)

对于数组A=（31，41，59，26，41，58），插入排序的执行过程如下，从第二个元素开始，依次判断当前元素和前一个元素的大小关系，如果当前元素更大，则不做处理；如果当前元素更小，则交换当前元素和前一个元素，直到当前元素所在位置左边的元素比它小或当前元素左边没有元素为止。

执行过程如下：

| 处理位置 | 判断结果 |            处理结果            |
| :------: | :------: | :----------------------------: |
|    2     |  41>31   | （31，**41**，59，26，41，58） |
|    3     |  59>41   | （31，**41**，59，26，41，58） |
|    4     |  26<59   | （31，**41**，26, 59，41，58） |
|    4     |  26<41   | （31，26, **41**, 59，41，58） |
|    4     |  26<31   | （26, 31, **41**, 59，41，58） |
|    5     |  41<59   | （26, 31, **41**, 41, 59，58） |
|    6     |  58<59   | （26, 31, **41**, 41, 58, 59） |

---

> **2.1-2 重写过程 INSERTION-SORT, 使之按非升序（而不是非降序）排序。** 

非升序的INSERTION-SORT伪代码如下：

```c
INSERTION-SORT(A) 
	for j = 2 to A. length 
		key= A[j] 
		// Insert A[j] into the sorted sequence A[1...j —1]. 
		i=j-1 
       // key表示当前待移动元素
		while i > 0 and A[i] < key 	// 如果当前元素大于前一个元素则交换位置，也就是将较大元素移到前面位置
			A[i+1] = A[i] 
			i=i-1 
		A[i+1] = key
```

---

> **2.1-3 考虑以下查找问题： 输入：$n$ 个数的一个序列 $A=(a_1, a_2, …, a_n)$ 和一个值 $v$。 输出：下标 $i$ 使得 $v=A[i]$ 或者当 $v$ 不在 $A$ 中出现时，$v$ 为特殊值 NULL。 写出线性查找的伪代码，它扫描整个序列来查找 $v$。使用一个循环不变式来证明你的算法是正确的。确保你的循环不变式满足三条必要的性质。** 

线性查找的伪代码如下：

```c
Linear_Find(A, v)
    for i = 1 to A.length
        if v==A[i]
            return i
    return NULL
```

---

> **2.1-4** 考虑把两个 $n$ 位二进制整数加起来的问题，这两个整数分别存储在两个 $n$ 元数组 $A$ 和 $B$ 中。这两个整数的和应按二进制形式存储在一个(n+1)元数组 $C$ 中。请给出该问题的形式化描述，并写出伪代码。





### 练习 2.2

> **2.2-1** 用 $\Theta$ 记号表示函数 $n^3/1000-100n^2 -100n+3$



---

2.2-2 考虑排序存储在数组 $A$ 中的 $n$ 个数：首先找出 $A$ 中的最小元素并将其与 $A[1]$ 中的元素进行交换。接着，找出 $A$ 中的次最小元素并将其与 $A[2]$ 中的元素进行交换。对 A 中前 $n-1$ 个元素按该方式继续。该算法称为 **选择算法**，写出其伪代码。该算法维持的循环不变式是什么？为什么它只需要对前 $n—1$ 个元素，而不是对所有 $n$ 个元素运行？用 $\Theta$ 记号给出选择排序的最好情况与最坏情况运行时间。

2.2-3 再次考虑线性查找问题（参见练习 2.1-3)。假定要查找的元素等可能地为数组中的任意元素，平均需要检查输入序列的多少元素？最坏情况又如何呢？用 $\Theta$ 记号给出线性查找的平均情况和最坏情况运行时间。证明你的答案。

2.2-4 我们可以如何修改几乎任意算法来使之具有良好的最好情况运行时间？

### 练习 2.3

2.3-1 使用图 2-4 作为模型，说明归并排序在数组 $A=\langle3,41,52,26,38,57,9,49\rangle$ 上的操作。

2.3-2 重写过程 MERGE, 使之不使用哨兵，而是一旦数组 $L$ 或 $R$ 的所有元素均被复制回 $A$ 就
立刻停止，然后把另一个数组的剩余部分复制回 $A$。

2.3-3 使用数学归纳法证明：当 $n$ 刚好是 2 的幂时，以下递归式的解是 $T(n)=n\lg n$ 。
$$
T(n)=\begin{cases}2&\text{若 }n = 2\\2T(n/2)+n&\text{若 }n = 2^k, k > 1\end{cases}
$$
2.3-4 我们可以把插人排序表示为如下的一个递归过程。为了排序 $A[1..n]$, 我们递归地排序 $A[1\ldots n-1]$, 然后把 $A[n]$ 插人已排序的数组 $A[1\ldots n-1]$。为插人排序的这个递归版本的最坏情况运行时间写一个递归式。

2.3-5 回顾查找问题(参见练习 2.1-3), 注意到，如果序列 $A$ 已排好序，就可以将该序列的中点与 $v$ 进行比较。根据比较的结果，原序列中有一半就可以不用再做进一步的考虑了。二分查找算法重复这个过程，每次都将序列剩余部分的规模减半。为二分查找写出迭代或递归的伪代码。证明：二分查找的最坏情况运行时间为 $\Theta(\lg n)$。

2.3-6 注意到 2.1 节中的过程 INSERTION-SORT 的第 5~7 行的 while 循环采用一种线性查找来(反向)扫描已排好序的子数组 $A[1\ldots j一1]$。我们可以使用二分查找(参见练习 2.3-5)来把插人排序的最坏情况总运行时间改进到 $\Theta(n\lg n)吗？$

$^* $ 2.3-7 描述一个运行时间为 $\Theta(n\lg n)$ 的算法，给定 $n$ 个整数的集合 $S$ 和另一个整数 $x$, 该算法能
确定 $S$ 中是否存在两个其和刚好为 $x$ 的元素。

### 思考题

2-1 (在归并排序中对小数组采用插入排序） 虽然归并排序的最坏情况运行时间为 $\Theta (nlgn)$, 而插入排序的最坏情况运行时间为 $\Theta (n^2)$, 但是插人排序中的常量因子可能使得它在 $n$ 较小 时，在许多机器上实际运行得更快。因此，在归并排序中当子问题变得足够小时，采用插入排序来使递归的叶变粗是有意义的。考虑对归并排序的一种修改，其中使用插入排序来 排序长度为 $k$ 的 $n/k$ 个子表，然后使用标准的合并机制来合并这些子表，这里 $k$ 是一个待定的值

a.证明：插入排序最坏情况可以在 $\Theta (nk)$ 时间内排序每个长度为 $K$ 的 $n/k$ 个子表。 

b.表明在最坏情况下如何在 $\Theta(nlg(n/k))$ 时间内合并这些子表。 

c.假定修改后的算法的最坏情况运行时间为 $\Theta(nk+nlg(n/k))$, 要使修改后的算法与标准的归并排序具有相同的运行时间，作为 $n$ 的一个函数，借助 $\Theta$ 记号，$K$ 的最大值是什么？ 

d. 在实践中，我们应该如何选择 $k$?



2-2 (冒泡排序的正确性) 冒泡排序是一种流行但低效的排序算法，它的作用是反复交换相邻
的未按次序排列的元素。

**BUBBLESORT(A)** 

```c
for i = 1 to A.length - 1 
	for j = A.length downto i + 1 
		if A[j] < A[j —1] 
			exchange A[j] with A[j —1] 
```

a.假设 $A^\prime$​表示 BUBBLESORT(A)的输出。为了证明 BUBBLESORT 正确，我们必须证明它将终止并且有：
$$
A^{\prime}[1]\leqslant A^{\prime}[2]\leqslant\cdotp\cdotp\cdotp\leqslant A^{\prime}[n]	\tag{2.3}
$$
其中 $n=A.length$。为了证明 BUBBLESORT 确实完成了排序，我们还需要证明什么？下面两部分将证明不等式(2.3)。

b.为第 2~4 行的 for 循环精确地说明一个循环不变式，并证明该循环不变式成立。你的证
明应该使用本章中给出的循环不变式证明的结构。

c 使用(b)部分证明的循环不变式的终止条件，为第 1~4 行的 for 循环说明一个循环不变
式，该不变式将使你能证明不等式(2.3)。你的证明应该使用本章中给出的循环不变式证
明的结构。

d.冒泡排序的最坏情况运行时间是多少？与插人排序的运行时间相比，其性能如何？



2-3 (霍纳(Horner)规则的正确性) 给定系数 $a_0,a_1,...,a_n$ 和 $x$ 的值，代码片段

```cpp
y= 0 
for i = n downto 0 
			    y	 = a_i + x*y 
```


实现了用于求值多项式

$$
P(x)=\sum_{k = 0}^na_kx^k = a_0+x(a_1+x(a_2+\cdotp\cdotp\cdotp+x(a_{n-1}+xa_n)\cdotp\cdotp\cdotp))
$$
的霍纳规则。

a.借助 $\Theta$ 记号，实现霍纳规则的以上代码片段的运行时间是多少？

b.编写伪代码来实现朴素的多项式求值算法，该算法从头开始计算多项式的每个项。该算法的运行时间是多少？与霍纳规则相比，其性能如何？

c.考虑以下循环不变式：在第 2~3 行 for 循环每次迭代的开始有
$$
y =\sum_{k = 0}^{n-(i+1)}a_{k+i+1}x^k
$$
把没有项的和式解释为等于 0。遵照本章中给出的循环不变式证明的结构，使用该循环不变式来证明终止时有 $y=\sum\limits_{k=0}^n a_k x^k$

d. 最后证明上面给出的代码片段将正确地求由系数 $a_0,a_1,...,a_n$ 刻画的多项式的值。



2-4 (逆序对) 假设 $A[1..n]$ 是一个有 $n$ 个不同数的数组。若 $i<j$ 且 $A[i]{>}A[j]$，则对偶($i$, $j$)称为
$A$ 的一个逆序对(inversion)。

a.列出数组 ${\langle2,3,8,6,1\rangle}$ 的 5 个逆序对。

b.由集合{1,2,..., n}中的元素构成的什么数组具有最多的逆序对？它有多少逆序对？

c.插人排序的运行时间与输入数组中逆序对的数量之间是什么关系？证明你的回答。

d.给出一个确定在 $n$ 个元素的任何排列中逆序对数量的算法，最坏情况需要 $\Theta(n\lg n)$ 时间。(提示：修改归并排序。)