## 第四章 分治策略

### 练习 4.1

4.1-1 当 $A$ 的所有元素均为负数时，FIND-MAXIMUM-SUBARRAY 返回什么？

4.1-2 对最大子数组问题，编写暴力求解方法的伪代码，其运行时间应该为 $\Theta(n^2)$。

4.1-3 在你的计算机上实现最大子数组问题的暴力算法和递归算法。请指出多大的问题规模 $n_0$ 是性能交叉点——从此之后递归算法将击败暴力算法？然后，修改递归算法的基本情况——当问题规模小于 $n_0$ 时采用暴力算法。修改后，性能交叉点会改变吗？

4.1-4 假定修改最大子数组问题的定义，允许结果为空子数组，其和为 0。你应该如何修改现有算法，使它们能允许空子数组为最终结果？

4.1-5 使用如下思想为最大子数组问题设计一个非递归的、线性时间的算法。从数组的左边界开始，由左至右处理，记录到目前为止已经处理过的最大子数组。若已知 $A[1..j]$ 的最大子数组，基于如下性质将解扩展为 $A[1..j+1]$ 的最大子数组：$A[1..j+1]$ 的最大子数组要么是 $A[1..j]$ 的最大子数组，要么是某个子数组 $A[i..j+1] (1 \leq i \leq j+1)$。在已知 $A[1..j]$ 的最大子数组的情况下，可以在线性时间内找出形如 $A[i..j+1]$ 的最大子数组。

### 练习 4.2

注意：虽然练习 4.2-3、4.2-4 和 4.2-5 是关于 Strassen 算法的变形的，但你应该先阅读 4.5 节，然后再尝试求解这几个问题。

4.2-1 使用 Strassen 算法计算如下矩阵乘法：
$$
\begin{bmatrix}
1 & 3 \\
7 & 5
\end{bmatrix}
\begin{bmatrix}
6 & 8 \\
4 & 2
\end{bmatrix}
$$
给出计算过程。

4.2-2 为 Strassen 算法编写伪代码。

4.2-3 如何修改 Strassen 算法，使之适应矩阵规模 n 不是 2 的幂的情况？证明：算法的运行时间为 $\Theta(n^{\lg 7})$。

4.2-4 如果可以用 k 次乘法操作（假定乘法的交换律不成立）完成两个 $3 \times 3$ 矩阵相乘，那么你可以在 $o(n^{\lg k})$ 时间内完成 $n \times n$ 矩阵相乘，满足这一条件的最大的 k 是多少？此算法的运行时间是怎样的？

4.2-5 V.Pan 发现一种方法，可以用 132 464 次乘法操作完成 $68 \times 68$ 的矩阵相乘，发现另一种方法，可以用 143 640 次乘法操作完成 $70 \times 70$ 的矩阵相乘，还发现一种方法，可以用 155 424 次乘法操作完成 $72 \times 72$ 的矩阵相乘。当用于矩阵相乘的分治算法时，上述哪种方法会得到最佳的渐近运行时间？与 Strassen 算法相比，性能如何？

4.2-6 用 Strassen 算法作为子进程来进行一个 $k n \times n$ 矩阵和一个 $n \times k n$ 矩阵相乘，最快需要花费多长时间？对两个输入矩阵规模互换的情况，回答相同的问题。

4.2-7 设计算法，仅使用三次实数乘法即可完成复数 $a+bi$ 和 $c+di$ 相乘。算法需接收 $a$、$b$、$c$ 和 $d$ 为输入，分别生成实部 $ac-bd$ 和虚部 $ad+bc$。

### 练习 4.3

4.3-1 证明：$T(n) = T(n-1) + n$ 的解为 $O(n^2)$。

4.3-2 证明：$T(n) = T(\lceil n/2 \rceil) + 1$ 的解为 $O(\lg n)$。

4.3-3 我们看到 $T(n) = 2T(\lfloor n/2 \rfloor) + n$ 的解为 $O(n \lg n)$。证明 $\Omega(n \lg n)$ 也是这个递归式的解。从而得出结论：解为 $\Theta(n \lg n)$。

4.3-4 证明：通过做出不同的归纳假设，我们不必调整归纳证明中的边界条件，即可克服递归式 (4.19) 中边界条件 $T(1) = 1$ 带来的困难。

4.3-5 证明：归并排序的“严格”递归式 (4.3) 的解为 $\Theta(n \lg n)$。

4.3-6 证明：$T(n) = 2T(\lfloor n/2 \rfloor + 17) + n$ 的解为 $O(n \lg n)$。

4.3-7 使用 4.5 节中的主方法，可以证明 $T(n) = 4T(n/3) + n$ 的解为 $T(n) = \Theta(n^{\log_3 4})$。说明基于假设 $T(n) \leqslant cn^{\log_3 4}$ 的代入法不能证明这一结论。然后说明如何通过减去一个低阶项完成代入法证明。

4.3-8 使用 4.5 节中的主方法，可以证明 $T(n) = 4T(n/2) + n$ 的解为 $T(n) = \Theta(n^2)$。说明基于假设 $T(n) \leqslant cn^2$ 的代入法不能证明这一结论。然后说明如何通过减去一个低阶项完成代入法证明。

4.3-9 利用改变变量的方法求解递归式 $T(n) = 3T(\sqrt{n}) + \log n$。你的解应该是渐近紧确的。不必担心数值是否是整数。

### 练习 4.4

4.4-1 对递归式 $T(n) = 3T(\lfloor n/2 \rfloor) + n$，利用递归树确定一个好的渐近上界，用代入法进行验证。

4.4-2 对递归式 $T(n) = T(n/2) + n^2$，利用递归树确定一个好的渐近上界，用代入法进行验证。

4.4-3 对递归式 $T(n) = 4T(n/2 + 2) + n$，利用递归树确定一个好的渐近上界，用代入法进行验证。

4.4-4 对递归式 $T(n) = T(n-1) + 1$，利用递归树确定一个好的渐近上界，用代入法进行验证。

4.4-5 对递归式 $T(n) = T(n-1) + T(n/2) + n$，利用递归树确定一个好的渐近上界，用代入法进行验证。

4.4-6 对递归式 $T(n) = T(n/3) + T(2n/3) + cn$，利用递归树论证其解为 $\Omega(n \lg n)$，其中 c 为常数。

4.4-7 对递归式 $T(n) = 4T(\lfloor n/2 \rfloor) + cn$ (c 为常数)，画出递归树，并给出其解的一个渐近紧确界。用代入法进行验证。

4.4-8 对递归式 $T(n) = T(n-a) + T(a) + cn$，利用递归树给出一个渐近紧确解，其中 $a \geq 1$ 和 $c > 0$ 是常数。

4.4-9 对递归式 $T(n) = T(\alpha n) + T((1-\alpha) n) + cn$，利用递归树给出一个渐近紧确解，其中 $0 < \alpha < 1$ 和 $c > 0$ 是常数。

### 练习 4.5

4.5-1 对下列递归式，使用主方法求出渐近紧确界。
    a. $T(n) = 2T(n/4) + 1$
    b. $T(n) = 2T(n/4) + \sqrt{n}$
    c. $T(n) = 2T(n/4) + n$
    d. $T(n) = 2T(n/4) + n^2$

4.5-2 Caesar 教授想设计一个渐近快于 Strassen 算法的矩阵相乘算法。他的算法使用分治方法，将每个矩阵分解为 $n/4 \times n/4$ 的子矩阵，分解和合并步骤共花费 $\Theta(n^2)$ 时间。他需要确定，他的算法需要创建多少个子问题，才能击败 Strassen 算法。如果他的算法创建 a 个子问题，则描述运行时间 T(n) 的递归式为 $T(n) = aT(n/4) + \Theta(n^2)$。Caesar 教授的算法如果要渐近快于 Strassen 算法，a 的最大整数值应是多少？

4.5-3 使用主方法证明：二分查找递归式 $T(n) = T(n/2) + \Theta(1)$ 的解是 $T(n) = \Theta(\lg n)$。（二分查找的描述见练习 2.3-5）。

4.5-4 主方法能应用于递归式 $T(n) = 4T(n/2) + n^2 \lg n$ 吗？请说明为什么可以或者为什么不可以。给出这个递归式的一个渐近上界。

*4.5-5 考虑主定理情况 3 的一部分：对某个常数 $c < 1$，正则条件 $af(n/b) \leq cf(n)$ 是否成立。给出一个例子，其中常数 $a \geq 1$，$b > 1$ 且函数 $f(n)$ 满足主定理情况 3 中除正则条件外的所有条件。

### 练习 4.6

*4.6-1 对 b 是正整数而非任意实数的情况，给出公式 (4.27) 中 $n_j$ 的简单而准确的表达式。

*4.6-2 证明：如果 $f(n) = \Theta(n^{\log_b a} \lg^k n)$，其中 $k \geqslant 0$，那么主递归式的解为 $T(n) = \Theta(n^{\log_b a} \lg^{k+1} n)$。为简单起见，假定 n 是 b 的幂。

*4.6-3 证明：主定理中的情况 3 被过分强调了，从某种意义上来说，对某个常数 c < 1，正则条件 $a f(n/b) \leqslant c f(n)$ 成立本身就意味着存在常数 $\varepsilon > 0 $，使得 $ f(n) = \Omega(n^{\log_b a + \varepsilon})$。

### 思考题

4-1 （递归式例子）对于下列每个递归式，给出 $T(n)$ 的渐近上界和下界。假定 $n \leq 2$ 时 $T(n)$ 是常数。给出尽量紧确的界，并验证其正确性。
    a. $T(n) = 2T(n/2) + n^4$
    b. $T(n) = T(n/10) + n$
    c. $T(n) = 16T(n/4) + n^2$
    d. $T(n) = 7T(n/3) + n^2$
    e. $T(n) = 7T(n/2) + n^2$
    f. $T(n) = 2T(n/4) + \sqrt{n}$
    g. $T(n) = T(n-2) + n^2$

4-2 （参数传递代价）我们有一个贯穿本书的假设——过程调用中的参数传递花费常量时间，即使传递一个 $N$ 个元素的数组也是如此。在大多数系统中，这个假设是成立的，因为传递的是指向数组的指针，而非数组本身。本题讨论三种参数传递策略：

1. 数组通过指针来传递。时间 = $\Theta(1)$。
2. 数组通过元素复制来传递。时间 = $\Theta(N)$，其中 $N$ 是数组的规模。
3. 传递数组时，只复制过程可能访问的子区域。若子数组 $A[p..q]$ 被传递，则时间 = $\Theta(q-p+1)$。

a.考虑在有序数组中查找元素的递归二分查找算法 (参见练习 2.3-5)。分别给出上述三种参数传递策略下，二分查找最坏情况下运行时间的递归式，并给出递归式解的好的上界。

令 $N$ 为原问题的规模，$n$ 为子问题的规模。

b.对 2.3.1 节的 MERGE-SORT 算法重做 (c)。

4-3 （更多的递归式例子）对于下列每个递归式，给出 $T(n)$ 的渐近上界和下界。假定对足够小的 $n$，$T(n)$ 是常数。给出尽量紧确的界，并验证其正确性。
    a. $T(n) = 4T(n/2) + n \lg n$
    b. $T(n) = 3T(n/3) + n/\lg n$
    c. $T(n) = 4T(n/2) + n^2 \sqrt{n}$
    d. $T(n) = 2T(n/2-2) + n/2$
    e. $T(n) = 2T(n/2) + n/\lg n$
    f. $T(n) = T(n/2) + T(n/4) + T(n/8) + n$
    g. $T(n) = T(n-1) + 1/n$
    h. $T(n) = T(n-1) + \lg n$
    i. $T(n) = T(n-2) + 1/\lg n$
    j. $T(n) = \sqrt{n}T(\sqrt{n}) + n$

4-4 （斐波那契数）本题讨论递归式 (3.22) 定义的斐波那契数的性质。我们将使用生成函数技术来求解斐波那契递归式。生成函数 (又称为形式幂级数) $\mathcal{F}(z)$ 定义为
$$
\mathcal{F}(z) = \sum_{i = 0}^{\infty} F_i z^i = 0 + z + z^2 + 2z^3 + 3z^4 + 5z^5 + 8z^6 + 13z^7 + 21z^8 + \cdots
$$
其中 $F_i$ 为第 $i$ 个斐波那契数。
a. 证明：$\mathcal{F}(z) = z + z\mathcal{F}(z) + z^2\mathcal{F}(z)$。
b. 证明：
$$
\mathcal{F}(z) = \frac{z}{1 - z - z^2} = \frac{z}{(1 - \phi z)(1 - \hat{\phi} z)} = \frac{1}{\sqrt{5}}\left(\frac{1}{1 - \phi z} - \frac{1}{1 - \hat{\phi} z}\right)
$$
其中
$$
\phi = \frac{1 + \sqrt{5}}{2} = 1.618 03 \cdots
$$

$$
\hat{\phi} = \frac{1 - \sqrt{5}}{2} = -0.618 03 \cdots
$$

c. 证明：
$$
\mathcal{F}(z) = \sum_{i = 0}^{\infty} \frac{1}{\sqrt{5}} (\phi^i - \hat{\phi}^i) z^i
$$

d. 利用 (c) 的结果证明：对 $i \geq 0$，$F_i = \phi^i / \sqrt{5}$，结果舍入到最接近的整数。（提示：观察到 $|\hat{\phi}| < 1$。）

4-5 （芯片检测）Diogenes 教授有 $n$ 片可能完全一样的集成电路芯片，原理上可以用来相互检测。教授的测试夹具同时只能容纳两块芯片。当夹具装载上时，每块芯片都检测另一块，并报告它是好是坏。一块好的芯片总能准确报告另一块芯片的好坏，但教授不能信任坏芯片报告的结果。因此，4 种可能的测试结果如下表：

| 芯片 A 的结果 | 芯片 B 的结果 |           结论           |
| :-----------: | :-----------: | :----------------------: |
|   B 是好的    |   A 是好的    | 两片都是好的，或都是坏的 |
|   B 是好的    |   A 是坏的    |      至少一块是坏的      |
|   B 是坏的    |   A 是好的    |      至少一块是坏的      |
|   B 是坏的    |   A 是坏的    |      至少一块是坏的      |

a. 证明：如果超过 $n/2$ 块芯片是坏的，使用任何基于这种逐对检测操作的策略，教授都不能确定哪些芯片是好的。假定坏芯片可以合谋欺骗教授。
	b. 考虑从 $n$ 块芯片中寻找一块好芯片的问题，假定超过 $n/2$ 块芯片是好的。证明：进行 $n/2$ 次逐对检测足以将问题规模减半。
	c. 假定超过 $n/2$ 块芯片是好的，证明：可以用 $\Theta(n)$ 次逐对检测找到好的芯片。给出描述检测次数的递归，并求解它。

4-6 (Monge 序列)对一个 $m \times n$ 的实数阵列 $A$，若对所有满足 $1 \leq i < k \leq m$ 和 $1 \leq j < l \leq n$ 的 $i, j, k$ 和 $l$ 有
$$
A [i, j] + A [k, l] \leq A [i, l] + A [k, j]
$$
则称 $A$ 是 Monge 阵列 (Monge array)。换句话说，无论何时选定 Monge 阵列的两行和两列，对于交叉点上的 4 个元素，左上和右下两个元素之和总是小于等于左下和右上元素之和。例如，下面就是一个 Monge 阵列：
$$
\begin{bmatrix}
10 & 17 & 13 & 28 & 23 \\
17 & 22 & 16 & 29 & 23 \\
24 & 28 & 22 & 34 & 24 \\
11 & 13 & 6 & 17 & 7 \\
45 & 44 & 32 & 37 & 23 \\
36 & 33 & 19 & 21 & 6 \\
75 & 66 & 51 & 53 & 34 \\
\end{bmatrix}
$$
a. 证明：一个数组是 Monge 阵列当且仅当对所有 $i=1, 2, \cdots, m-1$ 和 $j=1, 2, \cdots, n-1$，有
$$
A [i, j] + A [i+1, j+1] \leq A [i, j+1] + A [i+1, j]
$$
（提示：对于“当”的部分，对所有行和列使用归纳法。）

b. 下面数组不是 Monge 阵列。改变一个元素使其变成 Monge 阵列。（提示：利用 (a) 的结果。）
$$
\begin{bmatrix}
37 & 23 & 22 & 32 \\
21 & 6 & 7 & 10 \\
53 & 34 & 30 & 31 \\
32 & 13 & 9 & 6 \\
43 & 21 & 15 & 8 \\
\end{bmatrix}
$$
c. 令 $f(i)$ 表示第 $i$ 行的最左最小元素的列下标。证明：对任意 $m \times n$ 的 Monge 阵列，$f(1) \leq f(2) \leq \cdots \leq f(m)$。

d. 下面是一个计算 $m \times n$ 的 Monge 阵列 $A$ 每一行最左最小元素的分治算法的描述：
   提取 $A$ 的偶数行构造子矩阵 $A'$。递归地确定 $A'$ 每行的最左最小元素。
   然后计算 $A$ 的奇数行的最左最小元素。
   解释如何在 $O(m+n)$ 时间内计算 $A$ 的奇数行的最左最小元素（在偶数行的最左最小元素已知的情况下）。
e. 给出 (d) 中描述的算法的运行时间的递归式。证明其解为 $O(m+n \log m)$。
