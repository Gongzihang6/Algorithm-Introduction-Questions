# 第五部分 高级数据结构

## 第十八章 B 树

### 练习 18.1

$18.1$-$1$ 为什么不允许最小度数 $t=1$ ?

$18.1$-$2$ 当 $t$ 取何值时，图 $18$-$1$ 所示的树是一棵合法的 $B$ 树?

$18.1$-$3$ 请给出表示 $\{1,2,3,4,5\}$ 的最小度数为 $2$ 的所有合法 $B$ 树。

$18.1$-$4$ 一棵高度为 $h$ 的 $B$ 树中，可以存储最多多少个关键字？用最小度数 $t$ 的函数表示。

$18.1$-$5$ 如果红黑树中每个黑结点吸收它的红色孩子，并把它们的孩子并入作为自己的孩子，描述这个结果的数据结构。

### 练习

$18.2$-$1$ 请给出关键字 $F$、$S$、$Q$、$K$、$C$、$L$、$H$、$T$、$V$、$W$、$M$、$R$、$N$、$P$、$A$、$B$、$X$、$Y$、$D$、$Z$、$E$ 依序插入一棵最小度数为 $2$ 的空 B 树的结果。只要画出在某些结点分裂之前的结构以及最终的结构。

$18.2$-$2$ 请解释在什么情况下（如果有的话），在调用 B-TREE-INSERT 的过程中，会执行冗余的 DISK-READ 或 DISK-WRITE 操作。（所谓冗余的 DISK-READ，是指对已经在主存中的某页做 DISK-READ。冗余的 DISK-WRITE 是指将已经存在于磁盘上的某页又完全相同地重写一遍。）

$18.2$-$3$ 请说明如何在一棵 B 树中找出最小关键字，以及如何找出某一给定关键字的前驱。

*$18.2$-$4$ 假设关键字 $\{1,2,\cdots,n\}$ 被插入一棵最小度数为 $2$ 的空 B 树中，那么最终的 B 树有多少个结点？

$18.2$-$5$ 因为叶结点无需指向孩子结点的指针，那么对同样大小的磁盘页面，可选用一个与内部结点不同的（更大的）$t$ 值。请说明如何修改 B 树的创建和插入过程来处理这个变化。

$18.2$-$6$ 假设 B-TREE-SEARCH 的实现是在每个结点内采用二分查找，而不是线性查找。证明：无论怎样选择 $t$（$t$ 为 $n$ 的函数），这种实现所需的 CPU 时间都为 $O(\log n)$。

$18.2$-$7$ 假设磁盘硬件允许我们任意选择磁盘页面的大小，但读取磁盘页面的时间是 $a+bt$，其中 $a$ 和 $b$ 为规定的常数，$t$ 为确定磁盘页大小后的 B 树的最小度数。请描述如何选择 $t$ 以（近似地）最小化 B 树的查找时间。对 $a=5$ ms 和 $b=10$ ms，请给出 $t$ 的一个最优值。

### 练习 18.3

$18.3$-$1$ 请说明依次从图 $18$-$8$(c)中删除 $C$、$P$ 和 $V$ 后的结果。

$18.3$-$2$ 请写出 B-TREE-DELETE 的伪代码。

### 思考题

$18$-$1$ （辅存上的栈）考虑在一个有着相对少量的快速主存但有着相对大量较慢的磁盘存储空间的计算机上实现一个栈的问题。操作 PUSH 和 POP 操作的对象为单字。我们希望计算机支持的栈可以增长得很大，以至于无法全部装入主存中，因此它的大部分都要放在磁盘上。

一种简单但低效的栈实现方法是将整个栈存放在磁盘上。在主存中保持一个栈的指针，它指向栈顶元素的磁盘地址。如果该指针的值为 $p$，则栈顶元素是磁盘的 $\left|\frac{p}{m}\right|$ 页上的第 $(p \mod m)$ 个字，这里 $m$ 为每页所含的字数。

为了实现 PUSH 操作，我们增加栈指针，从磁盘将适当的页读到主存中后，复制要被压入栈的元素到该页上适当字的位置，最后将该页写回到磁盘。POP 操作与之类似。我们减小栈指针，从磁盘上读入所需的页，再返回栈顶元素。我们不需要写回该页，因为它没有被修改。

因为磁盘操作代价相对较高，我们统计任何实现的两部分代价：总的磁盘存取次数和总的 CPU 时间。任何对一个包含 $m$ 个字的页面的磁盘存取，都会引起一次磁盘存取和 $\Theta(m)$ 的 CPU 时间。

​	a. 从渐近意义上看，使用这种简单实现，在最坏的情况下，$n$ 个栈操作需要多少次磁盘存取？CPU 时间又是多少？（用 $m$ 和 $n$ 来表示这个问题及后面几个问题的答案。）

现在考虑栈的另一种实现，即在主存中始终保持存放栈中的一页。（还用少量的主存来记录当前哪一页在主存中。）只有相关的磁盘页驻留在主存中，才能执行栈操作。如果需要，可以将当前主存中的页写回磁盘，并且可以从磁盘向主存读入新的一页。如果相关的磁盘页已经在主存，那么就无需任何磁盘存取。

​	b. 最坏情况下，$n$ 个 PUSH 操作所需的磁盘存取次数是多少？所需的 CPU 时间是多少？

​	c. 最坏情况下，$n$ 个栈操作所需的磁盘存取次数是多少？所需的 CPU 时间是多少？

假设现在是在主存中保持栈的 $2$ 页（此外还有少量的字来记录哪些页在主存中）的实现。

​	d. 请描述如何管理栈页，使得任何栈操作的摊还磁盘存取次数为 $O(1/m)$，摊还 CPU 时间为 $O(1)$。

$18$-$2$ （连接与分裂 2-3-4 树）连接操作输入两个动态集合 $S'$ 和 $S''$，以及一个元素 $x$，使得对任何 $x' \in S'$ 和 $x'' \in S''$，有 $x'.key < x.key < x''.key$。它返回一个集合 $S = S' \cup \{x\} \cup S''$。分裂操作就像一个“逆”连接操作：给定一个动态集合 $S$ 和一个元素 $x \in S$，它创建了一个集合 $S'$，其包含 $S-\{x\}$ 中所有关键字小于 $x.key$ 的元素；同时创建了一个集合 $S''$，其包含 $S-\{x\}$ 中所有关键字大于 $x.key$ 的元素。在这个问题中，我们讨论如何在 2-3-4 树上实现这些操作。为方便起见，假定所有元素都只包含关键字，并且所有的关键字都不相同。

​	a. 对 2-3-4 树中的每个结点 $x$，说明如何将以 $x$ 为根的子树的高度作为一个属性 $x.height$ 来维护。要确保所给出的实现不影响查找、插入和删除的渐近运行时间。

​	b. 说明如何实现连接操作。给定两棵 2-3-4 树 $T'$ 与 $T''$ 和一个关键字 $k$，连接操作应在 $O(1+|h'-h''|)$ 运行时间内完成，其中 $h'$ 和 $h''$ 分别是树 $T'$ 和 $T''$ 的高度。

​	c. 考虑从一棵 2-3-4 树 $T$ 的根到一个给定关键字 $k$ 的简单路径 $p$，$T$ 中小于 $k$ 的关键字集合 $S'$，以及 $T$ 中大于 $k$ 的关键字集合 $S''$。证明：$p$ 将 $S'$ 分为一个树的集合 $\{T_0', T_1', \cdots, T_m'\}$ 和一个关键字的集合 $\{k_1', k_2', \cdots, k_m'\}$，且对任何关键字 $y \in T_m'$ 和 $z \in T_m'$ $(i=1,2,\cdots, m)$，都有 $y < k_1' < z$。$T_{i-1}'$ 和 $T_i'$ 的高度之间有什么关系？请说明 $p$ 是如何将 $S''$ 分为树集合和关键字集合的。

​	d. 请说明如何实现 $T$ 上的分裂操作。利用连接操作将 $S'$ 中的关键字拼成一棵简单的 2-3-4 树 $T'$，将 $S''$ 中的关键字拼成一棵简单的 2-3-4 树 $T''$。分裂操作的运行时间要求为 $O(\log n)$，这里 $n$ 是 $T$ 中的关键字个数。（提示：连接的代价应是套迭的。）

## 第十九章 斐波拉契堆

### 练习 19.1

### 练习 19.2

$19.2$-$1$ 给出图 $19$-$4(m)$ 中的斐波那契堆调用 FIB-HEAP-EXTRACT-MIN 后得到的斐波那契堆。

### 练习 19.3

$19.3$-$1$ 假定斐波那契堆中一个根 $x$ 被标记了。解释 $x$ 是如何成为一个被标记的根的。试说明 $x$ 是否被标记对分析并没有影响，即使它不是一个先被链接到另一个结点，后又丢失了一个孩子的根。

$19.3$-$2$ 使用聚合分析来证明 FIB-HEAP-DECREASE-KEY 的 $O(1)$ 摊还时间是每一个操作的平均代价。

### 练习

$19.4$-$1$ Pinocchio 教授声称一个 $n$ 个结点的斐波那契堆的高度是 $O(\log n)$ 的。对于任意的正整数 $n$，试给出经过一系列斐波那契堆操作后，可以创建出一个斐波那契堆，该堆仅仅包含一棵具有 $n$ 个结点的线性链的树，以此来说明该教授是错误的。

$19.4$-$2$ 假定对级联切断操作进行推广，对于某个整数常数 $k$，只要一个结点失去了它的第 $k$ 个孩子，就将其从它的父结点上剪切掉（$19.3$ 节中为 $k=2$ 的情形）。$k$ 取什么值时，有 $D(n)=O(\log n)$。

### 思考题

$19$-$1$ （删除操作的另一种实现）Pisano 教授提出了下面的 FIB-HEAP-DELETE 过程的一个变种，声称如果删除的结点不是由 $H.min$ 指向的结点，那么该程序运行得更快。

```c
PISANO-DELETE(H, x)
	if x == H.min
        FIB-HEAP-EXTRACT-MIN(H)
    else y = x.p
        if y ≠ NIL
            CUT(H, x, y)
            CASCADING-CUT(H, y)
        add x's child list to the root list of H
        remove x from the root list of H
```

a. 该教授的声称是基于第 7 行可以在 $$O(1)$$ 实际时间内完成的这一假设，它的程序可以运行得更快。该假设有什么问题吗？

b. 当 $$x$$ 不是由 $$H.min$$ 指向时，给出 PISANO-DELETE 实际时间的一个好上界。你给出的上界应该以 $$x.degree$$ 和调用 CASCADING-CUT 的次数 $$c$$ 这两个参数来表示。

c. 假定调用 PISANO-DELETE($$H$$, $$x$$)，并设 $$H'$$ 是执行后得到的斐波那契堆。假定结点 $$x$$ 不是一个根，用 $$x.degree$$、$$c$$、$$t(H)$$ 和 $$m(H)$$ 来表示 $$H'$$ 势的界。

d. 证明：PISANO-DELETE 的摊还时间渐近地不好于 FIB-HEAP-DELETE 的摊还时间，即使在 $$x \neq H.min$$ 时也是如此。

19-2 (二项树和二项堆) 二项树 $$B_k$$ 是一棵递归定义的有序树(参看 B. 5. 2 节)。如图 19-6(a)所示，二项树 $$B_0$$ 仅包含一个结点。二项树 $$B_k$$ 是由两个二项树 $$B_{k-1}$$ 组成的，这两棵树按照一棵树的根是另一棵树根的最左孩子的方式链接。图 19-6(b)所示为二项树 $$B_0$$ 到 $$B_4$$ 。

![image-20250118224834280](F:\software\Typora\images\image-20250118224834280.png)

a. 对于二项树 $$B_k$$，证明：

1. 一共有 $$2^k$$ 个结点。

2. 树的高度是 $$k$$。

3. 对于 $$i=0,1,\cdots, k$$，深度为 $$i$$ 的结点恰有 $$\binom{k}{i}$$ 个。

4. 根的度数为 $$k$$，它比其他任意结点的度数都要大。此外，如图 19-6(c)所示，如果把根的孩子从左到右编号为 $$k-1, k-2,\cdots, 0$$，那么孩子 $$i$$ 是子树 $$B_i$$ 的根。

**二项堆(binomial heap) $$H$$** 是具备如下性质的二项树的集合：

1. 每个结点具有一个关键字(与斐波那契堆相同)。

2. $$H$$ 中的每个二项树遵循最小堆性质。

3. 对于任意的非负整数 $$k$$，$$H$$ 中最多有一个二项树的根的度数为 $$k$$。



b. 假定一个二项堆 $$H$$ 一共有 $$n$$ 个结点。讨论 $$H$$ 中包含的二项树与 $$n$$ 的二进制表示之间的关系。并证明 $$H$$ 最多由 $$\lfloor \lg n \rfloor + 1$$ 棵二项树组成。

假定按如下方式表述二项堆。用 10.4 节中的左孩子、右邻兄弟方案来表示二项堆中的每一棵二项树。每个结点包含一个关键字，指向它父结点的指针、指向它最左孩子的指针和指向与它右邻兄弟的指针(这些指针一些情况下是 NIL)，以及它的度数(如同斐波那契堆，表示为有多少个孩子)。这些根组成了一个单向链接的根链表，并以根的度数从小到大排列。可以通过一个指向根链表第一个结点的指针来访问二项堆。

c. 完整描述如何表示一个二项堆(例如，对属性进行命名，描述属性值什么时候为 NIL，定义根链表是怎么组织的)，并说明如何用与本章中实现斐波那契堆一样的方式来实现在二项堆上同样的 7 个操作。每一个操作的最坏时间应该为 $$O(\lg n)$$，其中 $$n$$ 为二项堆中的结点数目(或对于 UNION 操作，为要被合并的两个二项堆中的结点数)。MAKE-HEAP 操作应为常数时间。

d. 假定仅仅要实现在一个斐波那契堆上的可合并堆操作(即并不实现 DECREASE-KEY 和 DELETE 操作)，斐波那契堆中的树与二项堆中的树有何相似之处？有什么区别？证明在一个 $$n$$ 个结点的斐波那契堆中最大度数最多为 $$\lfloor \lg n \rfloor$$。

e. MeGee 教授提出了一个基于斐波那契堆的新的数据结构。一个 MeGee 堆具有与斐波那契堆相同的结构，并且只支持可合并堆操作。除了插人和合并在最后一步中合并根链表外，其他操作的实现方式均与斐波那契堆中的实现方式相同。McGee 堆上各操作的最坏情况运行时间是多少？

19-3 (更多的斐波那契堆操作) 想要扩展斐波那契堆 $$H$$ 支持两个新操作，要求不改变斐波那契堆其他操作的摊还时间。

a. 操作 FIB-HEAP-CHANGE-KEY($$H$$, $$x$$, $$k$$) 将结点 $$x$$ 中关键字的值改为 $$k$$。给出 FIB-HEAP-CHANGE-KEY 的一个有效实现，并分析当 $$k$$ 大于、小于或等于 $$x.key$$ 时，各情形下的摊还运行时间。

b. 给出 FIB-HEAP-PRUNE($$H$$, $$r$$) 的一个有效实现，该操作从 $$H$$ 中删除 $$q=\min(r,H,n)$$ 个结点。可以选择任意 $$q$$ 个结点来删除。试分析你的实现的摊还运行时间。(提示：可能需要修改数据结构以及势函数。)

19-4 (2-3-4 堆) 第 18 章介绍了 2-3-4 树，树中每个内部结点(而不是根)有 2 个、3 个或 4 个孩子，且所有的叶结点有相同的深度。在本问题中，实现支持可合并堆操作的 2-3-4 堆。

2-3-4 堆以下几点与 2-3-4 树不同。在 2-3-4 堆中，仅仅叶结点存储关键字，并且每个叶结点 $$x$$ 仅仅在属性 $$x.key$$ 中存储一个关键字。叶结点中的关键字可能以任意顺序存在。每个内部结点 $$x$$ 包含一个值 $$x.small$$，它等于以 $$x$$ 为根的子树中叶结点存储的最小的关键字。根 $$r$$ 包含一个属性 $$r.height$$，存储树的高度。最后，2-3-4 堆设计为存放在主存中，这样磁盘的读/写是不需要的。

实现下面的 2-3-4 堆操作。在一个具有 $$n$$ 个元素的 2-3-4 堆上，(a)~(e)中每一个操作应该在 $$O(\lg n)$$ 时间内完成。(f)中的 UNION 操作应该在 $$O(\lg n)$$ 时间内完成，其中 $$n$$ 为输入的两个堆元素个数之和。

a. MINIMUM，该操作返回一个指向具有最小关键字的叶结点的指针。

b. DECREASE-KEY，该操作将一个给定的叶结点 $$x$$ 的关键字减小为给定的值 $$k \leqslant x.key$$。

c. INSERT，该操作插人一个关键字为 $$k$$ 的叶结点 $$x$$。

d. DELETE，该操作删除一个给定的叶结点 $$x$$。

e. EXTRACT-MIN，该操作抽取具有最小关键字的叶结点。

f. UNION, 该操作合并两个 2-3-4 堆，并返回一个单独的 2-3-4 堆，销毁掉输入的堆。



## 第二十章 Van Emde Boas 树

### 练习 20.1

20.1-1 修改本节中的数据结构，使其支持重复关键字。

20.1-2 修改本节中的数据结构，使其支持带有卫星数据的关键字。

20.1-3 使用本节的数据结构会发现，查找 $$x$$ 的后继和前驱并不依赖于 $$x$$ 当时是否包含在集合中。当 $$x$$ 不包含在树中时，试说明如何在一棵二叉搜索树中查找 $$x$$ 的后继。

20.1-4 假设不使用一棵叠加的度为 $$\sqrt{u}$$ 的树，而是使用一棵叠加的度为 $$u^{1/k}$$ 的树，这里 $$k$$ 是大于 1 的常数，则这样的一棵树的高度是多少？又每个操作将需要多长时间？

### 练习 20.2

20.2-1 写出 PROTO-vEB-MAXIMUM 和 PROTO-vEB-PREDECESSOR 过程的伪代码。

20.2-2 写出 PROTO-vEB-DELETE 的伪代码。通过扫描簇内的相关位，来更新相应的 summary 位。并且你实现的伪代码的最坏情况运行时间是多少？

20.2-3 为每个 proto-vEB 结构增加属性 $$n$$，以给出其所在集合中的元素个数，然后写出 PROTO-vEB-DELETE 的伪代码，要求使用属性 $$n$$ 来确定何时将 summary 重置为 0。你的伪代码的最坏情况运行时间是多少？由于加入了新的属性 $$n$$，其他的操作要改变吗？这些变化会影响到它们的运行时间吗？

20.2-4 修改 proto-vEB 结构，以支持重复关键字。

20.2-5 修改 proto-vEB 结构，以支持带有卫星数据的关键字。

20.2-6 写出一个创建 proto-vEB($$u$$) 结构的伪代码。

20.2-7 试说明如果 PROTO-vEB-MINIMUM 中的第 9 行被执行，则 proto-vEB 结构为空。

20.2-8 假设设计了这样一个 proto-vEB 结构，其中每个簇数组仅有 $$u^{1/4}$$ 个元素。那么每个操作的运行时间是多少？

### 练习 20.3

20.3-1 修改 vEB 树以支持重复关键字。

20.3-2 修改 vEB 树以支持带有卫星数据的关键字。

20.3-3 写出创建空 van Emde Boas 树过程的伪代码。

20.3-4 如果调用 vEB-TREE-INSERT 来插入一个已包含在 vEB 树中的元素，会出现什么情况？如果调用 vEB-TREE-DELETE 来删除一个不包含在 vEB 树中的元素，会出现什么情况？解释这些函数为什么有相应的运行状况？怎样修改 vEB 树和操作，使得常数时间内能判断一个元素是否在其中？

20.3-5 假设我们创建一个包含 $$u^{1/k}$$ 个簇(而不是全域大小为 $$\sqrt{u}$$ 的 $$\sqrt{u}$$ 个簇)的 vEB 树，其每个簇的全域大小为 $$u^{1-1/k}$$，其中 $$k>1$$，而且 $$k$$ 为常数。如果恰当地修改这些操作，则这些操作的运行时间是多少？为了分析方便，假设 $$u^{1/k}$$ 和 $$u^{1-1/k}$$ 总是为整数。

20.3-6 创建一个全域大小为 $$u$$ 的 vEB 树，需要 $$O(u)$$ 的运行时间。假设我们想得到确切时间。如果 vEB 树中每个操作的摊还时间为 $$O(\lg \lg u)$$，那么最小的操作数 $$n$$ 是多少？

### 思考题

20.1 (van Emde Boas 树的空间需求) 这个问题讨论 van Emde Boas 树的空间需求，并给出一种修改数据结构的方法，使其空间需求依赖元素个数 $$n$$，而不是全域大小 $$u$$。为简单起见，假设 $$\sqrt{u}$$ 总是为整数。

a. 解释为什么下面的递归式表示全域大小为 $$u$$ 的 van Emde Boas 的空间需求 $$P(u)$$。
$$
P(u)=(\sqrt{u}+1) P(\sqrt{u})+\Theta(\sqrt{u})\quad\text{(20.5)}
$$

b. 证明：递归式(20.5)的解为 $$P(u)=O(u)$$。

为了减少空间需求，定义一棵缩减空间的 van Emde Boas 树(reduced-space van Emde Boas tree)，或 $$RS-vEB$$ 树。$$RS-vEB$$ 树是一棵 vEB 树，但做出了如下修改：

- 属性 $$V.cluster$$ 并不是一个指向全域大小为 $$\sqrt{u}$$ 的 vEB 树的简单指针数组，而是一个散列表(见第 11 章)，以动态表的方式来存储(见 17.4 节)。相应于 $$V.cluster$$ 的数组版本，而散列表存储指向全域大小为 $$\sqrt{u}$$ 的 RS-vEB 树的指针。于是要查找第 $$i$$ 个簇，就在散列表中查找关键字 $$i$$，所以可以用在散列表中的简单搜索找到第 $$i$$ 个簇。

- 散列表只存储指向非空簇的指针，在散列表中搜索一个空簇，返回 NIL，表示这个簇为空。

- 如果所有的簇为空，则属性 $$V.summary$$ 为 NIL；否则，$$V.summary$$ 指向全域大小为 $$\sqrt{u}$$ 的 $$RS-vEB$$ 树。

因为散列表使用动态表来实现，所以需要的空间与非空簇的数量成正比。

当需要向空 RS-vEB 树插入一个元素时，调用下面的过程创建 RS-vEB 树，其中参数 $$u$$ 是 $$RS-vEB$$ 树的全域大小：

```
CREATE-NEW-RS-vEB-TREE(u)
    allocate a new vEB tree V
    V.u = u
    V.min = NIL
    V.max = NIL
    V.summary = NIL
    create V.cluster as an empty dynamic hash table
    return V
```

c. 修改 vEB-TREE-INSERT 过程的伪代码，来形成 RS-vEB-TREE-INSERT($$V$$, $$x$$) 的伪代码，实现将 $$x$$ 插入 RS-vEB 树 $$V$$ 中，并且调用相应的 CREATE-NEW-RS-vEB-TREE。

d. 修改 vEB-TREE-SUCCESSOR 过程的伪代码，来形成 RS-vEB-TREE-SUCCESSOR($$V$$, $$x$$) 的伪代码，实现返回 $$x$$ 在 RS-vEB 树 $$V$$ 中的后继，或者如果 $$x$$ 在 $$V$$ 中无后继，则返回 NIL。

e. 在简单均匀散列的假设下，证明：你实现的 RS-vEB-TREE-INSERT 和 RS-vEB-TREE-SUCCESSOR 的期望运行时间为 $$O(\lg \lg u)$$。

f. 假设从不删除 vEB 树中的元素，证明：$$RS\text{-}vEB$$ 树结构的空间需求为 $$O(n)$$，其中 $$n$$ 是存储在 RS-vEB 树中的实际元素个数。

g. 相比 vEB 树，RS-vEB 树具有另一个优点：创建树的时间较少。创建一棵空 RS-vEB 树需要多长时间？

20-2 (y-fast 检索树) 本题讨论的是 D. Willard 的 y-fast 检索树，它与 van Emde Boas 树类似。一个全域大小为 $$u$$ 的 y-fast 检索树的 MEMBER、MINIMUM、MAXIMUM、PREDECESSOR 和 SUCCESSOR 操作的最坏情况运行时间为 $$O(\lg \lg u)$$。INSERT 和 DELETE 操作的摊还时间为 $$O(\lg \lg u)$$。像缩减空间的 van Emde Boas 树一样（见思考题 20-1），y-fast 检索树存储 $$n$$ 个元素的空间仅需要 $$O(n)$$ 空间。y-fast 检索树的设计依赖于完全散列（见 11.5 节）。

假设创建一个完全散列表作为初步的结构，该散列表中不仅包含动态集合中的每个元素，而且还包含这些元素的二进制前缀。例如，如果 $$u=16$$，那么 $$\lg u=4$$，并且 $$x=13$$ 在集合中，由于 13 的二进制表示为 1101，因此完全散列表应含有串 1、11、110 和 1101。除了该散列表外，还要创建一个该集合当前元素以升序排列的双向链表。

a. 这个数据结构的空间需求是多少？

b. 如何在 $$O(1)$$ 时间内完成 MINIMUM 和 MAXIMUM 操作？如何在 $$O(\lg \lg u)$$ 时间内完成 MEMBER、PREDECESSOR 和 SUCCESSOR 操作？如何在 $$O(\lg u)$$ 时间内完成 INSERT 和 DELETE 操作？

为了将空间需求减少到 $$O(n)$$，我们对数据结构做出如下修改：

- 将 $$n$$ 个元素分成大小为 $$\lg u$$ 的 $$n/\lg u$$ 个组。（假设 $$\lg u$$ 可以整除 $$n$$。）第一组由最小的 $$\lg u$$ 个元素组成，第二组由下面 $$\lg u$$ 个最小的元素组成，依此类推。

- 对每个组都设置一个“代表”。第 $$i$$ 组的代表至少与组里的最大元素一样大，而且比第 $$i+1$$ 组的最小元素要小。（最后一组的代表可以是最大的可能元素 $$u-1$$。）注意，代表可能是一个值并不包含在集合中。

- 把每组的 $$\lg u$$ 个元素存储到一个平衡二叉搜索树中，比如红黑树。每个代表指向它所在组中的平衡二叉搜索树，而且每个平衡二叉搜索树指向它的代表。

- 完全散列表仅存储这些代表，也是用双向链表按升序排列来存储。

我们称这种结构为一个 y-fast 检索树。

c. 说明一个 y-fast 检索树存储 $$n$$ 个元素的空间需求仅为 $$O(n)$$。

d. 说明使用 y-fast 检索树，如何在 $$O(\lg \lg u)$$ 时间内完成 MINIMUM 和 MAXIMUM 操作？

e. 说明如何在 $$O(\lg \lg u)$$ 时间内完成 MEMBER 操作？

f. 说明如何在 $$O(\lg \lg u)$$ 时间内完成 PREDECESSOR 和 SUCCESSOR 操作？

g. 解释为什么 INSERT 和 DELETE 操作要耗费 $$O(\lg \lg u)$$ 时间？

h. 在 y-fast 检索树中每组需要精确的 $$\lg u$$ 个元素存储，试说明如何放松这个存储需求来保证在 $$O(\lg \lg u)$$ 摊还时间内完成 INSERT 和 DELETE 操作，并同时不影响其他操作的渐近运行时间。



## 第二十一章 用于不相交集合的数据结构

### 练习 21.1

21.1-1 假设 CONNECTED-COMPONENTS 作用于一个无向图 $$G=(V, E)$$，这里 $$V=\{a, b, c, d, e, f, g, h, i, j, k\}$$，且 $$E$$ 中的边以如下的顺序处理：$$(d, i), (f, k), (g, i), (b, g), (a, h), (i, j), (d, k), (b, j), (d, f), (g, j), (a, e)$$。请列出在每次执行完第 3~5 行后各连通分量的顶点。

21.1-2 证明：CONNECTED-COMPONENTS 处理完所有的边后，两个顶点在相同的连通分量中当且仅当它们在同一个集合中。

21.1-3 在 CONNECTED-COMPONENTS 作用于一个有 $$k$$ 个连通分量的无向图 $$G=(V, E)$$ 的过程中，FIND-SET 需要调用多少次？UNION 需要调用多少次？用 $$|V|$$、$$|E|$$ 和 $$k$$ 来表示你的答案。

### 练习 21.2

21.2-1 使用链表表示和加权合并启发式策略，写出 MAKE-SET、FIND-SET 和 UNION 操作的伪代码。并指定你在集合对象和表对象中所使用的属性。

21.2-2 给出下面程序的结果数据结构，并回答该程序中 FIND-SET 操作返回的答案。这里使用加权合并启发式策略的链表表示。
```c
for i=1 to 16
	MAKE-SET(x_i) 
for i=1 to 15 by 2 
	UNION(x_i, x_{i+i}) 
for i=1 to 13 by 4 
	UNION(x_i, x_{i+2}) 
UNION(x1 ,x5) 
UNION(x11 ,x13) 
UNIONCx1, x10) 
FIND-SETCx2) 
FIND-SET(x9) 
```



假定如果包含 $$x_i$$ 和 $$x_j$$ 的集合有相同的大小，则 UNION($$x_i$$, $$x_j$$) 表示将 $$x_j$$ 所在的表链接到 $$x_i$$ 所在的表后。

21.2-3 对定理 21.1 的整体证明进行改造，得到使用链表表示和加权合并启发式策略下的 MAKE-SET 和 FIND-SET 的摊还时间上界为 $$O(1)$$，以及 UNION 的摊还时间上界为 $$O(\lg n)$$。

21.2-4 请给出图 21-3 所示操作序列的一个运行时间的渐近紧确界，假定使用链表表示和加权合并启发式策略。

21.2-5 Gompers 教授猜想也许有可能在每个集合对象中仅使用一个指针，而不是两个指针 (head 和 tail)，同时仍然保留每个链表元素的 2 个指针。请说明教授的猜想是有道理的，并通过描述如何使用一个链表来表示每个集合，使得每个操作与本章中描述的操作有相同的运行时间，来加以解释。同时描述这些操作是如何工作的。你的方法应该允许使用加权合并启发式策略，并与本节所描述的有相同效果。（提示：使用一个链表的尾作为集合的代表。）

21.2-6 假设对 UNION 过程做一个简单的改动，在采用链表表示中拿掉让集合对象的 tail 指针总指向每个表的最后一个对象的要求。无论是使用还是不使用加权合并启发式策略，这个修改不应该改变 UNION 过程的渐近运行时间。（提示：而不是把一个表链接到另一个表后面，将它们拼接在一起。）

### 练习 21.3

21.3-1 用按秩合并与路径压缩启发式策略的不相交集合森林重做练习 21.2-2。

21.3-2 写出使用路径压缩的 FIND-SET 过程的非递归版本。

21.3-3 给出一个包含 $$m$$ 个 MAKE-SET、UNION 和 FIND-SET 操作的序列(其中有 $$n$$ 个是 MAKE-SET 操作)，当仅使用按秩合并时，需要 $$\Omega(m \lg n)$$ 的时间。

21.3-4 假设想要增加一个 PRINT-SET($$x$$) 操作，它是对于给定的结点 $$x$$ 打印出 $$x$$ 所在集合的所有成员，顺序可以任意。如何对一棵不相交集合森林的每个结点仅增加一个属性，使得 PRINT-SET($$x$$) 所花费的时间同 $$x$$ 所在集合元素的个数呈线性关系，并且其他操作的渐近运行时间不改变。这里假设我们可在 $$O(1)$$ 的时间内打印出集合的每个成员。

*21.3-5 证明：任何具有 $$m$$ 个 MAKE-SET、UNION 和 FIND-SET 操作的序列，这里所有的 LINK 操作都出现在 FIND-SET 操作之前，如果同时使用路径压缩和按秩合并启发式策略，则这些操作只需 $$O(m)$$ 的时间。在同样情况下，如果只使用路径压缩启发式策略，又会如何？

### 练习 21.4

21.4-1 证明引理 21.4。

21.4-2 证明：每个结点的秩最多为 $$\lfloor \lg n \rfloor$$。

21.4-3 根据练习 21.4-2 的结论，对于每个结点 $$x$$，需要多少位 (bit) 来存储 $$x.rank$$？

21.4-4 利用练习 21.4-2，请给出一个简单的证明，证明在一个不相交集合森林上使用按秩合并策略而不使用路径压缩策略的运行时间为 $$O(m \lg n)$$。

21.4-5 Dante 教授认为，因为各结点的秩在一条指向根的简单路径上是严格递增的，所以结点的级沿着路径也一定是单调递增的。换句话说，如果 $$x.rank > 0$$，并且 $$x.p$$ 不是一个根，那么 $$\text{level}(x) \leqslant \text{level}(x.p)$$。请问这位教授的想法正确吗？

*21.4-6 考虑函数 $$\alpha'(n) = \min\{k : A_k(1) \geqslant \lg(n+1)\}$$。证明：对于 $$n$$ 的所有实际值，有 $$\alpha'(n) \leqslant 3$$，并利用练习 21.4-2，说明如何去修改势函数的参数来证明对于一组 $$m$$ 个 MAKE-SET、UNION 和 FIND-SET 操作的序列（其中 $$n$$ 个是 MAKE-SET 操作），我们能在一个不相交集合森林上使用按秩合并与路径压缩在最坏情况时间 $$O(m \alpha'(n))$$ 内处理完。



### 思考题

21-1 （脱机最小值问题）脱机最小值问题 (off-line minimum problem) 是使用 INSERT 和 EXTRACT-MIN 操作维护一个元素取自域 $$\{1, 2, \cdots, n\}$$ 的动态集合 $$T$$。给定一组包含 $$n$$ 个 INSERT 和 $$m$$ 个 EXTRACT-MIN 的调用序列 $$S$$，其中属于 $$\{1, 2, \cdots, n\}$$ 中的每个关键字只被插入一次。我们希望确定每个 EXTRACT-MIN 调用返回的是哪个关键字。特别地，希望对一个 extracted [1..m]($$i = 1, 2, \cdots, m$$) 数组进行填充，其中 extracted [$$i$$] 是由第 $$i$$ 次 EXTRACT-MIN 调用所返回的关键字。该问题是“脱机的”，其含义就是在确定任何返回的关键字之前处理整个序列 $$S$$。

a. 在下面脱机最小值问题的实例中，每个操作 INSERT($$i$$) 用一个 $$i$$ 值来表示，并且每个 EXTRACT-MIN 用字母 E 来表示：
  			
$$
4, 8, E, 3, E, 9, 2, 6, E, E, E, 1, 7, E, 5
$$
   将正确的值填入 extracted 数组。

为了设计出解决此问题的算法，我们把序列 $$S$$ 划分成若干个同构的子序列，即如下表示 $$S$$：
$$
I_1, E, I_2, E, I_3, \cdots, I_m, E, I_{m+1}
$$
这里每个 E 代表单次 EXTRACT-MIN 调用，并且每个 $$I_j$$ 代表一个（可能为空的）INSERT 调用序列。对于每个子序列 $$I_j$$，开始时把由这些操作插入的关键字插入一个集合 $$K_j$$，如果 $$I_j$$ 为空，那么它也为空。然后执行下面的程序：

```
OFF-LINE-MINIMUM(m,n) 
	for i = 1 to n 
		determine j such that i 属于 Kj; 
		if j≠ m+l 
			extracted[j] = i 
			let l be the smallest value greater than j 
				for which set Kl, exists 
			Kl=Kj∪Kl，destroying Kj 
	return extracted
```

b. 证明：由 OFF-LINE-MINIMUM 返回的数组 extracted 是正确的。

c. 描述如何用不相交集合数据结构来高效实现 OFF-LINE-MINIMUM。给出实现的最坏情况运行时间的紧确界。

21-2 （深度确定）在深度确定 (depth-determination) 问题中，我们通过以下三个操作来维护一个有根树的森林 $$\mathcal{F} = \{T_i\}$$：

- MAKE-TREE(v)：创建一棵只包含唯一结点 $$v$$ 的树。
- FIND-DEPTH(v)：返回结点 $$v$$ 在树中的深度。
- GRAFT(r, v)：使得结点 $$r$$（假定它为一棵树的树根）成为结点 $$v$$ 的孩子（假定它在另一棵树中，但是它本身可能是、也可能不是一棵树的根）。

a. 假设采用类似于不相交集合森林的树表示：$$v.p$$ 是结点 $$v$$ 的父结点，除了 $$v$$ 是根时 $$v.p = v$$ 的这种情况。进一步假设，我们可以通过置 $$r.p = v$$ 来实现 GRAFT(r, v)，并且可以通过沿着查找路径上升至根，返回一个除 $$v$$ 以外的结点数来实现 FIND-DEPTH(v)。证明：一组 $$m$$ 个 MAKE-TREE、FIND-DEPTH 和 GRAFT 操作的序列的最坏情况运行时间是 $$\Theta(m^2)$$。

通过使用按秩合并与路径压缩启发式策略，能减少最坏情况运行时间。我们使用不相交集合森林 $$\mathcal{S} = \{S_i\}$$，其中每个集合 $$S_i$$（它本身是一棵树）对应于一棵森林 $$\mathcal{F}$$ 中的树 $$T_i$$。然而，集合 $$S_i$$ 中的树结构没有必要对应于 $$T_i$$ 的树结构。实际上，$$S_i$$ 的实现并没有记录准确的父子关系，但它允许我们确定 $$T_i$$ 中任意结点的深度。

关键的思想是维护每个结点 $$v$$ 的一个“伪距离” $$v.d$$，它被定义为使得沿着从 $$v$$ 到它的集合 $$S_i$$ 的根的简单路径上的伪距离之和等于 $$T_i$$ 中结点 $$v$$ 的深度。也就是说，如果从 $$v$$ 到它在 $$S_i$$ 的根的简单路径为 $$v_0, v_1, \cdots, v_k$$（这里 $$v_0 = v$$ 并且 $$v_k$$ 是 $$S_i$$ 的根），那么结点 $$v$$ 在树 $$T_i$$ 上的深度为 $$\sum_{j=0}^k v_j.d$$。

b. 给出 MAKE-TREE 的一种实现。

c. 说明应如何修改 FIND-SET 来实现 FIND-DEPTH。你的实现要采用路径压缩，并且它的运行时间应与查找路径的长度呈线性关系。试确保你的实现能正确地更新伪距离。

d. 说明如何实现 GRAFT(r, v)，它通过修改 UNION 和 LINK 过程来合并包含 $$r$$ 和 $$v$$ 的集合。试确保你的实现能正确地更新伪距离。并注意到，集合 $$S_i$$ 的根没有必要是对应树 $$T_i$$ 的根。

e. 试给出一组 $$m$$ 个 MAKE-TREE、FIND-DEPTH 和 GRAFT 操作的序列（其中 $$n$$ 个是 MAKE-TREE 操作）最坏情况运行时间的一个紧确界。

21-3 （Tarjan 的脱机最小公共祖先算法）在一棵有根树 $$T$$ 中，两个结点 $$u$$ 和 $$v$$ 的最小公共祖先 (least common ancestor) $$w$$ 是结点 $$u$$ 和 $$v$$ 的一个共同祖先，且它有最大的深度。在脱机最小公共祖先问题 (off-line least-common-ancestors problem) 中，给定一棵有根树 $$T$$ 和一个在 $$T$$ 中的无序结点对的任意集合 $$P = \{(u, v)\}$$，我们希望确定 $$P$$ 中每对的最小公共祖先。

为了解决脱机最小公共祖先问题，下面的过程通过对 LCA($$T.root$$) 的初始调用，来执行对 $$T$$ 的树遍历。假设在执行遍历之前，每个结点被着色为白色。

```
LCA(u)
MAKE-SET(u)
FIND-SET(u). ancestor=u 
for each child v of u in T 
	LCA(v) 
	UNION(u,v) 
	FIND-SET(u). ancestor=u 
u.color= BLACK 
for each node v such that {u,v) E P 
	if v. color= BLACK 
		print "The least common ancestor of " 
			u "and" v "is" FIND-SET (v). ancestor
```

a. 证明：对每对 $$\{u, v\} \in P$$，第 10 行恰好只执行一次。

b. 证明：在调用 $LCA(u)$ 时，不相交集合数据结构的集合数等于 $$T$$ 中 $$u$$ 的深度。

c. 证明：对于每对 $$\{u, v\} \in P$$，$LCA$ 能正确地输出 $$u$$ 和 $$v$$ 的最小公共祖先。

d. 假设我们使用 21.3 节中的不相交集合数据结构实现，试分析 $LCA$ 的运行时间。







