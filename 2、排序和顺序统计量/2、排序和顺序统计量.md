

# 第二部分 排序和顺序统计量

## 第六章 堆排序

### 练习 6.1

> **6.1-1** 在高度为 $h$ 的堆中，元素个数最多和最少分别是多少？

根据图 6-1，高度为 $h$ 的堆中，树有 $h+1$ 层

元素个数最多时，第 $h+1$ 层满，构成满二叉树，此时元素个数为：
$$
2^0 + 2^1 + \cdots + 2^h = 2^{h+1} - 1
$$
第 $h+1$ 层有 $2^{h}$ 个元素，等比数列求和，得到元素个数最多为 $2^{h+1} - 1$

元素个数最少时，第 $h+1$ 层只有一个元素，此时元素个数为：
$$
2^0 + 2^1 + \cdots + 2^{h-1}+1 = 2^{h}
$$
 因此元素个数最少为 $2^h$

---

> **6.1-2** 证明：含 $n$ 个元素的堆的高度为 $\lfloor \lg n \rfloor$。

根据题 6.1-1，高度为 h 的堆中，元素个数 n 的取值范围为： $2^h \leq n \leq 2^{h+1}-1$，也就是 $log_2(n+1)-1 \leq h \leq log_2(n)$，其中 log_2(n+1)-1 > log_2(n)-1，所以 $h=\lfloor log_2(n) \rfloor$

---

> **6.1-3** 证明：在最大堆的任一子树中，该子树所包含的最大元素在该子树的根结点上。

根据最大堆的性质，树中任意父结点元素大于等于它的子结点元素，反证法，假设在最大堆的子树中，存在一个子树，它包含的最大元素不在该子树的根结点上，而在其他地方，尽管根结点可能仍满足元素大于等于它的子结点元素，但由于最大元素结点不在根结点上，故它一定存在父结点，而它的父结点元素只能小于等于最大元素，如果小于，则不满足最大堆的性质，得出矛盾；如果等于，则该父结点也是最大元素，那么同理，该父结点的父结点元素也只能小于等于最大元素，如果小于，则不满足最大堆的性质，得出矛盾；如果等于，继续往上追溯，直到最大元素结点为根结点，或者得出矛盾；

---

> **6.1-4** 假设一个最大堆的所有元素都不相同，那么该堆的最小元素应该位于哪里？

树的最底层的叶子结点

堆中所有元素的值都不相同，最小的元素必定不可能出现在堆的任何非叶子结点处，因为非叶子结点必定有比它小的子结点。而在堆的底层，所有结点都是叶子结点，这些叶子结点没有子结点，因此它们的值相对于其他结点的值较小。

---

> **6.1-5** 一个已排好序的数组是一个最小堆吗？

不是。首先已排好序，也可能是降序排列，第一个元素是最大元素，就算是升序排列，第一个元素是最小元素，也不是最小堆，因为最小堆是树形结构，是一颗完全二叉树，同时任意父结点元素值大于等于其子结点元素值；但是数组是线性结构，也没有父结点、子结点关系。

---

> **6.1-6** 值为 $\langle 23, 17, 14, 6, 13, 10, 1, 5, 7, 12 \rangle$ 的数组是一个最大堆吗？

```c++
         23
       /    \
     17       14
    /  \     /  \
   6    13  10   1
  / \   / 
 5   7 12
```

不是。在一个完全二叉树（堆的结构）中，我们可以通过数组的索引来确定父结点和子结点的位置。具体规则如下：对索引为 i 的结点，其左子结点索引为 $2i$，右子结点索引为 $2i+1$，对于索引为 4 的结点 6 来说，其右结点索引 2*4+1 = 9 对应的元素值是 7，6 比 7 小，不满足最大堆的定义。

---

> **6.1-7** 证明：当用数组表示存储 $n$ 个元素的堆时，叶结点下标分别是 $\lfloor n/2 \rfloor + 1$，$\lfloor n/2 \rfloor + 2$，$\cdots$，$n$。

在堆中，对于索引为 $i$ 的结点，其左子结点索引为 $2i$，右子结点索引为 $2i+1$，如果该结点为叶子结点，那么应该满足：
$$
\begin{cases}  2i > n \\ 2i+1 > n \end{cases}
$$
也就是要满足 $i>n/2$，所以满足条件的最小叶子结点索引就是 $\lfloor n/2 \rfloor +1$，然后依次递增加 1，直到 $n$

---

### 练习 6.2

> **6.2-1** 参照图 6-2 的方法，说明 MAX-HEAPIFY(A, 3) 在数组 $A = \langle 27, 17, 3, 16, 13, 10, 1, 5, 7, 12, 4, 8, 9, 0 \rangle$ 上的操作过程。

<img src="F:\software\Typora\images\image-20250314104722049.png" alt="image-20250314104722049" style="zoom:50%;" />

```c++
                                               27
                                            /      \
                                         17          3
                                        /  \        /  \
                                      16    13    10    1
                                     /  \  /  \  / \   /
                                    5   7 12  4 8   9 0
```

当 `A.heap-size=14` 时，`MAX-HEAPIFY(A, 3)` 的执行过程如下：在结点 i = 3 出，A [3] 违背了最大堆性质，因为它的值比它的子结点值小，因此通过交换它和它较大子结点 i = 6 的值，结点 3 恢复最大堆性质；但破坏了 i = 6 的最大堆性质，因此递归调用 `MAX-HEAPIFY(A, 6)`，此时 i = 6，交换它和它较大子结点 i = 13 的值，i = 6 恢复最大堆性质；再次递归调用 `MAX-HEAPIFY(A, 13)`，此时不再有新的数据交换。

---

> **6.2-2** 参考过程 MAX-HEAPIFY，写出能够维护相应最小堆的 MIN-HEAPIFY(A, i) 的伪代码，并比较 MIN-HEAPIFY 与 MAX-HEAPIFY 的运行时间。

```c++
MIN-HEAPIFY(A, i)
	l = LEFT(i)
	R = RIGHT(i)
	if l <= A.heap-size and A[l]<=A[i]
        minst = l
	else minst = i
	if r <= A.heap-size and A[r]<=A[minst]
        minst = r
	if(minst ≠ i)
        exchange A[i] with A[minst]
        MIN-HEAPIFY(A, minst)
	return
```

两者的最差运行时间一致，都是从结点索引 $i$ 开始递归往下恢复最大或最小堆性质，直到叶子结点

---

> **6.2-3** 当元素 $A[i]$ 比其孩子的值都大时，调用 MAX-HEAPIFY(A, i) 会有什么结果？

```c++
MAX-HEAPIFY (A, i) 
    l = LEFT (i) 
    r = RIGHT (i) 
    if l <= A.heap-size and A[l] > A[i] 
    	largest = l 
    else largest = i 
    if r<= A.heap-size and A[r] > A[largest] 
    	largest = r 
    if largest ≠ i 
    	exchange A[i] with A[largest] 
    	MAX-HEAPIFY (A, largest)
```

书上所给的 `MAX-HEAPIFY (A, i)` 没有终止条件，如果索引 $i$ 的结点不满足最大堆性质，可以往下递归，但是当当前索引 i 的结点满足最大堆性质时，三个 if 条件都不会满足，程序自然结束。

---

> **6.2-4** 当 $i > A.heap\text{-}size/2$ 时，调用 MAX-HEAPIFY(A, i) 会有什么结果？

程序会直接结束不进行任何操作。根据 6.1-7，索引 $i > A.heap\text{-}size/2$ 时，该结点为叶子结点，对于叶子结点来说，索引 `l = LEFT (i)、r = RIGHT (i)` 超出了 A.heap-size 大小。

---

> **6.2-5** MAX-HEAPIFY 的代码效率较高，但第 10 行中的递归调用可能例外，它可能使某些编译器产生低效的代码。请用循环控制结构取代递归，重写 MAX-HEAPIFY 代码。

```c++
MAX-HEAPIFY(A, i)
    while TRUE
        l = LEFT(i)
        r = RIGHT(i)
        if l <= A.heap-size and A[l] > A[i]
            largest = l
        else
            largest = i
        if r <= A.heap-size and A[r] > A[largest]
            largest = r
        if largest ≠ i
            exchange A[i] with A[largest]
            i = largest  // 更新 i，继续处理下一个子树
        else
            break  // 如果没有发生交换，堆已经是最大堆，退出循环

```

---

> **6.2-6** 证明：对一个大小为 $n$ 的堆，MAX-HEAPIFY 的最坏情况运行时间为 $\Omega(\lg n)$。（提示：对于 $n$ 个结点的堆，可以通过对每个结点设定恰当的值，使得从根结点到叶结点路径上的每个结点都会递归调用 MAX-HEAPIFY。）

根据提示，若从根结点到叶结点路径上的每个结点都会递归调用 MAX-HEAPIFY，则对于大小为 n 的堆，二叉树的高度为 $\lfloor \lg n \rfloor$，也就是从根结点到叶子结点的路径长度，也就是需要递归调用 MAX-HEAPIFY 的次数，再结合主定理求解。

---

### 练习 6.3

> **6.3-1** 参照图 6-3 的方法，说明 BUILD-MAX-HEAP 在数组 $A = \langle 5, 3, 17, 10, 84, 19, 6, 22, 9 \rangle$ 上的操作过程。

```
                                    5
                                 /     \
                               3         17
                             /   \      /   \
                           10     84  19     6
                          /  \
                        22    9

```

```c++
BUILD-MAX-HEAP(A) 
    A.heap-size = A.length 
    for i = LA.length/2」 downto 1 
    	MAX-HEAPIFY(A, i) 
```

BUILD-MAX-HEAP 在该数组上的执行过程如下：数组 A 的长度为 9，$\lfloor A.length/2 \rfloor = 4$，因此首先调用 `MAX-HEAPIFY(A, 4)` ，将索引为 4 的节点转化为平凡最大堆的根节点（将 10 和 22 调换位置）；然后调用 `MAX-HEAPIFY(A, 3)`，将索引为 3 的节点转化为平凡最大堆的根节点（将 17 和 19 调换位置）；然后调用 `MAX-HEAPIFY(A, 2)`，将索引为 2 的节点转化为平凡最大堆的根节点（将 3 和 84 调换位置）；然后调用 `MAX-HEAPIFY(A, 1)`，将索引为 1 的节点转化为平凡最大堆的根节点（将 5 和 84 调换位置，注意此时会破坏索引为 2 的节点的最大堆的性质，所以会递归调用 MAX-HEAPIFY(A, 2)，参见 MAX-HEAPIFY 的实现，直到索引 1 的节点成为整个堆的根节点）。

---

> **6.3-2** 对于 BUILD-MAX-HEAP 中第 2 行的循环控制变量 $i$ 来说，为什么我们要求它是从 $\lfloor A.length/2 \rfloor$ 到 1 递减，而不是从 1 到 $\lfloor A.length/2 \rfloor$ 递增呢？

减少 MAX-HEAPIFY(A, i) 函数递归调用的深度，可以节约内存的使用，因为从底部逐渐往上调整，先让底部变的满足条件，这样顶层调用 MAX-HEAPIFY(A, i)时需要递归的次数可以减少；另一方面，从顶层开始往下调整，会导致在调整过程中不断修改较大的父节点，可能破坏已经调整好的子树结构，导致额外的计算和不必要的调整。

---

> **6.3-3** 证明：对于任一包含 $n$ 个元素的堆中，至多有 $\left\lceil n/ 2^{h+1} \right\rceil$ 个高度为 $h$ 的结点？

由 6.1-7，对于任一包含 $n$ 个元素的堆中，非叶子节点有 $\lfloor n/2 \rfloor$，因此叶子节点共有:
$$
n-\lfloor n/2 \rfloor =\lceil n/2 \rceil
$$
所以，当 $h=0$ 时，即高度为 0 的结点，为叶子结点，至多有 $\lceil n/2^{0+1} \rceil = \lceil n/2 \rceil$ 成立（==当堆构成满二叉树时达到至多==），采用归纳法证明；

假设当高度为 $h-1$ 时，该式子成立，也就是高为 $h-1$ 的节点至多有 $\lceil n/2^{h} \rceil$ 个

验证 $h=1$ 的情况，高度 $h=1$ 的节点数目可以这样求：去掉包含 $n$ 个元素的堆中高度 $h=0$ 的节点，得到一个新的高度为 $h-1$ 的堆，此时高度为 $h=1$ 的节点数目就是高度为 $h-1$ 的新堆的叶子节点；

新堆包含元素个数为 $\lfloor \frac{n}{2} \rfloor$，新堆的叶子节点数目为 $\lceil \frac{1}{2} \times \lfloor \frac{n}{2} \rfloor \rceil$
$$
\frac{n}{2}-1 <\lfloor \frac{n}{2} \rfloor \leq \frac{n}{2}	\\
\frac{n}{2^2}-\frac{1}{2}<\frac{1}{2} \times \lfloor \frac{n}{2} \rfloor \leq \frac{n}{2^2}	\\
\therefore \quad \lceil \frac{1}{2} \times \lfloor \frac{n}{2} \rfloor \rceil \leq \lceil \frac{n}{2^2} \rceil
$$
所以高 $h=1$ 的节点数目至多有 $\lceil 2/2^{1+1} \rceil$ 满足

同理，采用类似方法，可以逐步证明 $h=2，3，\cdots$ 都满足

|       堆元素个数        |                          内部节点数                          |    叶子节点至多数     |
| :---------------------: | :----------------------------------------------------------: | :-------------------: |
|           $n$           |                    $\lfloor n/2 \rfloor$                     |  $\lceil n/2 \rceil$  |
|  $\lfloor n/2 \rfloor$  | $\lfloor \frac{1}{2}\lfloor n/2 \rfloor \rfloor =\lfloor n/2^2 \rfloor$ | $\lceil n/2^2 \rceil$ |
| $\lfloor n/2^2 \rfloor$ |                   $\lfloor n/2^3 \rfloor$                    | $\lceil n/2^3 \rceil$ |

叶子节点至多数目在堆构成满二叉树时成立。高度 $h$ 每加 1，该高度的节点数就是之前内部节点数构成的新堆的叶子节点数

---

### 练习 6.4

**6.4-1** 参照图 6-4 的方法，说明 HEAPSORT 在数组 $A = \langle 5, 13, 2, 25, 7, 17, 20, 8, 4 \rangle$ 上的操作过程。

<img src="F:\software\Typora\images\image-20250318202432427.png" alt="image-20250318202432427" style="zoom: 67%;" />

```c++
HEAPSORT(A) 
    BUILD-MAX-HEAP(A) 
    for i = A.length downto 2 
        exchange A[1] with A[i] 
        A.heap-size = A.heap-size —1 
        MAX-HEAPIFY(A, 1) 
```

对于数组$A = \langle 5, 13, 2, 25, 7, 17, 20, 8, 4 \rangle$，首先调用BUILD-MAX-HEAP(A)，将这个数组构建为一个最大堆（此时第一个元素A[1]即为数组A的最大值），然后遍历循环，i的取值从A.length递减到2，每次循环，将当前最大值和A[i]交换，也就是依次将堆中最大元素调换到数组A的末尾，然后执行A.heap-size = A.heap-size —1 ，在逻辑上将当前堆的最大元素删除，下次调换的就是数组A中的第二大的元素了，同时i减1，第二大的元素调换到数组A中倒数第二的位置，依次实现升序排列；

**6.4-2** 试分析在使用下列循环不变量时，HEAPSORT 的正确性：在算法的第 2～5 行 for 循环每次迭代开始时，子数组 $A[1..i]$ 是一个包含了数组 $A[1..n]$ 中第 $i$ 小元素的最大堆，而子数组 $A[i+1..n]$ 包含了数组 $A[1..n]$ 中已排序的 $n-i$ 个最大元素？

**6.4-3** 对于一个按升序排列的包含 $n$ 个元素的有序数组 $A$ 来说，HEAPSORT 的时间复杂度是多少？如果 $A$ 是降序呢？

**6.4-4** 证明：在最坏情况下，HEAPSORT 的时间复杂度是 $\Omega(n \lg n)$。

**6.4-5** 证明：在所有元素都不同的情况下，HEAPSORT 的时间复杂度是 $\Omega(n \lg n)$。

### 练习 6.5

**6.5-1** 试说明 HEAP-EXTRACT-MAX 在堆 $A = (15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1)$ 上的操作过程。

**6.5-2** 试说明 MAX-HEAP-INSERT(A, 10) 在堆 $A = (15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1)$ 上的操作过程。

**6.5-3** 要求用最小堆实现最小优先队列，请写出 HEAP-MINIMUM、HEAP-EXTRACT-MIN、HEAP-DECREASE-KEY 和 MIN-HEAP-INSERT 的伪代码。

**6.5-4** 在 MAX-HEAP-INSERT 的第 2 行，为什么我们要先把关键字设为 $-\infty$，然后又将其增加到所需的值呢？

**6.5-5** 试分析在使用下列循环不变量时，HEAP-INCREASE-KEY 的正确性：
在算法的第 4～6 行 while 循环每次迭代开始的时候，子数组 $A[1.. A.heap\text{-}size]$ 要满足最大堆的性质。如果有违背，只有一个可能：$A[i]$ 大于 $A[PARENT(i)]$。

**6.5-6** 在 HEAP-INCREASE-KEY 的第 5 行的交换操作中，一般需要通过三次赋值来完成。想一想如何利用 INSERTION-SORT 内循环部分的思想，只用一次赋值就完成这一交换操作？

**6.5-7** 试说明如何使用优先队列来实现一个先进先出队列，以及如何使用优先队列来实现线。（队列和栈的定义见 10.1 节。）

**6.5-8** HEAP-DELETE(A, i) 操作能够将结点 i 从堆 A 中删除。对于一个包含 n 个元素的堆，请设计一个能够在 $O(\lg n)$ 时间内完成的 HEAP-DELETE 操作。

**6.5-9** 请设计一个时间复杂度为 $O(\pi\lg k)$ 的算法，它能够将 k 个有序链表合并为一个有序链表，这里是所有输入链表包含的总的元素个数。（提示：使用最小堆来完成 k 路归并。）

### 思考题

**6-1 (用插入的方法建堆)** 我们可以通过反复调用 MAX-HEAP-INSERT 实现向一个堆中插入元素，考虑 BUILD-MAX-HEAP 的如下实现方式：

```plaintext
BUILD-MAX-HEAP(A)
    A.heap-size = 1
    for i = 2 to A.length
        MAX-HEAP-INSERT(A, A[i])
```

a. 当输入数据相同的时候，BUILD-MAX-HEAP 和 BUILD-MAX-HEAP' 生成的堆是否总是一样？如果是，请证明；否则，请举出一个反例。

b. 证明：在最坏情况下，调用 BUILD-MAX-HEAP' 建立一个包含 $n$ 个元素的堆的时间复杂度是 $\Theta(n \lg n)$。

**6.2 (对 d 叉堆的分析)** d 叉堆与二叉堆很类似，但（一个可能的例外是）其中的每个非叶结点有 d 个孩子，而不是仅仅 2 个。

​	a. 如何在一个数组中表示一个 d 叉堆？

​	b. 包含 n 个元素的 d 叉堆的高度是多少？请用 n 和 d 表示。

​	c. 请给出 EXTRACT-MAX 在 d 叉最大堆上的一个有效实现，并用 d 和 n 表示出它的时间复杂度。

​	d. 给出 INSERT 在 d 叉最大堆上的一个有效实现，并用 d 和 n 表示出它的时间复杂度。

​	e. 给出 INCREASE-KEY(A, i, k) 的一个有效实现。当 $k < A[i]$ 时，它会触发一个错误，否则执行 $A[i] = k$，并更新相应的 d 叉最大堆，请用 d 和 n 表示出它的时间复杂度。

**6.3 (Young 氏矩阵)** 在一个 m×n 的 Young 氏矩阵 (Young tableau) 中，每一行的数据都是从左到右排序的，每一列的数据都是从上到下排序的。Young 氏矩阵中也会存在一些值为 $\infty$ 的数据项，表示那些不存在的元素。因此，Young 氏矩阵可以用来存储 $r \leqslant mm$ 个有限的数。

​	a. 画出一个包含元素为 (9, 16, 3, 2, 4, 8, 5, 14, 12) 的 4×4 Young 氏矩阵。

​	b. 对于一个 m×n 的 Young 氏矩阵 Y 来说，请证明：如果 Y [1,1] = ∞，则 Y 为空；如果 Y [m, n] < ∞，则 Y 为满（即包含 mn 个元素）。

​	c. 请给出一个在 m×n Young 氏矩阵上时间复杂度为 $O(m+n)$ 的 EXTRACT-MIN 的算法实现。你的算法可以考虑使用一个递归过程，它可以把一个规模为 m×n 的问题分解为规模为 (m−1)×n 或者 m×(n−1) 的子问题（提示：考虑使用 MAX-HEAPIFY）。这里，定义 T(p) 用来表示 EXTRACT-MIN 在任一 m×n 的 Young 氏矩阵上的时间复杂度，其中 p = m+n，给出并求解 T(p) 的递归表达式，其结果为 $O(m+n)$。

​	d. 试说明如何在 $O(m+n)$ 时间内，将一个新元素插入到一个未满的 m×n 的 Young 氏矩阵中。

​	e. 在不用其他排序算法的情况下，试说明如何利用一个 n×n 的 Young 氏矩阵在 $O(m^2)$ 时间内将 $n^2$ 个数进行排序。

​	f. 设计一个时间复杂度为 $O(m+n)$ 的算法，它可以用来判断一个给定的数是否存储在 m×n 的 Young 氏矩阵中。



## 第七章 快速排序

### 练习 7.1

> **7.1-1** 参照图 7-1 的方法，说明 PARTITION 在数组 $A = \langle 13, 19, 9, 5, 12, 8, 7, 4, 2, 6, 11 \rangle$ 上的操作过程。

7.1-2 当数组 $A[p..r]$ 中的元素都相同时，PARTITION 返回的 $q$ 值是什么？修改 PARTITION，使得当数组 $A[p..r]$ 中所有元素的值都相同时，$q = \lfloor(p+r)/2\rfloor$。

7.1-3 请简要地证明：在规模为 $n$ 的子数组上，PARTITION 的时间复杂度为 $\Theta(n)$。

7.1-4 如何修改 QUICKSORT，使得它能够以非递增序进行排序？

### 练习 7.2

7.2-1 利用代入读证明，正如 7.2 节开头提到的那样，递归约式 $T(x) = T(n-1) + \Theta(x)$ 的解为 $T(n) = \Theta(n^2)$。

7.2-2 当数组 A 的所有元素都具有相同值时，QUICKSORT 的时间复杂度是什么？

7.2-3 证明：当数组 A 包含的元素不同，并且是按降序排列的时候，QUICK90RT 的时间复杂度为 $\Theta(n^2)$。

7.2-4 银行一般会按照交易时间来记录某一账户的交易情况，但是，很多人却喜欢收到的银行对账单是按照支票号码的顺序来排列的。这是因为，人们通常都是按照支票号码的顺序来开出支票的。而商人也通常都是根据支票编号的顺序付支票。这一问题是将按交易时间排序的序列转换成按支票号排序的序列，它实质上是一个对几乎有序的输入序列进行排序的问题。请证明，在这个网上，INSERTION-SORT 的性能往往要优于 QUICKSORT。

7.2-5 一般设快速排序的每一层所做的划分的比例都是 $1-\alpha$，其中 $0 < \alpha \leq 1/8$ 且 $\alpha$ 是一个常数。试证明，在相应的归约树中，叶结点的最小深度大约是 $-k \log(1-\alpha)$，最大深度大约是 $-\log(\log(1-\alpha))$（无需考虑参数会入问题）。

*7.2-6 试证明，在一个随机输入数组上，对于任何常数 $0 < \alpha \leq 1/2$，PARTITION 产生比 $1-\alpha$ 更平衡的划分的概率约为 $1-2\alpha$。

### 练习 7.3

7.3-1 为什么我们分析随机化算法的期望运行时间，而不是其最坏运行时间呢？

7.3-2 在 RANDOMIZED-QUICKSORT 的运行过程中，在最坏情况下，随机数生成器 RANDOM 被调用了多少次？在最好情况下呢？以 $\Theta$ 符号的形式给出你的答案？

### 练习 7.4

7.4-1 证明：在递归约式
$$
T(n) = \max_{0 \leq \leq n-1} (T(q) + T(n-q-1)) + \Theta(n)
$$
中，$T(n) = \Omega(n^2)$。

7.4-2 证明：在最好情况下，快速排序的运行时间为 $\Omega(n \lg n)$。

7.4-3 证明：在 $q=0, 1, \cdots, n-1$ 区间内，当 $q=0$ 或 $q=n-1$ 时，$q^2 + (n-q-1)^2$ 取得最大值。

7.4-4 证明：RANDOMIZED-QUICKSORT 期望运行时间是 $\Omega(n \lg n)$。

7.4-5 当输入数据已经“几乎有序”时，插入排序速度很快。在实际应用中，我们可以利用这一特点来提高快速排序的速度。当对一个长度小于 $k$ 的子数组调用快速排序时，让它不做任何排序就返回。当上层的快速排序调用返回后，对整个数组运行插入排序来完成排序过程。试证明：这一排序算法的期望时间复杂度为 $O(nk + n \lg(n/k))$。分别从理论和实践的角度说明我们应该如何选择 $k$？

*7.4-6 考虑对 PARTITION 过程做这样的修改：从数组 A 中随机选出三个元素，并用这三个元素的中位数（即这三个元素按大小排在中间的值）对数组进行划分。求以 $\alpha$ 的函数形式表示的、最坏划分比例为 $\alpha : (1-\alpha)$ 的近似概率，其中 $0 < \alpha < 1$。



### 思考题

7-1 （Hoare 划分的正确性） 本章中的 PARTITION 算法并不是其最初的版本。下面给出的是最早由 C. R. Hoare 所设计的划分算法：

```c
HOARE-PARTITION(A, p, r)
    x = A[p]
    i = p - 1
    j = r + 1
    while TRUE
        repeat
            j = j - 1
        until A[j] <= x
        repeat
            i = i + 1
        until A[i] >= x
        if i < j
            exchange A[i] with A[j]
        else return j
```

a. 试说明 HOARE-PARTITION 在数组 $A = \{13, 19, 9, 5, 12, 8, 7, 4, 11, 2, 6, 21\}$ 上的操作过程，并说明在每一次执行第 4—13 行 while 循环时数组元素的值和辅助变量的值。

后续的三个问题要求读者仔细论证 HOARE-PARTITION 的正确性。在这里假设了数组 $A[p.. r]$ 至少包含来 2 个元素，试证明下列问题：
b. 下标 i 和 j 可以使我们不会访问在子数组 $A[p.. r]$ 以外的数组 A 的元素。
c. 当 HOARE-PARTITION 结束时，它返回的值 j 满足 $p \leq j < r$。
d. 当 HOARE-PARTITION 结束时，$A[p.. j]$ 中的每一个元素都小于或等于 $A[j+1.. r]$ 中的元素。

在 7.1 节的 PARTITION 过程中，主元 (原来存储在 $A[r]$ 中) 是与它所划分的两个分区分离的。与之对应，在 HOARE-PARTITION 中，主元 (原来存储在 $A[p]$ 中) 是存在于分区 $A[p.. j]$ 或 $A[j+1.. r]$ 中的。因为有 $p \leq j < r$，所以这一划分总是非平凡的。

e. 利用 HOARE-PARTITION，重写 QUICKSORT 算法。

7-2 （针对相同元素值的快速排序） 在 7.4.2 节对随机化快速排序的分析中，我们假设输入元素的值是互异的，在本题中，我们将看看如果这一假设不成立会出现什么情况。

a. 如果所有输入元素的值都相同，那么随机化快速排序的运行时间会是多少？
b. PARTITION 过程返回一个数组下标 q，使得 $A[p.. q-1]$ 中的每个元素都小于或等于 $A[q]$，而 $A[q+1.. r]$ 中的每个元素都大于 $A[q]$。修改 PARTITION 代码来构造一个新的 PARTITION'(A, p, r)，它排列 $A[p.. r]$ 的元素，返回值是两个数组下标 q 和 t，其中 $p \leq q \leq t \leq r$，且有
   - $A[q.. t]$ 中的所有元素都相等。
   - $A[p.. q-1]$ 中的每个元素都小于 $A[q]$。
   - $A[t+1.. r]$ 中的每个元素都大于 $A[q]$。
与 PARTITION 类似，新构造的 PARTITION' 的时间复杂度是 $\Theta(r - p)$。

c. 将 RANDOMIZED-QUICKSORT 过程改为调用 PARTITION，并重新命名为 RANDOMIZED-QUICKSORT'。修改 QUICKSORT 的代码构造一个新的 QUICKSORT*(A, p, r)，它调用 RANDOMIZED-PARTITION'，并且只有分区内的元素互不相同的时候才做递归调用。

d. 在 QUICKSORT* 中，应该如何改变 7.4.2 节中的分析方法，从而避免所有元素都是互异的这一假设？

7-3 （另一种快速排序的分析方法） 对随机化版本的快速排序算法，还有另一种性能分析方法，这一方法关注于每一次单独递归调用的期望运行时间，而不是比较的次数。

a. 证明：给定一个大小为 n 的数组，任何特定元素被选为主元的概率为 $1/n$。利用这一点来定义指示器随机变量 $X_i = I(\text{第 } i \text{ 小的元素被选为主元})$，$\mathbb{E}[X_i]$ 是什么？

b. 设 $T(n)$ 是一个表示快速排序在一个大小为 n 的数组上的运行时间的随机变量，试证明：
$$
\mathbb{E}[T(n)] = \mathbb{E}\left [\sum_{q = 1}^n X_q(T(q-1) + T(n-q) + \Theta(n))\right] \qquad (7.5)
$$

c. 证明公式 (7.5) 可以重写为：
$$
\mathbb{E}[T(n)] = \frac{2}{n} \sum_{q = 2}^{n-1} \mathbb{E}[T(q)] + \Theta(n) \qquad (7.6)
$$

d. 证明：
$$
\sum_{k = 2}^{n-1} k \lg k \leq \frac{1}{2} n^2 \lg n - \frac{1}{8} n^2 \qquad (7.7)
$$
（提示：可以将该累加式分成两个部分，一部分是 $k = 2, 3, \cdots, \lceil n/2 \rceil - 1$，另一部分是 $k = \lceil n/2 \rceil, \cdots, n-1$。）

e. 利用公式 (7.7) 中给出的界证明：公式 (7.6) 中的递归式有解 $\mathbb{E}[T(n)] = \Theta(n \lg n)$。（提示：使用代入法，证明对于某个正常数 a 和足够大的 n，有 $\mathbb{E}[T(n)] \leq a n \lg n$。）

7-4 （快速排序的栈深度） 7.1 节中的 QUICKSORT 算法包含了两个对其自身的递归调用。在调用 PARTITION 后，QUICKSORT 分别递归调用了左边的子数组和右边的子数组。QUICKSORT 中的第二个递归调用并不是必须。我们可以用一个循环控制结构来代替它。这一技术称为尾递归，好的编译器都提供这一功能。考虑下面这个版本的快速排序，它模拟了尾递归情况：

```c
TAIL-RECURSIVE-QUICKSORT(A, p, r)
	while p < r
    	// Partition and sort left subarray.
    	q = PARTITION(A, p, r)
    	TAIL-RECURSIVE-QUICKSORT(A, p, q-1)
    	p = q + 1
```

a. 证明：TAIL-RECURSIVE-QUICKSORT(A, 1, A.length) 能正确地对数组 A 进行排序。编译器通常使用栈来存储递归执行过程中的相关信息，包括每一次递归调用的参数等。最新调用的信息存在栈的顶部，而第一次调用的信息存在栈的底部。当一个过程被调用时，其相关信息被压入栈中；当它结束时，其信息则被弹出。因为我们假设数组参数是用指针来指示的，所以每次过程调用只需要 $O(1)$ 的栈空间。栈深度是在一次计算中会用到的栈空间的最大值。

b. 请描述一种场景，使得针对一个包含 n 个元素数组的 TAIL-RECURSIVE-QUICKSORT 的栈深度是 $\Theta(n)$。

c. 修改 TAIL-RECURSIVE-QUICKSORT 的代码，使其最坏情况下栈深度是 $\Theta(\lg n)$，并且能够保持 $O(n \lg n)$ 的期望时间复杂度。

7-5 （三数取中划分）一种改进 RANDOMIZED-QUICKSORT 的方法是在划分时，要从子数组中更细致地选择作为主元的元素（而不是简单地随机选择）。常用的做法是三数取中法：从子数组中随机选出三个元素，取其中位数作为主元（见练习 7.4-6）。对于这个问题的分析，我们不妨假设数组 $A[1.. n]$ 的元素是互异的且有 $n \geq 3$。我们用 $A'[1.. n]$ 来表示已排好序数组。用三数取中法选择主元 x，并定义 $p_i = \Pr\{x = A'[i]\}$。

a. 对于 $i = 2, 3, \cdots, n-1$，请给出以 n 和 i 表示的 $p_i$ 的准确表达式（注意 $p_1 = p_n = 0$）。

b. 与平凡实现相比，在这种实现中，选择 $x = A'[(n+1)/2]$（即 $A[1.. n]$ 的中位数）的值作为主元的概率增加了多少？假设 $n \rightarrow \infty$，请给出这一概率的极限值。

c. 如果我们定义一个“好”划分意味着主元选择 $x = A'[i]$，其中 $n/3 \leq i \leq 2n/3$。与平凡实现相比，这种实现中得到一个好划分的概率增加了多少？（提示：用积分来近似累加和。）

d. 证明：对快速排序而言，三数取中法只影响其时间复杂度 $\Omega(n \lg n)$ 的常数项因子。

7-6 （对区间的模糊排序）考虑这样的一种排序问题：我们无法准确知道待排序的数字是什么。但对于每一个数，我们知道它属于实数轴上的某个区间。也就是说，我们得到了 n 个形如 $[a_i, b_i]$ 的闭区间，其中 $a_i \leq b_i$。我们的目标是实现这些区间的模糊排序，即对 $j = 1, 2, \cdots, n$，生成一个区间的排列 $\langle i_1, i_2, \cdots, i_n \rangle$，且存在 $c_j \in [a_i, b_i]$，满足 $c_1 \leq c_2 \leq \cdots \leq c_n$。

a. 为 n 个区间的模糊排序设计一个随机算法。你的算法应该具有算法的一般结构，它可以对左边端点（即 $a_i$ 的值）进行快速排序，同时它也能利用区间的重叠性质来改善时间性能。（当区间重叠越来越多的时候，区间的模糊排序问题会变得越来越容易。你的算法应能充分利用这一重叠性质。）

b. 证明：在一般情况下，你的算法的期望运行时间为 $\Theta(n \lg n)$。但是，当所有的区间都有重叠的时候，算法的期望运行时间为 $\Theta(n)$（也就是说，存在一个值 x，对所有的 i，都有 $x \in [a_i, b_i]$。）你的算法不必显式地检查这种情况，而是随着重叠情况的增加，算法的性能自然地提高。





## 第八章 线性时间排序

### 练习 8.1

8.1-1 在一棵比较排序算法的决策树中，一个叶结点可能的最小深度是多少？

8.1-2 不用斯特林近似公式，给出 $\lg(n!)$ 的渐近紧确界。利用 A.2 节中介绍的技术来求累加和 $\sum_{k=1}^n \lg k$。

8.1-3 证明：对 $n!$ 种长度为 $n$ 的输入中的至少一半，不存在能达到线性运行时间的比较排序算法。如果只要求对 $1/n$ 的输入达到线性时间呢？$1/2^n$ 呢？

8.1-4 假设现有一个包含 $n$ 个元素的待排序序列。该序列由 $n/k$ 个子序列组成，每个子序列包含 $k$ 个元素。一个给定子序列中的每个元素都小于其后继子序列中的所有元素，且大于其前驱子序列中的每个元素。因此，对于这个长度为 $n$ 的序列的排序转化为对 $n/k$ 个子序列中的 $k$ 个元素的排序。试证明：这个排序问题中所需比较次数的下界是 $\Omega(n \lg k)$。（提示：简单地将每个子序列的下界进行合并是不严谨的。）

### 练习 8.2

8.2-1 参照图 8-2 的方法，说明 COUNTING-SORT 在数组 $A = \langle 6, 0, 2, 0, 1, 3, 4, 6, 1, 3, 2 \rangle$ 上的操作过程。

8.2-2 试证明 COUNTING-SORT 是稳定的。

8.2-3 假设我们在 COUNTING-SORT 的第 10 行循环的开始部分，将代码改写为：
```plaintext
10 for j = 1 to A.length
```

8.2-4 设计一个算法，它能够对于任何给定的介于 0 到 k 之间的 n 个整数先进行预处理，然后在 $O(1)$ 时间内回答输入的 n 个整数中有多少个落在区间 $[a..b]$ 内。你设计的算法的预处理时间应为 $\Theta(n + k)$。

### 练习 8.3

8.3-1 参照图 8-3 的方法，说明 RADIX-SORT 在下列英文单词上的操作过程：COW, DOG, SEA, RUG, ROW, MOB, BOX, TAB, BAR, EAR, TAR, DIG, BIG, TEA, NOW, FOX。

8.3-2 下面的排序算法中哪些是稳定的：插入排序、归并排序、堆排序和快速排序？给出一个能使任何排序算法都稳定的方法。你所给出的方法带来的额外时间和空间开销是多少？

8.3-3 利用归纳法来证明基数排序是正确的。在你所给出的证明中，在哪里需要假设所用的底层排序算法是稳定的？

8.3-4 说明如何在 $O(n)$ 时间内，对 0 到 $n^3 - 1$ 区间内的 n 个整数进行排序。

*8.3-5 在本节给出的第一个卡片排序算法中，为排序 d 位十进制数，在最坏情况下需要多少轮排序？在最坏情况下，操作员需要记录多少堆卡片？

### 练习 8.4

8.4-1 参照图 8-4 的方法，说明 BUCKET-SORT 在数组 $A = \langle 0.79, 0.13, 0.16, 0.64, 0.39, 0.20, 0.89, 0.53, 0.71, 0.42 \rangle$ 上的操作过程。

8.4-2 解释为什么桶排序在最坏情况下运行时间是 $\Theta(n^2)$？我们应该如何修改算法，使其在保持平均情况为线性时间代价的同时，最坏情况下时间代价为 $O(n \lg n)$？

8.4-3 设 X 是一个随机变量，用于表示在将一枚硬币抛掷两次时，正面朝上的次数。$E[X^2]$ 是多少呢？$E^2[X]$ 是多少呢？

*8.4-4 在单位圆内给定 n 个点，$p_i = (x_i, y_i)$，对所有 $i = 1, 2, \cdots, n$，有 $0 < x_i^2 + y_i^2 \leq 1$。假设所有的点服从均匀分布，即在单位元的任一区域内找到给定点的概率与该区域的面积成正比。请设计一个在平均情况下有 $\Theta(n)$ 时间代价的算法，它能够按照点到原点之间的距离 $d_i = \sqrt{x_i^2 + y_i^2}$ 对这 n 个点进行排序。（提示：在 BUCKET-SORT 中，设计适当的桶大小，用以反映各个点在单位圆中的均匀分布情况。）

*8.4-5 定义随机变量 X 的概率分布函数 $P(x)$ 为 $P(x) = \Pr\{X \leq x\}$。假设有 n 个随机变量 $X_1, X_2, \cdots, X_n$ 服从一个连续概率分布函数 P，且它可以在 $O(1)$ 时间内被计算得到。设计一个算法，使其能够在平均情况下在线性时间内完成这些数的排序。

### 思考题

8-1 （比较排序的概率下界） 在这一问题中，我们将证明对于给定的 n 个互异的输入元素，任何确定或随机的比较排序算法，其概率运行时间都有下界 $\Omega(n \lg n)$。首先来分析一个确定的比较排序算法 A，其决策树为 $T_A$。假设 A 的输入 A 给定一种排列情况都是等可能的。

a. 假设 $T_A$ 的每个叶结点都标有在给定的随机输入情况下到达该结点的概率。证明：恰有 $n!$ 个叶结点标有 $1/n!$，其他的叶结点标为 0。
b. 定义 $D(T)$ 表示一棵决策树 T 的外部路径长度，即 $D(T)$ 是 T 的所有叶结点深度的和。假设 T 为一棵有 $k>1$ 个叶结点的决策树，$LT$ 和 $RT$ 分别是 T 的左子树和右子树。证明：$D(T) = D(LT) + D(RT) + k$。
c. 定义 $d(k)$ 为所有具有 $k>1$ 个叶结点的决策树 T 的最小 $D(T)$ 值。证明：$d(k) = \min_{i+j=k-1} \{d(i) + d(j) + k\}$。（提示：考虑一棵能够取得该最小值的、有 k 个叶结点的决策树 T。设 $i_0$ 是 LT 中的叶结点数，$k-i_0$ 是 RT 中的叶结点数。）
d. 证明：$d$ 对于给定的 $k(k>1)$ 和 $i(1 \leq i \leq k-1)$，函数 $i \lg i + (k-i) \lg (k-i)$ 在 $i = k/2$ 处取得最小值，并有结论 $d(k) = \Omega(k \lg k)$。
e. 证明：$D(T_A) = \Omega(n! \lg(n!))$，并得出在平均情况下，排序 n 个元素的时间代价为 $\Omega(n \lg n)$ 这一结论。

f. 证明：对任何随机化比较排序算法 B，总存在一个确定的比较排序算法 A，其期望的比较次数不多于 B 的比较次数。

8-2 （线性时间原址排序） 假设有一个包含 n 个待排序数据记录的数组，且每条记录的关键字的值为 0 或 1。对这样一组记录进行排序的算法可能具备如下三种特性的一部分：

1. 算法的时间代价是 $O(n)$。
2. 算法是稳定的。
3. 算法是原址排序，除了输入数组之外，算法只需要固定的额外存储空间。
a. 给出一个满足上述条件 1 和条件 2 的算法。
b. 给出一个满足上述条件 2 和条件 3 的算法。
c. 给出一个满足上述条件 1 和条件 3 的算法。
d. 你设计的算法 (a)～(c) 中的任一个是否可以用于 RADIX-SORT 的第 2 行作为基础排序方法，从而使 RADIX-SORT 在排序有 b 位关键字的 n 条记录时的时间代价是 $O(bm)$？如果可以，请解释应如何处理；如果不行，请说明原因。
e. 假设有 n 条记录，其中所有关键字的值都在 1 到 k 的区间内。你应该如何修改计数排序，使得它可以在 $O(n + k)$ 时间内完成对 n 条记录的原址排序。（除输入数组外，你可以 $O(k)$ 使用大小为 k 的额外存储空间。你给出的算法是稳定的吗？（提示：当 $k = n^2$ 时，你应该怎么做？）

8-3 （变长数据项的排序）

a. 给定一个整数数组，其中不同的整数所包含的数字的位数可能不同，但该数组中，所有整数所包含的总数字位数为 n。设计一个算法，使其可以在 $O(n)$ 时间内对该数组进行排序。
b. 给定一个字符串数组，其中不同的字符串所包含的字符数可能不同，但所有字符串中的总字符个数为 n。设计一个算法，使其可以在 $O(n)$ 时间内对该数组进行排序。（注意：这些字符串可以按字典顺序进行排序。）

8-4 （水壶） 假设给了你 n 个红色的水壶和 n 个蓝色的水壶。它们的形状和尺寸都各不相同。所有的红色水壶中所盛的水都不一样多，蓝色水壶也是如此。而且，对于每一个红色水壶来说，都有一个对应的蓝色水壶，两者盛有一样多的水；反之亦然。

你的任务是找出所有的所盛水量一样多的红色水壶和蓝色水壶，并将它们配成一对。为此，可以执行如下操作：挑出一对水壶，其中一个是红色的，另一个是蓝色的，将红色水壶中倒满水，再将水倒入蓝色的水壶中。通过这一操作，可以判断出这个红色水壶是否比蓝色水壶盛的水更多，或者两者是一样多的。假设这样的比较需要花费一个单位时间。你的目标是找出一个算法，它能够用最少的比较次数来确定所有水壶的配对。注意，你不能直接比较两个红色或两个蓝色的水壶。
a. 设计一个确定性算法，它能够用 $\Theta(n^2)$ 次比较来完成所有水壶的配对。
b. 证明：解决该问题算法的比较次数下界为 $\Omega(n \lg n)$。
c. 设计一个随机算法，其期望的比较次数为 $O(n \lg n)$，并证明这个界是正确的。对你的算法来说，最坏情况下的比较次数是多少？
d. 设计一个随机算法，其期望的比较次数为 $O(n \lg n)$，并证明这个界是正确的。（提示：在 BUCKET-SORT 中，设计适当的桶大小，用以反映各个点在单位圆中的均匀分布情况。）

8-5 （平均排序） 假设我们不是要完全排序一个数组，而是要求数组中元素在平均情况下是“部分排序”的。更准确地说，如果对所有的 $i = 1, 2, \cdots, n-k$ 有下式成立，我们就称一个包含 n 个元素的数组 A 为 k 排序的 (k-sorted)：

$$\sum_{j=i}^{n-k} A[j] \leq \sum_{j=i+1}^{n-k+1} A[j]$$
a. 一个数组是 1 排序的，表示什么含义？
b. 给出对数字 1, 2, ..., 10 的一个排列，它是 2 排序的，但不是完全有序的。

c. 证明：一个包含 n 个元素的数组是 k 排序的，当且仅当对所有的 $i = 1, 2, \cdots, n-k$，有 $A[i] \leq A[i+k]$。
d. 设计一个算法，它能在 $O(\alpha(n/k))$ 时间内对一个包含 n 个元素的数组进行 k 排序。当 k 是一个常数时，也可以给出 k 排序算法的下界。
e. 证明：我们可以在 $O(n \lg k)$ 时间内对一个长度为 n 的 k 排序数组进行全排序。（提示：可以利用练习 6.5-9 的结果。）
f. 证明：当 k 是一个常数时，对包含 n 个元素的数组进行 k 排序需要 $\Omega(n \lg n)$ 的时间。（提示：可以利用前面解决比较排序下界的方法。）

8-6 （合并有序列表） 合并两个有序列表是我们经常会遇到的问题。作为 MERGE-SORT 的一个子过程，我们在 2.3.1 节中已经遇到过这一问题。对这一问题，我们证明在最坏情况下，合并两个都包含 n 个元素的有序列表的比较次数的下界是 $2n-1$。

首先，利用决策树来说明比较次数有一个下界 $2n-o(n)$。
a. 给定 2n 个数，计算出共有多少种可能的方式将它们划分成两个有序的列表，其中每个列表都包含 n 个数。
b. 利用决策树和 (a) 的答案，证明：任何能够正确合并两个有序列表的算法都至少要进行 $2n-o(n)$ 次比较。
c. 请给出一个更紧确界 $2n-1$。
d. 说明：如果两个元素在有序序列中是连续的，且它们分别来自不同的列表，则它们必须进行比较。
e. 利用你对上一部分的回答，说明合并两个有序列表时的比较次数下界为 $2n-1$。



8-7 (0-1 排序原理和交换排序)

针对两个数组元素 $A[i]$ 和 $A[j] (i < j)$ 的比较交换操作的形式如下：

```plaintext
COMPARE-EXCHANGE(A, i, j)
   if A[i] > A[j]
       exchange A[i] with A[j]
```

经过比较交换操作之后，我们得到 $A[i] \leq A[j]$。

遗忘比较交换算法是指算法只按照事先定义好的操作执行，即需要比较的位置下标必须事先确定好。虽然算法可能依靠待排序元素个数，但它不能依赖待排序元素的值，也不能依赖任何之前的比较交换操作的结果。例如，下面是一个基于遗忘比较交换算法的插入排序：

```plaintext
INSERTION-SORT (A)
   for j = 2 to A.length
       for i = j - 1 downto 1
           COMPARE-EXCHANGE(A, i, i + 1)
```

0-1 排序引理提供了有力的方法来证明一个遗忘比较交换算法可以产生正确的排序结果。该引理表明，如果一个遗忘比较交换算法能够对所有包含 0 和 1 的输入序列排序，那么它也包含任意值的输入序列排序。

你可以用反证法证明 0-1 排序引理。如果一个遗忘比较交换算法不能将一个包含任意值的序列进行排序，那么它也不能将 0-1 序列进行排序。不妨假设一个遗忘比较交换算法 X 未能对数组 A [1..n] 排序。设 A [p] 是算法 X 未能将其放到正确位置的最小的元素，而 A [q] 是被算法 X 放在 A [p] 原本应该在的位置上的一个元素。定义一个只包含 0 和 1 的数组 B [1..n] 如下：

$$
 B [i] = \begin{cases} 
0 & \text{若 } A [i] \leq A [p] \\
1 & \text{若 } A [i] > A [p]
\end{cases} 
$$
a. 讨论：当 \(A [q] > A [p]\) 时，有 \(B [p] = 0\) 和 \(B [q] = 1\)。

b. 为了完成 0-1 排序引理的证明，证明算法 X 不能对数组 B 正确地排序。

现在，需要用 0-1 排序引理来证明一个特别的排序算法的正确性。该排序算法是用于包含 n 个元素的矩形数组的排序。这一矩形数组有 r 行 s 列（因此 n = rs），满足下列三个限制条件：

- r 必须是偶数
- r ≥ 2s²

当列排序完成时，矩形数组是列优先有序的：按照列从上到下，从左到右，都是单调递增的。

如果不包括 n 的值的计算，列排序需要 8 步操作。所有奇数步都一样：对每一列单独进行排序。每一个偶数步是一个特定的排列。具体如下：

1. 对第一列进行排序。
2. 转置这个矩形数组，并重新规整化 r 行 s 列的形式，也就是说，首先将最左边的一列放在前 r/s 行，然后将下一列放在第二个 r/s 行，依此类推。
3. 对第一列进行排序。
4. 对每一列进行排序。
5. 重复第 2 步排列操作的逆操作。
6. 将每一列的上半部分移到下一列的下半部分位置，将每一列的下半部分移到下一列的上半部分，并将最左边一列的上半部分置为空。此时，最后一列的下半部分成为新的最右列的上半部分，新的最右列的下半部分为空。
7. 对第一列进行排序。
8. 执行第 6 步排列操作的逆操作。

图 8-5 显示了一个在 r = 6 和 s = 3 时的列排序步骤（即使这个例子违背了 r ≥ 2s² 的条件，列排序仍然有效）。

![图 8-5](F:\software\Typora\images\image-20250117122735447.png)

图 8-5 列排序的步骤。(a)6 行 3 列的输入数组。(b)第 1 步排序操作之后的情况。(c)第 2 步转置和规整化后的情况。(d)第 3 步排序操作之后的情况。(e)执行完第 4 步的情况，即反转第 2 步排列操作。(f)第 5 步排序操作之后的情况。(g)第 6 步移动后的情况。(h)第 7 步排序操作之后的情况。(i)执行完第 8 步的情况，即反转第 6 步排列操作。现在数组已经是列优先有序了。



c. 讨论，即使不知道奇数步与偶数步，我们也可以把所有排序看做一种遗忘比较交换算法。

第二部分 排序和顺序统计量

虽然似乎很难让人相信排序也能发现排序，但是你可以用 0-1 排序引理来证明这一点。因为列排序可以看做是一种遗忘比较交换算法，所以我们可以使用 0-1 排序引理来证明列排序的正确性。下面一些定义有助于你使用这一引理。如果数组中的某个区域只包含 0 或者全 1，我们定义这个区域是干净的。否则，如果某个区域包含 0 和 1 的混合，则称这个区域是脏的。这里，假设输入数据只包含 0 和 1，且输入数据能够被转换为 0-1 形式。

d. 证明：经过第 1～3 步，数组由三部分组成：底部一些由全 0 组成的干净行，底部一些全 1 组成的干净行，以及中间最多 r 行脏的行。

e. 证明：经过第 4 步后，如果按照列优先原则读取数组，先读到的是全 0 的干净区域，最后是全 1 的干净区域，中间是由最多 s² 个元素组成的脏区域。

f. 证明：第 5～8 步产生一个全排列的 0-1 输出，并得到结论：列排序可以正确地对任意输入数组进行排序。

g. 现在假设 x 不能被 r 整除。证明：经过第 1～3 步，数组的顶部有一些全 0 的行，底部有一些全 1 的行，中间是最多 r/s 行脏行。那么与 g 相比，在 x 不能被 r 整除时，r 至少有多大才能保证列排序的正确性？

h. 对第 1 步做一个简单修改，使得我们可以 r 不能被 r 整除时，也保证 r ≥ 2s²，并证明在这一修改后，列排序仍然正确。









## 第九章 中位数和顺序统计量

### 练习 9.1

9.1-1 证明：在最坏情况下，找到 $n$ 个元素中第二小的元素需要 $n + \lceil \lg n \rceil - 2$ 次比较。（提示：可以同时找最小元素。）

*9.1-2 证明：在最坏情况下，同时找到 $n$ 个元素中最大值和最小值的比较次数的下界是 $\lceil 3n/2 \rceil - 2$。（提示：考虑有多少个数有成为最大值或最小值的潜在可能，然后分析一下每一次比较会如何影响这些计数。）

### 练习 9.2

9.2-1 证明：在 RANDOMIZED-SELECT 中，对长度为 0 的数组，不会进行递归调用。

9.2-2 请讨论：指示器随机变量 $$X_k$$ 和 $$T(\max(k-1, n-k))$$ 是独立的。

9.2-3 给出 RANDOMIZED-SELECT 的一个基于循环的版本。

9.2-4 假设用 RANDOMIZED-SELECT 去选择数组 $$A=\langle 3, 2, 9, 0, 7, 5, 4, 8, 6, 1 \rangle$$ 的最小元素，给出能够导致 RANDOMIZED-SELECT 最坏情况发生的一个划分序列。

### 练习 9.3

9.3-1 在算法 SELECT 中，输入元素被分为每组 5 个元素。如果它们被分为每组 7 个元素，该算法仍然会是线性时间吗？证明：如果分成每组 3 个元素，SELECT 的运行时间不是线性的。

9.3-2 分析 SELECT，并证明：如果 $$n \geqslant 140$$，则至少 $$\lceil n/4 \rceil$$ 个元素大于中位数的中位数 $$x$$，至少 $$\lceil n/4 \rceil$$ 个元素小于 $$x$$？

9.3-3 假设所有元素都是互异的，说明在最坏情况下，如何才能使快速排序的运行时间为 $$O(n\lg n)$$。

*9.3-4 对一个包含 $$n$$ 个元素的集合，假设一个算法只使用比较来确定第 $$i$$ 小的元素，证明：无需额外的比较操作，它也能找到第 $$i-1$$ 小的元素和第 $$n-i$$ 大的元素。

9.3-5 假设你已经有了一个最坏情况下是线性时间的用于求解中位数的“黑箱”子程序。设计一个能在线性时间内解决任意顺序统计量的选择问题算法。

9.3-6 对一个包含 $$n$$ 个元素的集合来说，$$k$$ 分位数是指能把有序集合分成 $$k$$ 个等大小集合的第 $$k-1$$ 个顺序统计量。给出一个能找出某一集合的 $$k$$ 分位数的 $$O(n \lg k)$$ 时间的算法。

9.3-7 设计一个 $$O(n)$$ 时间的算法，对于一个给定的包含 $$n$$ 个互异元素的集合 $$S$$ 和一个正整数 $$k \leqslant n$$，该算法能够确定 $$S$$ 中最接近中位数的 $$k$$ 个元素。

9.3-8 设 $$X[1..n]$$ 和 $$Y[1..n]$$ 为两个数组，每个都包含 $$n$$ 个有序的元素。请设计一个 $$O(\lg n)$$ 时间的算法来找出数组 $$X$$ 和 $$Y$$ 中所有 $$2n$$ 个元素的中位数。

9.3-9 Olay 教授是一家石油公司的顾问。这家公司正在计划建造一条从东向西的大型输油管道，这一管道将穿越一个有 $$n$$ 口油井的油田。公司希望有一条管道支线沿着最短路径从每口油井连接到主管道（方向或南或北），如图 9-2 所示。给定每口油井的 $$x$$ 和 $$y$$ 坐标，教授应该如何选择主管道的最优位置，使得各直线的总长度最小？证明：该最优位置可以在线性时间内确定。

![图 9.2](F:\software\Typora\images\image-20250117124018628.png)

图 9-2 Olay 教授需要确定东西向石油管道的位置，使得南北向的支线管道的总长度最小



### 思考题

9-1（有序序列中的 i 个最大数）给定一个包含 $$n$$ 个元素的集合，我们希望利用基于比较的算法找出按顺序排列的前 $$i$$ 个最大元素。请设计能实现下列每一项要求，并且具有最佳渐近最坏情况运行时间的算法，以 $$n$$ 和 $$i$$ 来表示算法的运行时间：

a. 对输入数据排序，并找出前 $$i$$ 个最大数。

b. 对输入数据建立一个最大优先队列，并调用 EXTRACT-MAX 过程 $$i$$ 次。

c. 利用一个顺序统计量算法来找到第 $$i$$ 大的元素，然后用它作为主元划分输入数组，再对前 $$i$$ 大的数排序。

9-2（带权中位数）对分别具有正权重 $$w_1, w_2, \cdots, w_n$$，且满足 $$\sum_{i=1}^{n} w_i = 1$$ 的 $$n$$ 个互异元素 $$x_1, x_2, \cdots, x_n$$ 来说，带权中位数 $$x_i$$（较小中位数）是满足如下条件的元素：

$$
\sum_{x_j < x_i} w_j < \frac{1}{2}
$$

和

$$
\sum_{x_j > x_i} w_j \leq \frac{1}{2}
$$

例如，如果元素是 0.1, 0.35, 0.05, 0.1, 0.15, 0.05, 0.2，并且每个元素的权重等于本身（即对所有 $$i = 1, 2, \cdots, 7$$，都有 $$w_i = x_i$$），那么中位数是 0.1，而带权中位数是 0.2。

a. 证明：如果对所有 $$i = 1, 2, \cdots, n$$ 都有 $$w_i = 1/n$$，那么 $$x_1, x_2, \cdots, x_n$$ 的中位数就是 $$x_i$$ 的带权中位数。

b. 利用排序，设计一个最坏情况下 $$O(n \lg n)$$ 时间的算法，可以得到 $$n$$ 个元素的带权中位数。

c. 说明如何利用像 9.3 节的 SELECT 这样的线性时间中位数算法，在 $$\Theta(n)$$ 最坏情况时间内求出带权中位数。

邮局位置问题的定义如下：给定权重分别为 $$w_1, w_2, \cdots, w_n$$ 的 $$n$$ 个点 $$p_1, p_2, \cdots, p_n$$，我们希望找到一个点 $$p$$（不一定是输入点中的一个），使得 $$\sum_{i=1}^{n} w_i d(p, p_i)$$ 最小，这里 $$d(a, b)$$ 表示点 $$a$$ 与 $$b$$ 之间的距离。

d. 证明：对一维邮局位置问题，带权中位数是最好的解决方法，其中，每个点都是一个实数，点 $$a$$ 与 $$b$$ 之间的距离是 $$d(a, b) = |a - b|$$。

e. 请给出二维邮局位置问题的最好解决方法：其中的点是 $$(x, y)$$ 的二维坐标形式，点 $$a = (x_1, y_1)$$ 与 $$b = (x_2, y_2)$$ 之间的距离是 Manhattan 距离，即 $$d(a, b) = |x_1 - x_2| + |y_1 - y_2|$$。

9-3（小顺序统计量）要在 $$n$$ 个数中选出第 $$i$$ 个顺序统计量，SELECT 在最坏情况下需要的比较次数 $$T(n)$$ 满足 $$T(n) = \Theta(n)$$。但是，隐含在 $$\Theta$$ 记号中的常数项是非常大的。当 $$i$$ 相对 $$n$$ 来说很小时，我们可以实现一个不同的算法，它以 SELECT 作为子程序，但在最坏情况下所做的比较次数更少。

a. 设计一个能用 $$U_i(n)$$ 次比较在 $$n$$ 个元素中找出第 $$i$$ 小元素的算法，其中，

$$
U_i(n) = \begin{cases} 
T(n) & \text{若 } i \geq n/2 \\
\lfloor n/2 \rfloor + U_i(\lceil n/2 \rceil) + T(2i) & \text{其他}
\end{cases}
$$

(提示：从 $$\lfloor n/2 \rfloor$$ 个不相交对的两两比较开始，然后对由每对中的较小元素构成的集合进行递归。)

b. 证明：如果 $$i < n/2$$，则有 $$U_i(n) = n + O(T(2i) \lg(n/i))$$。

c. 证明：如果 $$i$$ 是小于 $$n/2$$ 的常数，则有 $$U_i(n) = n + O(\lg n)$$。

d. 证明：如果对所有 $$k \geq 2$$ 有 $$i = n/k$$，则 $$U_i(n) = n + O(T(2n/k) \lg k)$$。

9-4（随机选择的另一种分析方法）在这个问题中，我们用指示器随机变量来分析 RANDOMIZED-SELECT，这一方法类似于 7.4.2 节中所用的对 RANDOMIZED-QUICKSORT 的分析方法。

与快速排序中的分析一样，我们假设所有的元素都是互异的，输入数组 A 的元素被重命名为 $$z_1, z_2, \cdots, z_n$$，其中 $$z_i$$ 是第 $$i$$ 小的元素。因此，调用 RANDOMIZED-SELECT(A, 1, n, k) 返回 $$z_k$$。

对所有 $$1 \leq i < j \leq n$$，设

$$
X_{ij} = I\{\text{在执行算法查找 } z_k \text{ 期间，} z_i \text{ 与 } z_j \text{ 进行过比较}\}
$$

a. 给出 $$E[X_{ij}]$$ 的准确表达式。（提示：你的表达式可能有不同的值，依赖于 $$i, j, k$$ 的值。）

b. 设 $$X_i$$ 表示在找到 $$z_i$$ 时 A 中元素的总比较次数，证明：

$$
E [X_i] \leq 2\left(\sum_{i = 1}^{k-1}\sum_{j = i+1}^{k} + \sum_{j = k+1}^{n}\frac{i-k-1}{j-k+1} + \sum_{i = k+1}^{n}\frac{k-i-1}{k-i+1}\right)
$$

c. 证明：$$E[X_i] \leq 4n$$。

d. 假设 A 中的元素都是互异的，证明：RANDOMIZED-SELECT 的期望运行时间是 $$O(n)$$。









































































































































































































































































































