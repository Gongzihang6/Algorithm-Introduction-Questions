# 第三部分 数据结构

## 第十章 基本数据结构

### 练习 10.1

10.1-1 仿照图 10-1，画图表示依次执行操作 $$PUSH(S,4)$$、$$PUSH(S,1)$$、$$PUSH(S,3)$$、$$POP(S)$$、$$PUSH(S,8)$$ 和 $$POP(S)$$ 每一步的结果，栈 $$S$$ 初始为空，存储于数组 $$S[1..6]$$ 中。

10.1-2 说明如何在一个数组 $$A[1..n]$$ 中实现两个栈，使得当两个栈的元素个数之和不为 $$n$$ 时，两者都不会发生上溢。要求 $$PUSH$$ 和 $$POP$$ 操作的运行时间为 $$O(1)$$。

10.1-3 仿照图 10-2，画图表示依次执行操作 $$ENQUEUE(Q,4)$$、$$ENQUEUE(Q,1)$$、$$ENQUEUE(Q,3)$$、$$DEQUEUE(Q)$$、$$ENQUEUE(Q,8)$$ 和 $$DEQUEUE(Q)$$ 每一步的结果，队列初始为空，存储于数组 $$Q[1..6]$$ 中。

10.1-4 重写 $$ENQUEUE$$ 和 $$DEQUEUE$$ 的代码，使之能处理队列的下溢和上溢。

10.1-5 栈插入和删除元素只能在同一端进行，队列的插入操作和删除操作分别在两端进行，与它们不同的，有一种双端队列 (deque)，其插入和删除操作都可以在两端进行。写出 4 个时间均为 $$O(1)$$ 的过程，分别实现在双端队列的两端插入和删除元素的操作，该队列是用一个数组实现的。

10.1-6 说明如何用两个栈实现一个队列，并分析相关队列操作的运行时间。

10.1-7 说明如何用两个队列实现一个栈，并分析相关栈操作的运行时间。

### 练习 10.2

10.2-1 单链表上的动态集合操作 $$INSERT$$ 能否在 $$O(1)$$ 时间内实现？$$DELETE$$ 操作呢？

10.2-2 用一个单链表 $$L$$ 实现一个栈。要求操作 $$PUSH$$ 和 $$POP$$ 的运行时间仍为 $$O(1)$$。

10.2-3 用一个单链表 $$L$$ 实现一个队列。要求操作 $$ENQUEUE$$ 和 $$DEQUEUE$$ 的运行时间仍为 $$O(1)$$。

10.2-4 如前所述，$$LIST\text{-}SEARCH'$$ 过程中的每一次循环迭代都需要两个测试：一是检查 $$x \neq L.nil$$，另一个是检查 $$x.key \neq k$$。试说明如何在每次迭代中省略对 $$x \neq L.nil$$ 的检查。

10.2-5 使用单向循环链表实现字典操作 $$INSERT$$、$$DELETE$$ 和 $$SEARCH$$，并给出所写过程的运行时间。

10.2-6 动态集合操作 $$UNION$$ 以两个不相交的集合 $$S_1$$ 和 $$S_2$$ 作为输入，并返回集合 $$S = S_1 \cup S_2$$，包含 $$S_1$$ 和 $$S_2$$ 的所有元素。该操作通常会破坏集合 $$S_1$$ 和 $$S_2$$。试说明如何选用一种合适的表类数据结构，来支持 $$O(1)$$ 时间的 $$UNION$$ 操作。

10.2-7 给出一个 $$\Theta(n)$$ 时间的非递归过程，实现对一个含 $$n$$ 个元素的单链表的逆转。要求除存储链表本身所需的空间外，该过程只能使用固定大小的存储空间。

*10.2-8 说明如何在每个元素仅使用一个指针 $$x.np$$（而不是通常的两个指针 $$next$$ 和 $$prev$$）的情况下实现双向链表。假设所有指针的值都可视为 $$k$$ 位的整型数，且定义 $$x.np = x.next \oplus x.prev$$，即 $$x.next$$ 和 $$x.prev$$ 的 $$k$$ 位异或。（NIL 的值用 0 表示。）注意要说明获取表头所需的信息，并说明如何在该表上实现 $$SEARCH$$、$$INSERT$$ 和 $$DELETE$$ 操作，以及如何在 $$O(1)$$ 时间内实现该表的逆转。

### 练习 10.3

10.3-1 画图表示序列 (13, 4, 8, 19, 5, 11)，其存储形式为多数组表示的双向链表。同样画出单数组表示的形式。

10.3-2 对一组同构对象用单数组表示法实现，写出过程 $$ALLOCATE\text{-}OBJECT$$ 和 $$FREE\text{-}OBJECT$$。

10.3-3 在 $$ALLOCATE\text{-}OBJECT$$ 和 $$FREE\text{-}OBJECT$$ 过程的实现中，为什么不需要设置或重置对象的 $$prev$$ 属性呢？

10.3-4 我们往往希望双向链表的所有元素在存储器中保持紧凑，例如，在多数组表示中占用前 $$m$$ 个下标位置。（在页式虚拟存储的计算环境下，即为这种情况。）假设除指向链表本身的指针外没有其他指针指向该链表的元素，试说明如何实现过程 $$ALLOCATE\text{-}OBJECT$$ 和 $$FREE\text{-}OBJECT$$，使得该表示保持紧凑。（提示：使用栈的数组实现。）

10.3-5 设 $$L$$ 是一个长度为 $$n$$ 的双向链表，存储于长度为 $$m$$ 的数组 $$key$$、$$prev$$ 和 $$next$$ 中。假设这些数组由维护双链自由表 $$F$$ 的两个过程 $$ALLOCATE\text{-}OBJECT$$ 和 $$FREE\text{-}OBJECT$$ 进行管理。又假设 $$m$$ 个元素中，恰有 $$n$$ 个元素在链表 $$L$$ 上，$$m-n$$ 个在自由表上。给定链表 $$L$$ 和自由表 $$F$$，试写出一个过程 $$COMPACTIFY\text{-}LIST(L, F)$$，用来移动 $$L$$ 中的元素使其占用数组中 1, 2, …, $$n$$ 的位置，调整自由表 $$F$$ 以保持其正确性，并且占用数组中 $$n+1$$, $$n+2$$, …, $$m$$ 的位置。要求所写的过程运行时间应为 $$\Theta(n)$$，且只使用固定量的额外存储空间。请证明所写的过程是正确的。

### 练习 10.4

10.4-1 画出下列属性表所示的二叉树，其根结点下标为 6。

| 下标 | key  | left | right |
| :--: | :--: | :--: | :---: |
|  1   |  12  |  7   |   3   |
|  2   |  15  |  8   |  NIL  |
|  3   |  4   |  10  |  NIL  |
|  4   |  10  |  5   |   9   |
|  5   |  2   | NIL  |  NIL  |
|  6   |  18  |  1   |   4   |
|  7   |  7   | NIL  |  NIL  |
|  8   |  14  |  6   |   2   |
|  9   |  21  | NIL  |  NIL  |
|  10  |  5   | NIL  |  NIL  |

10.4-2 给定一个 $$n$$ 结点的二叉树，写出一个 $$O(n)$$ 时间的递归过程，将该树每个结点的关键字输出。

10.4-3 给定一个 $$n$$ 结点的二叉树，写出一个 $$O(n)$$ 时间的非递归过程，将该树每个结点的关键字输出。可以使用一个栈作为辅助数据结构。

10.4-4 对于一个含 $$n$$ 个结点的任意有根树，写出一个 $$O(n)$$ 时间的过程，输出其所有关键字。该树以左孩子右兄弟表示法存储。

*10.4-5 给定一个 $$n$$ 结点的二叉树，写出一个 $$O(n)$$ 时间的非递归过程，将该树每个结点的关键字输出。要求除该树本身的存储空间外只能使用固定量的额外存储空间，且在过程中不得修改该树，即使是暂时的修改也不允许。

*10.4-6 任意有根树的左孩子右兄弟表示法中每个结点用到三个指针：$$left\text{-}child$$、$$right\text{-}sibling$$ 和 $$parent$$。对于任何结点，都可以在常数时间到达其父结点，并在与其孩子数呈线性关系的时间内到达所有孩子结点。说明如何在每个结点中只使用两个指针和一个布尔值的情况下，使结点的父结点或者其所有孩子结点可以在与其孩子数呈线性关系的时间内到达。

### 思考题

10-1（链表间的比较）对于下表中的 4 种链表，所列的每种动态集合操作在最坏情况下的渐近运行时间是多少？

| 操作                  | 未排序的单链表 | 已排序的单链表 | 未排序的双向链表 | 已排序的双向链表 |
| --------------------- | -------------- | -------------- | ---------------- | ---------------- |
| $$SEARCH(L, k)$$      |                |                |                  |                  |
| $$INSERT(L, x)$$      |                |                |                  |                  |
| $$DELETE(L, x)$$      |                |                |                  |                  |
| $$SUCCESSOR(L, x)$$   |                |                |                  |                  |
| $$PREDECESSOR(L, x)$$ |                |                |                  |                  |
| $$MINIMUM(L)$$        |                |                |                  |                  |
| $$MAXIMUM(L)$$        |                |                |                  |                  |

10-2（利用链表实现可合并堆）可合并堆 (mergeable heap) 支持以下操作：$$MAKE\text{-}HEAP$$（创建一个空的可合并堆）、$$INSERT$$、$$MINIMUM$$、$$EXTRACT\text{-}MIN$$ 和 $$UNION$$。说明在下列前提下如何用链表实现可合并堆。试着使各操作尽可能高效。分析每个操作按动态集合规模的运行时间。

a. 链表是已排序的。

b. 链表是未排序的。

c. 链表是未排序的，且待合并的动态集合是不相交的。

10-3（搜索已排序的紧凑链表）练习 10.3-4 讨论了如何将含 $$n$$ 个元素的链表紧凑地维持在数组的前 $$n$$ 个位置。假设所有的关键字均不相同，且紧凑链表是已排序的，即对所有的 $$i = 1, 2, \ldots, n$$ 且 $$next[i] \neq NIL$$，有 $$key[i] < key[next[i]]$$。又假设有一个变量 $$L$$ 存放链表的首元素的下标。在这些假设下，试说明可以利用下列随机算法在 $$O(\sqrt{n})$$ 的期望时间内搜索链表。

```c
COMPACT-LIST-SEARCH(L, n, k) 
    while i ≠ NIL and key[i] < k
        j = RANDOM(1, n)
        if key[i] < key[j] and key[j] ≤ k
            i = j
        if key[i] == k
            return i
        i = next[i]
    if i == NIL or key[i] > k
        return NIL
    else return i
```

由于我们已经定义了一个支持 MINIMUM 和 EXTRACT-MIN 操作的可合并堆，我们也可以将它视为一个可合并最小堆。再者，如果这个堆支持 MAXIMUM 和 EXTRACT-MAX 操作，就是一个可合并最大堆。

如果忽略过程中第 3～7 行，就得到一个普通的搜索已排序链表的算法，其中下标 $$i$$ 依次指向链表的各个位置。当下标 $$i$$ 越出表的末端或 $$key[i] \geq k$$ 时，搜索终止。在后一种情况中，如果 $$key[i] = k$$，显然，我们已找到值为 $$k$$ 的关键字。但如果 $$key[i] > k$$，则我们永远也找不到值为 $$k$$ 的关键字，因而终止查找是正确的。

第 3～7 行意图向前跳至某个随机选择的位置 $$j$$。当 $$key[j]$$ 大于 $$key[i]$$ 而不大于 $$k$$ 时，这种跳跃是有益的。因为这种情况下，$$j$$ 在链表中标识了一个正常搜索中 $$i$$ 将要到达的位置。由于该链表是紧凑的，所以在 1 到 $$n$$ 中任意选择一个 $$j$$ 都会指向链表中的某个对象，而不会是自由表中的某个位置。

我们不直接分析 COMPACT-LIST-SEARCH 的性能，而是要分析一个相关的算法 COMPACT-LIST-SEARCH'，该算法执行两个独立的循环。该算法增加了一个参数 $$t$$，用来决定第一个循环迭代次数的上限。

```plaintext
COMPACT-LIST-SEARCH'(L, n, k, t)
    i = L
    for q = 1 to t
        j = RANDOM(1, n)
        if key[i] < key[j] and key[j] <= k
            i = j
        if key[i] == k
            return i
    while i ≠ NIL and key[i] < k
        i = next[i]
    if i == NIL or key[i] > k
        return NIL
    else return i
```

为了比较算法 COMPACT-LIST-SEARCH($$L, n, k$$) 和 COMPACT-LIST-SEARCH'($$L, n, k, t$$) 的执行过程，假定调用 RANDOM(1, n) 所返回的整数序列在两个算法中是一样的。

a. 假设 COMPACT-LIST-SEARCH($$L, n, k$$) 中第 2～8 行的 while 循环经过了 $$t$$ 次迭代。论证 COMPACT-LIST-SEARCH'($$L, n, k, t$$) 会返回同样的结果，且 COMPACT-LIST-SEARCH' 中的 for 循环和 while 循环的迭代次数之和至少为 $$t$$。

在 COMPACT-LIST-SEARCH'($$L, n, k, t$$) 的调用中，设随机变量 $$X_q$$ 描述了第 2～7 行的 for 循环经 $$t$$ 次迭代后链表中从位置 $$i$$ 到目标关键字 $$k$$ 之间的距离（即通过 next 指针链）。

b. 论证 COMPACT-LIST-SEARCH'($$L, n, k, t$$) 的期望运行时间为 $$O(t + E[X_t])$$。

c. 证明：$$E[X_i] \leq \sum_{i=1}^{\infty}(1 - r/n)^i$$。（提示：利用等式 (C.25)。）

d. 证明：$$\sum_{t=0}^{n} r^t \leq n^{1 + t}/(t + 1)$$。

e. 证明：$$E[X_t] \leq n/(t + 1)$$。

f. 证明：COMPACT-LIST-SEARCH'($$L, n, k, t$$) 的期望运行时间为 $$O(t + n/t)$$。

g. 证明：COMPACT-LIST-SEARCH 的期望运行时间为 $$O(\sqrt{n})$$。

h. 为什么要假设 COMPACT-LIST-SEARCH 中的所有关键字均不相同？论证当链表中包含重复的关键字时，随机跳跃不一定能降低渐近时间。



## 第十一章 散列表

### 练习 11.1

11.1-1 假设一动态集合 $$S$$ 用一个长度为 $$m$$ 的直接寻址表 $$T$$ 来表示。请给出一个查找 $$S$$ 中最大元素的过程。你所给的过程在最坏情况下的运行时间是多少？

11.1-2 位向量 (bit vector) 是一个仅包含 0 和 1 的数组。长度为 $$m$$ 的位向量所占空间要比包含 $$m$$ 个指针的数组少得多。请说明如何用一个位向量来表示一个包含不同元素（无卫星数据）的动态集合。字典操作的运行时间应为 $$O(1)$$。

11.1-3 试说明如何实现一个直接寻址表，表中各元素的关键字不必都不相同，且各元素可以有卫星数据。所有三种字典操作 ($$INSERT$$、$$DELETE$$ 和 $$SEARCH$$) 的运行时间应为 $$O(1)$$。（不要忘记 $$DELETE$$ 要处理的是被删除对象的指针变量，而不是关键字。）

*11.1-4 我们希望在一个非常大的数组上，通过利用直接寻址的方式来实现一个字典。开始时，该数组中可能包含一些无用信息，但要对整个数组进行初始化是不太实际的，因为该数组的规模太大。请给出在大数组上实现直接寻址字典的方案。每个存储对象占用 $$O(1)$$ 空间；$$SEARCH$$、$$INSERT$$ 和 $$DELETE$$ 操作的时间均为 $$O(1)$$；并且对数据结构初始化的时间为 $$O(1)$$。（提示：可以利用一个附加数组，处理方式类似于栈，其大小等于实际存储在字典中的关键字数目，以帮助确定大数组中某个给定的项是否有效。）

### 练习 11.2

11.2-1 假设用一个散列函数 $$h$$ 将 $$n$$ 个不同的关键字散列到一个长度为 $$m$$ 的数组 $$T$$ 中。假设采用的是简单均匀散列，那么期望的冲突数是多少？更准确地，集合 $$\{(k, l): k \neq l, \text{ 且 } h(k) = h(l)\}$$ 基的期望值是多少？

11.2-2 对于一个用链接法解决冲突的散列表，说明将关键字 5, 28, 19, 15, 20, 33, 12, 17, 10 插入到该表中的过程。设该表中有 9 个槽位，并设其散列函数为 $$h(k) = k \mod 9$$。

11.2-3 Marley 教授做了这样一个假设，即如果将链模式改动一下，使得每个链表都能保持已排好序的顺序，散列的性能就可以有较大的提高。Marley 教授的改动对成功查找、不成功查找、插入和删除操作的运行时间有何影响？

11.2-4 说明在散列表内部，如何通过将所有未占用的槽位链接成一个自由链表，来分配和释放元素所占的存储空间。假定一个槽位可以存储一个标志、一个元素加上一个或两个指针。所有的字典和自由链表操作均应具有 $$O(1)$$ 的期望运行时间。该自由链表需要是双向链表吗？或者，是不是单链表就足够了呢？

11.2-5 假设将一个具有 $$n$$ 个关键字的集合存储到一个大小为 $$m$$ 的散列表中。试说明如果这些关键字均源于全域 $$U$$，且 $$|U| > nm$$，则 $$U$$ 中还有一个大小为 $$n$$ 的子集，其由散列到同一槽位中的所有关键字构成，使得链接法散列的查找时间最坏情况下为 $$\Theta(n)$$。

11.2-6 假设将 $$n$$ 个关键字存储到一个大小为 $$m$$ 且通过链接法解决冲突的散列表中，同时已知每条链的长度，包括其中最长链的长度 $$L$$，请描述从散列表的所有关键字中均匀随机地选择某一元素并在 $$O(L \cdot (1 + 1/\alpha))$$ 的期望时间内返回该关键字的过程。

### 练习 11.3

11.3-1 假设我们希望查找一个长度为 $$n$$ 的链表，其中每一个元素都包含一个关键字 $$k$$ 并具有散列值 $$h(k)$$。每一个关键字都是长字符串。那么在表中查找具有给定关键字的元素时，如何利用各元素的散列值呢？

11.3-2 假设将一个长度为 $$r$$ 的字符串散列到 $$m$$ 个槽中，并将其视为一个以 128 为基数的数，要求应用除法散列法。我们可以很容易地把数 $$m$$ 表示为一个 32 位的机器字，但对长度为 $$r$$ 的字符串，由于它被当做以 128 为基数的数来处理，就要占用若干个机器字。假设应用除法散列法来计算一个字符串的散列值，那么如何才能在除了该串本身占用的空间外，只利用常数个机器字？

11.3-3 考虑除法散列法的另一种版本，其中 $$h(k) = k \mod m, m = 2^p - 1$$，$$k$$ 为按基数 $$2^p$$ 表示的字符串。试证明：如果串 $$x$$ 可由串 $$y$$ 通过其自身的字符置换排列导出，则 $$x$$ 和 $$y$$ 具有相同的散列值。给出一个应用的例子，其中这一特性在散列函数中是不希望出现的。

11.3-4 考虑一个大小为 $$m = 1000$$ 的散列表和一个对应的散列函数 $$h(k) = \lfloor m(kA \mod 1) \rfloor$$，其中 $$A = (\sqrt{5} - 1) / 2$$，试计算关键字 61、62、63、64 和 65 被映射到的位置。

*11.3-5 定义一个从有限集合 $$U$$ 到有限集合 $$B$$ 上的散列函数簇 $$\mathcal{H}$$ 为 $$\varepsilon$$ 全域的，如果对 $$U$$ 中所有的不同元素对 $$k$ 和 $$ l$$，都有

$$
\operatorname{Pr}\{h(k) = h(l)\} \leqslant \varepsilon
$$

其中概率是相对从函数簇 $$\mathscr{H}$$ 中随机抽取的散列函数 $$h$$ 而言的。试证明：一个 $$\varepsilon$$ 全域的散列函数簇必定满足：

$$
\varepsilon \geqslant \frac{1}{|B|} - \frac{1}{|U|}
$$

*11.3-6 设 $$U$$ 为由取自 $$Z_p$$ 中的值构成的 $$n$$ 元组集合，并设 $$B = Z_p$$，其中 $$p$$ 为素数。对于一个取自 $$U$$ 的输入 $$n$$ 元组 $$\left\langle a_0, a_1, \cdots, a_{n-1}\right\rangle$$，定义其上的散列函数 $$h_b: U \rightarrow B\left(b \in Z_p\right)$$ 为：

$$
h_b\left(\left\langle a_0, a_1, \cdots, a_{n-1}\right\rangle\right) = \left(\sum_{j = 0}^{n-1} a_jb^j\right) \mod p
$$

并且设 $$\mathcal{H} = \left\{h_b: b \in Z_p\right\}$$。根据练习 11.3-5 中 $$\varepsilon$$ 全域的定义，证明 $$\mathcal{H}$$ 是 $$((n-1) / p)$$ 全域的。（提示：见练习 31.4-4。）

### 练习 11.4

11.4-1 考虑用开放寻址法将关键字 10、22、31、4、15、28、17、88、59 插入到一长度为 $$m = 11$$ 的散列表中，辅助散列函数为 $$h'(k) = k$$。试说明分别用线性探查、二次探查（$$c_1 = 1, c_2 = 3$$）和双重散列（$$h_1(k) = k, h_2(k) = 1 + (k \mod (m - 1))$$）将这些关键字插入散列表的过程。

11.4-2 试写出 HASH-DELETE 的伪代码；修改 HASH-INSERT，使之能处理特殊值 DELETED。

11.4-3 考虑一个采用均匀散列的开放寻址散列表。当装载因子为 $$3/4$$ 和 $$7/8$$ 时，试分别给出一次不成功查找和一次成功查找的探查期望数上界。

*11.4-4 假设采用双重散列来解决冲突，即所用的散列函数为 $$h(k, i) = (h_1(k) + i h_2(k)) \mod m$$。试证明：如果对某个关键字 $$k$$，$m$ 和 $$ h_2(k)$$ 有最大公约数 $$ d \geqslant 1 $$，则在对关键字 $$ k $$ 的一次不成功查找中，在返回槽 $$ h(k)$$ 之前，要检查散列表中第 $$(1/d)$$ 个元素。于是，当 $$ d = 1 $$ 时，$$ m $$ 与 $$ h_2(k)$$ 互素，查找操作可能要检查整个散列表。（提示：见第 31 章。）

*11.4-5 考虑一个装载因子为 $$\alpha$$ 的开放寻址散列表。找出一个非零的 $$\alpha$$ 值，使得一次不成功查找的探查期望数是一次成功查找的探查期望数的 2 倍。这两个探查期望数可以使用定理 11.6 和定理 11.8 中给定的上界。

### 练习 11.5

*11.5-1 假设采用了开放寻址法和均匀散列技术将 $n$ 个关键字插入到一个大小为 $ m $ 的散列表中。设 $p(n, m)$ 为没有冲突发生的概率。试证明：$p(n, m) \leqslant e^{-n^2/m}$ $。论证当 $ $n$ $ 超过 $ $\sqrt{m}$ 时，不发生冲突的概率快速趋于 0。

### 思考题

11-1（微列最长探查的界）采用开放寻址法，用一个大小为 $m$ 的散列表来存储 $ n(n \leqslant m/2)$ 个数据项目。

a. 假设采用均匀散列，证明：对于 $$i = 1, 2, \cdots, n$$，第 $i$ 次插入需要严格多于 $ k $ 次探查的概率至多为 $2^{-k}$。

b. 证明：对于 $$i = 1, 2, \cdots, n$$，第 $i$ 次插入需要多于 $$ 2 \lg n $$ 次探查的概率为 $$ O(1/n^2)$$。设随机变量 $$ X_i $$ 表示第 $ i $ 次插入所需的探查次数。在上面 (b) 中已证明 $\operatorname{Pr}(X_i > 2 \lg n) = O(1/n^2)$ $。设随机变量 $ $X = \max_{i \in Z^2} X_i$ $ 表示 $ $\pi$ 次插入中所需探查数的最大值。

e. 证明：$$\operatorname{Pr}(X > 2 \lg n) = O(1/n)$$。

d. 证明：最长探查序列的期望长度为 $$E[X] = O(\lg n)$$。

11-2（链接法中槽大小的界）假设有一个含 $\pi$ 个槽的散列表，向表中插入 $\pi $ 个关键字，并用链接法来解决冲突问题。每个关键字被等可能地散列到每个槽中。所有关键字被插入后，设$M$ 是各槽中所含关键字数的最大值。读者的任务是证明 $M$ 的期望值 $ E [M] $ 的一个上界为 $O(\lg n / \lg \lg n)$。

a. 证明：正好有 $k$ 个关键字被散列到某一特定槽中的概率 $Q_k$ 为

$$
Q_n = \left(\frac{1}{n}\right)^k \left(1 - \frac{1}{n}\right)^{n-k} \left(\frac{n}{n}\right)^k
$$

b. 设 $P_1$ 为 $$ M = k $$ 的概率，即包含最多关键字的槽中有 $ k $ 个关键字的概率。证明：$ $P_1 \leqslant n Q_1$。

c. 应用斯特林近似公式 (3.18) 来证明：$$Q_k \leqslant e^2 / k^2$$。

d. 证明：存在常数 $c > 1$，使得 $$Q_k < 1 / n^2$$ 对 $$k_0 = c \lg n / \lg \lg n$$ 成立。并有结论：对 $$k \geqslant k_0 = c \lg n / \lg \lg n$$，$$P_1 < 1 / n^2$$ 成立。

e. 证明：

$$
E [M] \leqslant \operatorname{Pr}\left\{M > \frac{c \lg n}{\lg n}\right\} \cdot n + \operatorname{Pr}\left\{M \leqslant \frac{c \lg n}{\lg n}\right\} \cdot \frac{c \lg n}{\lg n}
$$

并有结论：$$E[M] = O(\lg n / \lg \lg n)$$。

11-3（二次探查）假设要在一个散列表（表中的各个位置为 0, 1, …, m-1）中查找关键字 $k$，并假设有一个散列函数 $h$ 将关键字空间映射到集合 $\{0, 1, …, m-1\}$ 上，查找方法如下：

1. 计算值 $j = h(k)$，置 $i = 0$。
2. 探查要找的关键字 $k$ 的位置 $j$，或者找到了，或者该位置为空，并结束查找。
3. 置 $i = i + 1$，如果 $$i = m$$，则表已满，于是终止探查；否则，设 $j = (i + j) \mod m$，返回到步骤 2。步骤 2。

假设 $$m$$ 是 2 的幂。

a. 通过给出等式 (11.5) 中 $c_1$ 和 $$c_1$$ 的适当值，来证明该方案是一般的“二次探查”法的一个实例。

b. 证明：在最坏情况下，这个算法要检查表中的每一个位置。

11-4（数列和认证）设 $\mathscr{H}$ 为一个散列函数类，其中的每个散列函数 $h \in \mathscr{H}$ 将关键字全域 $U$ 映射到 $$(0, 1, …, m-1)$$ 上。我们称 $\mathscr{H}$ 是 $k$ 全域的（universal），如果对每个由 $k$ 个不同的关键字 $$\left(x^{(1)}, x^{(1)}, …, x^{(k)}\right)$$ 构成的固定序列，以及从 $\mathscr{H}$ 中随机选出的任意散列函数 $h$，序列 $$\left(h\left(x^{(1)}\right), h\left(x^{(2)}\right), …, h\left(x^{(k)}\right)\right)$$ 是 $m^k$ 个长度为 $k$ 的序列（其元素取自 $$\{0, 1, …, m-1\}$$）中任意一个的可能性相同。

a. 证明：如果数列函数簇 $\mathscr{H}$ 是 2 全域的，则它是全域的。

b. 设全域 $U$ 为取自 $Z_p = (0, 1, …, p-1)$ 中数值的 $n$ 元组集合，此处 $p$ 为素数。考虑元 $$x = (x_0, x_1, …, x_{n-1}) \in U$$，对于任意的 $n$ 元组 $$a = (a_0, a_1, …, a_{n-1}) \in U$$，定义散列函数 $h_{a}$ 为

$$
h_{a}(x) = \left(\sum_{j = 0}^{n} a_j x_j\right) \mod p
$$

并设 $$\mathscr{H} = (h_{a})$$。证明：$\mathscr{H}$ 是全域的，但不是 2 全域的。（提示：寻找一个关键字，使得 $\mathscr{H}$ 中所有散列函数对其都得到相同的值。）

c. 假设将 (b) 中的 $\mathscr{H}$ 略作修改；对任意的 $a \in U$ 和任意的 $$b \in Z_0$$，定义

$$
h^{\prime}{}_{a}(x) = \left(\sum_{j = 0}^{n} a_j x_j + b\right) \mod p
$$

$$\mathscr{H}^{\prime} = (h^{\prime}{}_{ab})$$。论证 $\mathscr{H}^{\prime}$ 是 2 全域的。（提示：考虑固定的 $n$ 元组 $x \in U$ 和 $y \in U$，对某个 $i$ 有 $$x_i \neq y_i$$。当 $a_1$ 和 $b_i$ 包括 $Z_p$ $ 时，$ $h^{\prime}_{ab}(x) $ $ 和 $ $h^{\prime}_{ab}(y) $ 会如何？）

d. 假设 Alice 和 Bob 悄悄地约定了一个取自 2 全域散列函数簇 $\mathcal{H}$ 中的散列函数 $h$。每个 $$h \in \mathcal{H}$$ 将关键字全域 $U$ 映射到 $$Z_p$$ 上，此处 $p$ 为素数。后来，Alice 通过互联网向 Bob 发送了一个消息 $$m$$，其中 $$m \in U$$。她同时还通过发送一个认证标记 $$t = h(m)$$ 来向 Bob 认证这一消息，而 Bob 则要检查他所接收到的 (m, t) 对是否确实满足 $$t = h(m)$$。假设某一对手半路中截获了 (m, t)，并试图将该值对替换为另一值对 $$(m', t')$$ 来欺骗 Bob。论证无论该对手的计算机性能多好，他成功地欺骗 Bob 接受 $$(m', t')$$ 的概率至多为 $$1/p$$，即使他知道所用的散列函数簇 $$\mathcal{H}$$。

## 第十二章 二叉搜索树

#### 练习 12.1

练习

12.1-1 对于关键字集合($$1,4,5,10,16,17,21$$)，分别画出高度为 2、3、4、5 和 6 的二叉搜索树。

12.1-2 二叉搜索树性质与最小堆性质(见 6.1 节)之间有什么不同？能使用最小堆性质在 $$O(n)$$ 时间内按序输出一棵有 $$n$$ 个结点树的关键字吗？可以的话，请说明如何做，否则解释理由。

12.1-3 设计一个执行中序遍历的非递归算法。（提示：一种容易的方法是使用栈作为辅助数据结构；另一种较复杂但比较简洁的做法是不使用栈，但要假设能测试两个指针是否相等。）

12.1-4 对于一棵有 $$n$$ 个结点的树，请设计在 $$\Theta(n)$$ 时间内完成的先序遍历算法和后序遍历算法。

12.1-5 因为在基于比较的排序模型中，完成 $$n$$ 个元素的排序，其最坏情况下需要 $$\Omega(n\lg n)$$ 时间。试证明：任何基于比较的算法从 $$n$$ 个元素的任意序列中构造一棵二叉搜索树，其最坏情况下需要 $$\Omega(n\lg n)$$ 的时间。

### 练习 12.2

12.2-1 假设一棵二叉搜索树中的结点在 1 到 1000 之间，现在想要查找数值为 363 的结点。下面序列中哪个不是查找过的序列？

​	a. 2, 252, 401, 398, 330, 344, 397, 363。

​	b. 924, 220, 911, 244, 898, 258, 362, 363。

​	c. 925, 202, 911, 240, 912, 245, 363。

​	d. 2, 399, 387, 219, 266, 382, 381, 278, 363。

​	e. 935, 278, 347, 621, 299, 392, 358, 363。

12.2-2 写出 TREE-MINIMUM 和 TREE-MAXIMUM 的递归版本。

12.2-3 写出过程 TREE-PREDECESSOR 的伪代码。

12.2-4 Bunyan 教授认为他发现了一个二叉搜索树的重要性质。假设在一棵二叉搜索树中查找一个关键字 $$k$$，查找结束于一个树叶。考虑三个集合：A 为查找路径左边的关键字集合；B 为查找路径上的关键字集合；C 为查找路径右边的关键字集合。Bunyan 教授声称：任何 $$a\in A, b\in B$$ 和 $$c\in C$$，一定满足 $$a\leqslant b\leqslant c$$。请给出该教授这个论断的一个最小可能的反例。

12.2-5 证明：如果一棵二叉搜索树中的一个结点有两个孩子，那么它的后继没有左孩子，它的前驱没有右孩子。

12.2-6 考虑一棵二叉搜索树 T，其关键字互不相同。证明：如果 T 中一个结点 x 的右子树为空，且 x 有一个后继 y，那么 y 一定是 x 的最底层祖先，并且其左孩子也是 x 的祖先。（注意到，每个结点都是它自己的祖先。）

12.2-7 对于一棵有 n 个结点的二叉搜索树，有另一种方法来实现中序遍历，先调用 TREE-MINIMUM 找到这棵树中的最小元素，然后再调用 n-1 次的 TREE-SUCCESSOR。证明：该算法的运行时间为 $$\Theta(n)$$。

12.2-8 证明：在一棵高度为 h 的二叉搜索树中，不论从哪个结点开始，k 次连续的 TREE-SUCCESSOR 调用所需时间为 $$O(k+h)$$。

12.2-9 设 T 是一棵二叉搜索树，其关键字互不相同；设 x 是一个叶结点，y 为其父结点。证明：y.key 或者是 T 树中大于 x.key 的最小关键字，或者是 T 树中小于 x.key 的最大关键字。

### 练习 12.3

12.3-1 给出 TREE-INSERT 过程的一个递归版本。

12.3-2 假设通过反复向一棵树中插入互不相同的关键字来构造一棵二叉搜索树。证明：在这棵树中查找关键字所检查过的结点数目等于先前插入这个关键字所检查的结点数目加 1。

12.3-3 对于给定的 $$n$$ 个数的集合，可以通过先构造包含这些数据的一棵二叉搜索树（反复使用 TREE-INSERT 逐个插入这些数），然后按中序遍历输出这些数的方法，来对它们排序。这个排序算法的最坏情况运行时间和最好情况运行时间各是多少？

12.3-4 删除操作可交换吗？可交换的含义是，先删除 $$x$$ 再删除 $$y$$ 留下的结果树与先删除 $$y$$ 再删除 $$x$$ 留下的结果树完全一样。如果是，说明为什么？否则，给出一个反例。

12.3-5 假设为每个结点换一种设计，属性 $$x.p$$ 指向 $$x$$ 的双亲，属性 $$x.succ$$ 指向 $$x$$ 的后继。试给出使用这种表示法的二叉搜索树 T 上 SEARCH、INSERT 和 DELETE 操作的伪代码。这些伪代码应在 $$O(h)$$ 时间内执行完，其中 $$h$$ 为树 T 的高度。（提示：应该设计一个返回某个结点的双亲的子过程。）

12.3-6 当 TREE-DELETE 中的结点 $$z$$ 有两个孩子时，应该选择结点 $$y$$ 作为它的前驱，而不是作为它的后继。如果这样做，对 TREE-DELETE 应该做些什么必要的修改？一些人提出了一个公平策略，为前驱和后继赋予相等的优先级，这样得到了较好的实验性能。如何对 TREE-DELETE 进行修改来实现这样一种公平策略？



### 练习 12.4

12.4-1 证明等式(12.3)。

12.4-2 请描述这样一棵有 $$n$$ 个结点的二叉搜索树，其树中结点的平均深度为 $$\Theta(\lg n)$$，但这棵树的高度是 $$\omega(\lg n)$$。一棵有 $$n$$ 个结点的二叉搜索树中结点的平均深度为 $$\Theta(\lg n)$$，给出这棵树高度的一个渐近上界。

12.4-3 说明含有 $$n$$ 个关键字的随机选择二叉搜索树的概念，这里每一棵 $$n$$ 个结点的二叉搜索树是等可能地被选择，不同于本节中给出的随机构建二叉搜索树的概念。（提示：当 $$n=3$$ 时，列出所有的可能。）

12.4-4 证明：函数 $$f(x)=2^x$$ 是凸的。

*12.4-5 考虑 RANDOMIZED-QUICKSORT 操作在 $$n$$ 个互不相同的输入数据的序列上。证明：对于任何常数 $$k>0$$，$$n!$$ 种输入排列除了其中的 $$O(1/n^k)$$ 种之外，运行时间都为 $$O(n\lg n)$$。

### 思考题

12-1 （带有相同关键字的二叉搜索树）相同关键字给二叉搜索树的实现带来了问题。
	a. 当用 TREE-INSERT 将 $$n$$ 个其中带有相同关键字的数据插入到一棵初始为空的二叉搜索树中时，其渐近性能是多少？
建议通过在第 5 行之前测试 $$z.key=x.key$$ 和在第 11 行之前测试 $$z.key=y.key$$ 的方法，来对 TREE-INSERT 进行改进。如果相等，根据下面的策略之一来实现。对于每个策略，得到将 $$n$$ 个其中带有相同关键字的数据插入到一棵初始为空的二叉搜索树中的渐近性能。（对第 5 行描述的策略是比较 $$z$$ 和 $$y$$ 的关键字，用于第 11 行的策略是用 $$y$$ 代替 $$z$$。）
	b. 在结点 $$x$$ 设置一个布尔标志 $$x.b$$ 并根据 $$x.b$$ 的值，置 $$x$$ 为 $$x.left$$ 或 $$x.right$$。当插入一个与 $$x$$ 关键字相同的结点时，每次访问 $$x$$ 时交替地置 $$x.b$$ 为 FALSE 或 TRUE。
	c. 在 $$x$$ 处设置一个与 $$x$$ 关键字相同的结点列表，并将 $$z$$ 放到该列表中。
	d. 随机地置 $$z$$ 为 $$x.left$$ 或 $$x.right$$。（给出最坏情况性能，并非形式地导出期望运行时间。）

12-2 （基数树）给定两个串 $$a=a_0a_1\cdots a_q$$ 和 $$b=b_0b_1\cdots b_q$$，这里每个 $$a_i$$ 和 $$b_i$$ 是以字符集的某种次序出现的，如果下面两种规则之一成立，就称串 $$a$$ 按字典序小于（lexicographically less than）串 $$b$$：
1. 存在一个整数 $$j$$，其中 $$0\leq j\leq \min(p, q)$$，使得对所有的 $$i=0, 1, \cdots, j-1$$，$$a_i=b_i$$，成立，且 $$a_j<b_j$$。
2. $$p<q$$，且对所有的 $$i=0, 1, \cdots, p$$，$$a_i=b_i$$。
例如，如果 $$a$$ 和 $$b$$ 是位串，那么 10 100 < 10 110(b 规则 1，取 $$j=3$$)，10 100 < 101 000（由规则 2）。这种次序类似于英语字典中使用的排序。

基数树（radix tree）数据结构如图 12-5 所示，这个树存储了位串 1011、10、011、100 和 0。

<img src="F:\software\Typora\images\image-20250117134056016.png" alt="image-20250117134056016" style="zoom:80%;" />

当对一个关键字 $$a=a_0a_1\cdots a_p$$ 进行查找时，在深度为 $$i$$ 的一个结点处，如果 $$a_i=0$$，则走左侧；如果 $$a_i=1$$，则走右侧。设 S 是一个不同位串组成的集合，各个串长度相同。说明如何使用一棵基数树在 $$O(n)$$ 时间内按字典序对 S 进行排序。对于图 12-5 所示的例子，排序输出的应该是序列 0、011、10、100、1011。



12-3（随机构建二叉搜索树中的平均结点深度）在本题中，要证明有 $$n$$ 个结点的一棵随机构建二叉搜索树中的结点平均深度为 $$O(\lg n)$$。虽然这个结果弱于定理 12.4，但我们使用的方法显露出构建一棵二叉搜索树与 7.3 节中的 RANDOMIZED-QUICKSORT 的执行之间有着惊人的相似之处。

定义一棵二叉树 T 的路径总长度(total path length) $$P(T)$$ 为 T 中所有结点 x 的深度之和，对每个结点 x 的深度表示为 $$d(x, T)$$。

a. 证明：T 中的一个结点平均深度是
$$
\frac{1}{n}\sum_{x\in T} d(x, T)=\frac{1}{n} P(T)
$$
因此，我们希望进一步证明 $$P(T)$$ 的期望值为 $$O(n\lg n)$$。

b. 设 $$T_L$$ 和 $$T_R$$​ 分别表示树 T 的左子树和右子树，证明：如果 T 有 n 个结点，则
$$
P(T)= P(T_L)+P(T_R)+n-1
$$
c. 设 P(n) 表示有 n 个结点的随机构建二叉搜索树的平均路径总长度，证明：
$$
P(n)=\frac{1}{n}\sum_{i = 0}^{n}(P(i)+P(n-i-1)+n-1)
$$
d. 说明如何将 P(n) 重写为：
$$
P(n)=\frac{2}{n}\sum_{k = 1}^{n-1} P(k)+\Theta(n)
$$
e. 思考题 7-3 曾给出随机快速排序的另一种分析，试证明结论：$$P(n)=O(n\lg n)$$。

在快速排序的每次递归调用时，总要选择一个随机划分元来为待排序的元素集合进行划分。二叉搜索树的每个结点都是对以该结点为根的子树中所有元素进行划分。

f. 请给出快速排序的一种实现，使快速排序中对一组元素的比较与将这些元素插入一棵二叉搜索树中所需的比较恰好相同。（这些比较的次序可以不同，但出现的比较一定要一样。）

12-4（不同二叉树的数目）设 $$b_n$$ 表示含有 n 个结点的不同二叉树的数目。在本题中，试给出一个求 $$b_n$$ 的公式和一个渐近估计。

a. 证明：$$b_0=1$$ 且对 $$n\geqslant 1$$，有
$$
b_n =\sum_{i = 0}^{n-1} b_i b_{n-i-1}
$$
b. 参考思考题 4-4 中生成函数的定义，设 B(x) 是下面的生成函数：
$$
B(x)=\sum_{n = 0}^{\infty} b_n x^n
$$
证明：$$B(x)=xB(x)^2+1$$​，因此以闭形式表示 B(x) 的一种方式是
$$
B(x)=\frac{1}{2x}(1-\sqrt{1-4x})
$$
f(x) 在点 $$x=a$$​ 处的泰勒展开式 (Taylor expansion) 为
$$
f(x)=\sum_{k = 0}^{\infty}\frac{f^{(k)}(a)}{k!}(x-a)^k
$$
这里 $$f^{(k)}(x)$$ 是在 x 处的 k 阶导数。

c. 使用 $$\sqrt{1-4x}$$ 在 $$x=0$$​ 处的泰勒展开式，证明：
$$
b_n =\frac{1}{n+1}\binom{2n}{n}
$$
（即第 n 个 Catalan 数）。（如果读者愿意，可以不用泰勒展开式，而是将二项展开式 (C. 4) 推广到非整数的指数 n 上去，也就是对于任何实数 n 和任何整数 k，当 $$k\geqslant 0$$ 时，$$\binom{n}{k}$$ 可以表示为 $$n(n-1)\cdots(n-k+1)/k!$$，否则为 0。）

d. 证明：
$$
b_n =\frac{4^n}{\sqrt{\pi n}}(1+O(1/n))
$$

## 第十三章 红黑树

### 练习13.1

13.1-1 按照图 13-1(a) 的方式，画出在关键字集合 {1, 2, ..., 15} 上高度为 3 的完全二叉搜索树。以三种不同方式向图中加入 NIL 叶结点并对各结点着色，使所得的红黑树的黑高分别为 2、3 和 4。

13.1-2 对图 13-1 中的红黑树，画出对其调用 TREE-INSERT 操作插入关键字 36 后的结果。如果插入的结点被标为红色，所得的树是否还是一棵红黑树？如果该结点被标为黑色呢？

13.1-3 定义一棵松弛红黑树 (relaxed red-black tree) 为满足红黑性质 1、3、4 和 5 的二叉搜索树。换句话说，根结点可以是红色或是黑色。考虑一棵根结点为红色的松弛红黑树 T。如果将 T 的根结点标为黑色而其他都不变，那么所得到的是否还是一棵红黑树？

13.1-4 假设将一棵红黑树的每一个红结点“吸收”到它的黑色父结点中，使得红结点的子结点变成黑色父结点的子结点（忽略关键字的变化）。当一个黑结点的所有红色子结点都被吸收后，它可能的度为多少？所得的树的叶结点深度如何？

13.1-5 证明：在一棵红黑树中，从某结点 x 到其后代叶结点的所有简单路径中，最长的一条至多是最短一条的 2 倍。

13.1-6 在一棵黑高为 k 的红黑树中，内部结点最多可能有多少个？最少可能有多少个？

13.1-7 试描述一棵含有 n 个关键字的红黑树，使其红色内部结点个数与黑色内部结点个数的比值最大。这个比值是多少？该比值最小的树又是怎样呢？比值是多少？

### 练习13.2

13.2-1 写出 RIGHT-ROTATE 的伪代码。

13.2-2 证明：在任何一棵有 $n$ 个结点的二叉搜索树中，恰有 $n-1$ 种可能的旋转。

13.2-3 设在图 13-2 左边一棵树中，$a$、$b$ 和 $c$ 分别为子树 $\alpha$、$\beta$ 和 $\gamma$ 中的任意结点。当结点 $x$ 左旋之后，$a$、$b$ 和 $c$ 的深度会如何变化？

13.2-4 证明：任何一棵含 $n$ 个结点的二叉搜索树可以通过 $O(n)$ 次旋转，转变为其他任何一棵含 $n$ 个结点的二叉搜索树。（提示：先证明至多 $n-1$ 次右旋足以将树转变为一条右侧伸展的链。）

*13.2-5 如果能够使用一系列的 RIGHT-ROTATE 调用把一个二叉搜索树 $T_1$ 变为二叉搜索树 $T_2$，则称 $T_1$ 可以右转(right-converted)成 $T_2$。试给出一个例子表示两棵树 $T_1$ 和 $T_2$，其中 $T_1$ 不能够右转成 $T_2$。然后，证明：如果 $T_1$ 可以右转成 $T_2$，那么它可以通过 $O(n^2)$ 次 RIGHT-ROTATE 调用来实现右转。

### 练习13.3

13.3-1 在 RB-INSERT 的第 16 行，将新插入的结点 $z$ 着为红色。注意到，如果将 $z$ 着为黑色，则红黑树的性质 4 就不会被破坏。那么为什么不选择将 $z$ 着为黑色呢？

13.3-2 将关键字 41、38、31、12、19、8 连续地插入一棵初始为空的红黑树之后，试画出该结果树。

13.3-3 假设图 13-5 和图 13-6 中子树 $\alpha$、$\beta$、$\gamma$、$\delta$ 和 $\varepsilon$ 的黑高都是 $k$。给每张图中的每个结点标上黑高，以验证图中所示的转换能保持性质 5。

13.3-4 Teach 教授担心 RB-INSERT-FIXUP 可能将 $T.nil.color$ 设为 RED，这时，当 $z$ 为根时，第 1 行的测试就不会让循环终止。通过讨论 RB-INSERT-FIXUP 永远不会将 $T.nil.color$ 设置为 RED，来说明这位教授的担心是没有必要的。

13.3-5 考虑一棵用 RB-INSERT 插入 $n$ 个结点而成的红黑树。证明：如果 $n>1$，则该树至少有一个红结点。

13.3-6 说明如果红黑树的表示中不提供父指针，应当如何有效地实现 RB-INSERT。

### 练习13.4

13.4-1 在执行 RB-DELETE-FIXUP 之后，证明：树根一定是黑色的。

13.4-2 在 RB-DELETE 中，如果 $x$ 和 $x.p$ 都是红色的，证明：可以通过调用 RB-DELETE-FIXUP($T$, $x$) 来恢复性质 4。

13.4-3 在练习 13.3-2 中，将关键字 41、38、31、12、19、8 连续插入一棵初始的空树中，从而得到一棵红黑树。请给出从该树中连续删除关键字 8、12、19、31、38、41 后的红黑树。

13.4-4 在 RB-DELETE-FIXUP 代码的哪些行中，可能会检查或修改哨兵 $T.nil$？

13.4-5 在图 13-7 的每种情况中，给出所示子树的根结点至每棵子树 $\alpha, \beta, \cdots, \zeta$ 之间的黑结点个数，并验证它们在转换之后保持不变。当一个结点的 color 属性为 $c$ 或 $c'$ 时，在计数中用记号 count($c$) 或 count($c'$) 来表示。

13.4-6 Skelton 和 Baron 教授担心在 RB-DELETE-FIXUP 的情况 1 开始时，结点 $x.p$ 可能不是黑色的。如果这两位教授是对的，则第 5～6 行就是错的。证明：$x.p$ 在情况 1 开始时必是黑色的，从而说明这两位教授没有担心的必要。

13.4-7 假设用 RB-INSERT 将一个结点 $x$ 插入一棵红黑树，紧接着又用 RB-DELETE 将它从树中删除。结果的红黑树与初始的红黑树是否一样？证明你的答案。

### 思考题

13-1 （持久动态集合）有时在算法的执行过程中，我们会发现在更新一个动态集合时，需要保留过去的版本。我们称这样的集合为持久的（persistent）。实现持久集合的一种方法是每当该集合被修改时，就将其完整地复制下来，但是这种方法会降低一个程序的执行速度，而且占用过多的空间。有时候，我们可以做得更好些。

考虑一个有 INSERT、DELETE 和 SEARCH 操作的持久集合 $S$，我们使用如图 13-8(a) 所示的二叉搜索树来实现。对集合的每一个版本都维护一个不同的根。为了将关键字 $z$ 插入到集合中，创建一个具有关键字 $z$ 的新结点。该结点成为具有关键字 $z$ 的新结点的左孩子，因为我们不能更改具有关键字 $z$ 的已存在结点。类似地，具有关键字 $7$ 的新结点成为具有关键字 $8$ 的新结点的左孩子，后者的右孩子为具有关键字 $10$ 的已存在结点。关键字为 $2$ 的新结点又成为关键字为 $4$ 的新根结点 $r'$ 的右孩子，而 $r'$ 的左孩子是关键字为 $3$ 的已存在结点。这样，我们只是复制了原树的一些结点，新树共享了原树的一些结点，如图 13-8(b) 所示。

![图13-8](F:\software\Typora\images\image-20250117222140667.png)

图 13-8 (a) 包含关键字 2, 3, 4, 7, 8, 10 的一棵二叉搜索树。(b) 插入关键字 5 后得到的持久二叉搜索树。该集合的最新版本包括由根 $r'$ 出发可到达的结点，而前一个版本包括由根 $r$ 可到达的结点。深阴影的结点是插入关键字 5 时增加的。

假设树中每个结点都有属性 color、left 和 right，但没有属性 parent。（参见练习 13.3-6）

​	a. 对于一棵一般的持久二叉搜索树，为插入一个关键字 $k$ 或删除一个结点 $y$，需要改变哪些结点。

​	b. 请写出一个过程 PERSISTENT-TREE-INSERT，使得在给定一棵持久树 $T$ 和一个要插入的关键字 $k$ 时，它返回将 $k$ 插入 $T$ 后得到的新的持久树 $T'$。

​	c. 如果持久二叉搜索树 $T$ 的高度为 $h$，实现 PERSISTENT-TREE-INSERT 过程的时间和空间需求分别是多少？（空间需求与新分配的结点数成正比。）

​	d. 假设在每个结点中增加一个父结点属性。这种情况下，PERSISTENT-TREE-INSERT 需要做一些额外的复制工作。证明：PERSISTENT-TREE-INSERT 的时间需求和空间需求为 $\Omega(n)$，其中 $n$ 为树中的结点个数。

​	e. 说明如何利用红黑树来保证每次插入或删除的最坏情况运行时间和空间为 $O(\log n)$。



13-2（红黑树上的连接操作）连接(JOIN) 将取两个动态集合 $S_1$、$S_2$ 和一个元素 $z$，使得对任何 $x_1 \in S_1$ 和 $x_2 \in S_2$，有 $x_1.key \leq z.key \leq x_2.key$，该操作返回一个集合 $S = S_1 \cup \{z\} \cup S_2$。在这个问题中，讨论如何在红黑树上实现连接。

​	a. 给定一些关键字，其黑点都存放在新属性 $T.bh$ 中。证明：在不需要树中结点的额外存储空间和不增加渐近运行时间的前提下，RB-INSERT 和 RB-DELETE 可以维护这个属性。并证明：当插入了 $n$ 个结点时，可以对每个被访问的结点在 $O(1)$ 时间内确定其黑高，要求实现操作 RB-JOIN($T_1$, $z$, $T_2$)，它像 $T_1$ 和 $T_2$ 并返回一棵红黑树 $T = T_1 \cup \{z\} \cup T_2$，其中 $z$ 为 $T_1$ 和 $T_2$ 中的结点集合。

​	b. 假设 $T_1$, $bh \geq T_2$, $bh$。试描述一个 $O(\log n)$ 时间的算法，使之能从黑高为 $bh$ 的结点中选出具有最大关键字的 $T_1$ 中的黑结点 $y$。

​	c. 设 $T$ 是以 $y$ 为根结点的树。试说明如何在不破坏二叉搜索树性质的前提下，在 $O(1)$ 时间内用 $T_1 \cup \{x\} \cup T_2$ 来取代 $T$。

​	d. 要保持红黑性质 1、3 和 5，应将 $z$ 着成什么颜色？试说明如何在 $O(\log n)$ 时间内维护性质 2 和性质 4。

​	e. 论证使用 (d) 部分的假设是不一般性的，并描述当 $T_1$, $bh \leq T_2$, $bh$ 时出现的对称情况。

​	f. 证明：RB-JOIN 的运行时间是 $O(\log n)$。



13-3 （AVL 树）AVL 树是一种高度平衡的（height balanced）二叉搜索树：对每一个结点 $x$，$x$ 的左子树与右子树的高度差至多为 1。要实现一棵 AVL 树，需要在每个结点内维护一个额外的属性：$x$ 的高度 $h_x$。与任何其他的二叉搜索树 $T$ 一样，假设 $T.root$ 指向根结点。

a. 证明：一棵有 $n$ 个结点的 AVL 树高度为 $O(\log n)$。（提示：证明高度为 $h$ 的 AVL 树至少有 $F_h$ 个结点，其中 $F_h$ 是斐波那契数列的第 $h$ 个数。）

b. 要在一棵 AVL 树中插入一个结点，首先以二叉搜索树的顺序把该结点放在适当的位置上。此时，这棵树可能就不再是高度平衡的。具体来说，某些结点的左子树与右子树的高度差可能会到 2。请描述一个过程 BALANCE($x$)，输入一棵以 $x$ 为根的子树，其左子树与右子树都是高度平衡的，而且它们的高度差至多是 2，即 $|x.right.h - x.left.h| \leq 2$，并将这棵以 $x$ 为根的子树转变为高度平衡的。（提示：使用旋转。）

c. 利用 (b) 来描述一个递归过程 AVL-INSERT($x$, $z$)，该操作输入一个 AVL 树中的结点 $x$ 以及一个新创建的结点 $z$（其关键字已经填入），然后将 $z$ 添加到以 $x$ 为根的子树中，并保持 $x$ 是一棵 AVL 树的根结点。和 12.3 节中的 TREE-INSERT 一样，假设 $z.key$ 已经被填入，且 $z.left = NIL, z.right = NIL$；再假设 $z.h = 0$。因此要把结点 $z$ 插入到 AVL 树 $T$ 中，需要调用 AVL-INSERT($T.root$, $z$)。

d. 证明：在一棵 $n$ 个结点的 AVL 树上 AVL-INSERT 操作需花费 $O(\log n)$ 时间，且执行 $O(1)$ 次旋转。





13-4 （trap 树）如果将一个含 $n$ 个元素的集合插入到一棵二叉搜索树中，所得到的树可能会相当不平衡，从而导致查找时间很长。然而从 12.4 节可知，随机构造二叉搜索树是趋向于平衡的。因此，一般来说，要为一组固定的元素建立一棵平衡的二叉搜索树，可以采用的一种策略就是先随机排列这些元素，然后按照排列的顺序将它们插入到树中。

如果没法同时得到所有的元素，应该怎样处理呢？如果一次收到一个元素，是否仍然能使用它们来随机建立一棵二叉搜索树？

我们将通过考察一个数据结构来正面回答这个问题。一棵 trap 树是一棵更改了结点排列方式的二叉搜索树。

![image-20250117222942443](F:\software\Typora\images\image-20250117222942443.png)

图 13-9 显示了一个例子。通常，树内的每一个结点 $x$ 都有一个关键字值 $x.key$，另外，还要为每个结点指定 $x.priority$，它是一个独立选取的随机数。假设所有的优先级都是不同的，而且所有的关键字也是不同的。trap 树的结点被排列成让关键字遵循二叉搜索树的性质，但优先级遵循最小堆顺序性质：

- 如果 $v$ 是 $u$ 的左孩子，则 $v.key \leq u.key$。
- 如果 $v$ 是 $u$ 的右孩子，则 $v.key \geq u.key$。
- 如果 $v$ 是 $u$ 的孩子，则 $v.priority > u.priority$。

（这两个性质的结合就是这种树被称为“trap”树的原因：它同时具有二叉搜索树和堆的特征。）

用以下方式考虑 trap 树是会有帮助的。假设将已有相应关键字的结点 $x_1$，$x_2$，…，$x_n$ 插入到一棵 trap 树内。得到的 trap 树是通过将这些结点以它们的优先级（随机选取）的顺序插入一棵正常的二叉搜索树形成的，即 $x_i.priority < x_j.priority$ 表示 $x_i$ 在 $x_j$ 之前被插入。

​	a. 证明：给定一个有相应关键字和优先级（互异）的结点 $x_1$，$x_2$，…，$x_n$ 组成的集合，存在唯一的一棵 trap 树与这些结点相关联。

​	b. 证明：trap 树的期望高度是 $O(\log n)$，因此在 trap 内查找一个值所花的时间为 $O(\log n)$。
让我们看看如何将一个新的结点插入到一个已存在的 trap 树中。要做的第一件事就是将一个随机的优先级赋予这个新结点。然后调用称为 TREAT-INSERT 的插入算法，其操作如图 13-10 所示。

![image-20250117223338258](F:\software\Typora\images\image-20250117223338258.png)

​	c. 解释 TREAP-INSERT 是如何工作的。说明其思想并给出伪代码。（提示：执行通常的二叉搜索树插入过程，然后做旋转来恢复最小堆顺序的性质。）

​	d. 证明：TREAP-INSERT 的期望运行时间是 $O(\log n)$。

TREAP-INSERT 先执行一个查找，然后做一系列旋转。虽然这两种操作的期望运行时间相同，但它们的实际代价不同。查找操作从 treap 树中读取信息而不做修改。相反，旋转操作会改变 treap 树内的父结点和子结点的指针。在大部分的计算机上，读取操作要比写入操作快很多。所以我们希望 TREAP-INSERT 执行少量的旋转。后面将说明所执行旋转的期望次数有一个常数界。

为此，需要做一些定义，如图 13-11 所示。一棵二叉搜索树 $T$ 的左脊柱 (left spine) 是从根结点到有最小关键字的结点的简单路径。换句话说，左脊柱是从根结点开始只包含左边缘的简单路径。对称地，$T$ 的右脊柱 (right spine) 是从根结点开始只包含右边缘的简单路径。一条脊柱的长度是它包含的结点数目。

![image-20250117223730631](F:\software\Typora\images\image-20250117223730631.png)

e. 考虑利用 TREAP-INSERT 插入结点 $x$ 后的 treap $T$。设 $C$ 为 $x$ 左子树的右脊柱的长度，$D$ 为 $x$ 右子树的左脊柱的长度。证明：在插入 $x$ 期间所执行的旋转的总次数等于 $C+D$。

现在来计算 $C$ 和 $D$ 的期望值。不失一般性，假设关键字为 1, 2, …, $n$，因为只是将它们两两比较。

对 treap $T$ 中的结点 $x$ 和 $y$，其中 $y \neq x$，设 $k = x.key$ 以及 $i = y.key$。定义指示器随机变量
$$
X_{ik} = I\{y \text{ 在 } x \text{ 的左子树的右脊柱中}\}
$$
f. 证明：$X_{ik} = 1$ 当且仅当 $y.priority > x.priority$，$y.key < x.key$ 成立，且对于每个满足 $y.key < z.key < x.key$ 的 $z$，有 $y.priority < z.priority$。

g. 证明：
$$
\Pr\{X_{ik} = 1\} = \frac{(k-i-1)!}{(k-i+1)!} = \frac{1}{(k-i+1)(k-i)}
$$
h. 证明：
$$
E[C] = \sum_{j=1}^{k-1} \frac{1}{j(j+1)} = 1 - \frac{1}{k}
$$
i. 利用对称性证明：
$$
E[D] = 1 - \frac{1}{n-k+1}
$$
j. 得出如下结论：当在一棵 trap 树中插入一个结点时，执行旋转的期望次数小于 2。

## 第十四章 数据结构的扩张

### 练习14.1

14.1-1 对于图 14-1 中的红黑树 $T$，说明执行 OS-SELECT($T.root$, 10) 的过程。

14.1-2 对于图 14-1 中的红黑树 $T$ 和关键字 $x.key$ 为 35 的结点 $x$，说明执行 OS-RANK($T$, $x$) 的过程。

14.1-3 写出 OS-SELECT 的非递归版本。

14.1-4 写出一个递归过程 OS-KEY-RANK($T$, $k$)，以一棵顺序统计树 $T$ 和一个关键字 $k$ 作为输入，要求返回 $k$ 在由 $T$ 表示的动态集合中的秩。假设 $T$ 的所有关键字都不相同。

14.1-5 给定 $n$ 个元素的顺序统计树中的一个元素 $x$ 和一个自然数 $i$，如何在 $O(\log n)$ 的时间内确定 $x$ 在该树线性序中的第 $i$ 个后继？

14.1-6 在 OS-SELECT 或 OS-RANK 中，注意到无论什么时候引用结点的 size 属性都是为了计算一个秩。相应地，假设每个结点都存储它在以自己为根的子树中的秩。试说明在插入和删除时，如何维护这个信息。（注意，这两种操作都可能引起旋转。）

14.1-7 说明如何在 $O(n \log n)$ 时间内，利用顺序统计树对大小为 $n$ 的数组中的逆序对（见思考题 2-4）进行计数。

*14.1-8 现有一个圆上的 $n$ 条弦，每条弦都由其端点来定义。请给出一个能在 $O(n \log n)$ 时间内确定圆内相交弦对数的算法。（例如，如果 $n$ 条弦都为直径，它们相交于圆心，则正确的答案为 $\binom{n}{2}$。）假设任意两条弦都不会共享端点。

### 练习14.2

14.2-1 通过为结点增加指针的方式，试说明如何在扩张的顺序统计树上，支持每一动态集合查询操作 MINIMUM、MAXIMUM、SUCCESSOR 和 PREDECESSOR 在最坏时间 $O(1)$ 内完成。顺序统计树上的其他操作的渐近性能不应受影响。

14.2-2 能否在不影响红黑树任何操作的渐近性能的前提下，将结点的黑高作为树中结点的一个属性来维护？说明如何做，如果不能，请说明理由。如何维护结点的深度？

*14.2-3 设 $\otimes$ 为一个满足结合律的二元运算符，$a$ 为红黑树中每个结点上的一个要维护的属性。假设在每个结点 $x$ 上增加一个属性 $f$，使 $x.f = x_1.a \otimes x_2.a \otimes \cdots \otimes x_m.a$，其中 $x_1, x_2, \cdots, x_m$ 是以 $x$ 为根的子树中按中序次序排列的所有结点。说明在一次旋转后，如何在 $O(1)$ 时间内更新 $f$ 属性。对你的扩张稍做修改，使得它能够应用到顺序统计树的 size 属性中。

*14.2-4 希望设计一个操作 $RB-ENUMERATE(x, a, b)$，来对红黑树进行扩张。该操作输出所有的关键字 $k$，使得在以 $x$ 为根的红黑树中有 $a \leqslant k \leqslant b$。描述如何在 $\Theta(m + \log n)$ 时间内实现 $RB-ENUMERATE$，其中 $m$ 为输出的关键字数目，$n$ 为树中的内部结点数。（提示：不需要向红黑树中增加新的属性。）

### 练习14.3

14.3-1 写出作用于区间树的结点且在 $O(1)$ 时间内更新 $max$ 属性的过程 LEFT-ROTATE 的伪代码。

14.3-2 改写 INTERVAL-SEARCH 的代码，使得当所有区间都是开区间时，它也能正确地工作。

14.3-3 请给出一个有效的算法，对一个给定的区间 $i$，返回一个与 $i$ 重叠且具有最小低端点的区间；或者当这样的区间不存在时返回 $T.nil$。

14.3-4 给定一棵区间树 $T$ 和一个区间 $i$，请描述如何在 $O(\min(n, k \log n))$ 时间内列出 $T$ 中所有与 $i$ 重叠的区间，其中 $k$ 为输出的区间数。（提示：一种简单的方法是做若干次查询，并且在这些查询操作中修改树，另一种略微复杂点的方法是不对树进行修改。）

14.3-5 对区间树 $T$ 和一个区间 $i$，请修改有关区间树的过程来支持新的操作 INTERVAL-SEARCH-EXACTLY($T$, $i$)，它返回一个指向 $T$ 中结点 $x$ 的指针，使得 $x.int.low = i.low$ 且 $x.int.high = i.high$；或者，如果 $T$ 不包含这样的区间时返回 $T.nil$。所有的操作（包括 INTERVAL-SEARCH-EXACTLY）对于包含 $n$ 个结点的区间树的运行时间都应为 $O(\log n)$。

14.3-6 说明如何来维护一个支持操作 MIN-GAP 的一些数的动态集 $Q$，使得该操作能给出 $Q$ 中两个最接近的数之间的差值。例如，$Q = \{1, 5, 9, 15, 18, 22\}$，则 MIN-GAP 返回 $18 - 15 = 3$，因为 15 和 18 是 $Q$ 中两个最接近的数。要使得操作 INSERT、DELETE、SEARCH 和 MIN-GAP 尽可能高效，并分析它们的运行时间。

*14.3-7 VLSI 数据库通常将一块集成电路表示成一组矩形，假设每个矩形的边都平行于 $x$ 轴或者 $y$ 轴，这样可以用矩形的最小和最大的 $x$ 轴与 $y$ 轴坐标来表示一个矩形。请给出一个 $O(n \log n)$ 时间的算法，来确定 $n$ 个这种表示的矩形集合中是否存在两个重叠的矩形。你的算法不一定要输出所有重叠的矩形，但对于一个矩形完全覆盖另一个（即使边界线不相交），一定能给出正确的判断。（提示：移动一条“扫描”线，穿过所有的矩形。）

### 思考题

14-1 （最大重叠点）假设我们希望记录一个区间集合的最大重叠点（a point of maximum overlap），即被最多数目区间所覆盖的那个点。
a. 证明：最大重叠点一定是其中一个区间的端点。
b. 设计一个数据结构，使得它能够有效地支持 INTERVAL-INSERT、INTERVAL-DELETE，以及返回最大重叠点的 FIND-POM 操作。（提示：使红黑树记录所有的端点。左端点关联 +1 值，右端点关联 -1 值，并且给树中的每个结点扩张一个额外信息来维护最大重叠点。）

14-2 （Josephus 排列）定义 Josephus 问题如下：假设 $n$ 个人围成一个圆圈，给定一个正整数 $m$ 且 $m \leq n$。从某个指定的人开始，沿环将遇到的每第 $m$ 个人移出队伍。每个人移出之后，继续沿环数剩下来的人。这个过程直到所有的 $n$ 个人都被移出后结束。每个人移出的次序定义了一个来自整数 1, 2, …, $n$ 的 $(n, m)$-Josephus 排列。例如，$(7, 3)$-Josephus 排列为 (3, 6, 2, 7, 5, 1, 4)。
a. 假设 $m$ 是常数，描述一个 $O(n)$ 时间的算法，使得对于给定的 $n$，能够输出 $(n, m)$-Josephus 排列。
b. 假设 $m$ 不是常数，描述一个 $O(n \log n)$ 时间的算法，使得对于给定的 $n$，能够输出 $(n, m)$-Josephus 排列。















































































































































































































