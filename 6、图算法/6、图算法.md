# 第六部分 图算法

## 第二十二章 基本的图算法

### 练习 22.1

22.1-1 给定有向图的邻接链表，需要多长时间才能计算出每个结点的出度（发出的边的条数）？多长时间才能计算出每个结点的入度（进入的边的条数）？

22.1-2 给定一棵有 7 个结点的完全二叉树的邻接链表，请给出等价的邻接矩阵表示。这里假设结点的编号为从 1~7。

22.1-3 有向图 $$G = (V, E)$$ 的转置是图 $$G^T = (V, E^T)$$，这里 $$E^T = \{(v, u) \in V \times V: (u, v) \in E\}$$。因此，图 $$G^T$$ 就是将有向图 G 中所有边的方向反过来而形成的图。对于邻接链表和邻接矩阵两种表示，请给出从图 G 计算出 $$G^T$$ 的有效算法，并分析算法的运行时间。

22.1-4 给定多图 $$G = (V, E)$$ 的邻接链表（多图是允许重复边和自循环边的图），请给出一个时间为 $$O(V + E)$$ 的算法，用来计算该图的“等价”无向图 $$G' = (V, E')$$ 的邻接链表表示。这里 $$E'$$ 是将 E 中的冗余边和自循环边删除后余下的边。删除冗余边指的是将两个结点之间的多条边替换为一条边。

22.1-5 有向图 $$G = (V, E)$$ 的平方图是图 $$G^2 = (V, E^2)$$，这里，边 $$(u, v) \in E^2$$ 当且仅当图 G 包含一条最多由两条边构成的从 u 到 v 的路径。请给出一个有效算法来计算图 G 的平方图 $$G^2$$。这里图 G 既可以以邻接链表表示，也可以以邻接矩阵表示。请分析算法的运行时间。

22.1-6 多数以邻接矩阵作为输入的图算法的运行时间为 $$O(V^2)$$，但也有例外。给定图 G 的邻接矩阵表示，请给出一个 $$O(V)$$ 时间的算法来判断有向图 G 是否存在一个通用汇点（universal sink）。通用汇点指的是入度为 $$|V| - 1$$ 但出度为 0 的结点。

22.1-7 有向无环图 $$G = (V, E)$$ 的关联矩阵（incidence matrix）是一个满足下述条件的 $$|V| \times |E|$$ 矩阵 $$B = (b_{ij})$$：

$$
b_{ij} = 
\begin{cases} 
-1 & \text{如果边 } j \text{ 从结点 } i \text{ 发出} \\
1 & \text{如果边 } j \text{ 进入结点 } i \\
0 & \text{其他}
\end{cases}
$$

请说明矩阵乘积 $$BB^T$$ 里的每一个元素代表什么意思。这里 $$B^T$$ 是矩阵 B 的转置。

22.1-8 假定数组 $$Adj[u]$$ 的每个记录项不是链表，而是一个散列表，里面包含的是 $$(u, v) \in E$$ 的结点 v。如果每条边被查询的概率相同，则判断一条边是否在图中的期望时间值是多少？这种表示方式的缺陷是什么？请为每条边链表给出一个不同的数据结构来解决这个问题。与散列表相比较，你所给出的新方法存在什么缺陷吗？

### 练习 22.2

22.2-1 请计算出在有向图 22-2(a)上运行广度优先搜索算法后的 d 值和 $$\pi$$ 值。这里假定结点 3 为算法所用的源结点。

22.2-2 请计算出在图 22-3 所示无向图上运行广度优先搜索算法后的 d 值和 $$\pi$$ 值。这里假定结点 u 为算法所用的源结点。

22.2-3 证明：使用单个位来存放每个结点的颜色即可。这个论点可以通过证明将算法第 18 行的伪代码删除后，BFS 过程生成的结果不变来得到。

22.2-4 如果将输入的图用邻接矩阵来表示，并修改算法来应对此种形式的输入，请问 BFS 的运行时间将是多少？

22.2-5 证明：在广度优先搜索算法里，赋给结点 u 的 u. d 值与结点在邻接链表里出现的次序无关。使用图 22-3 作为例子，证明：BFS 所计算出的广度优先树可以因邻接链表中的次序不同而不同。

22.2-6 举出一个有向图 $$G = (V, E)$$ 的例子，对于源结点 $$s \in V$$ 和一组树边 $$E_r \subseteq E$$，使得对于每个结点 $$v \in V$$，图(V, $$E_x$$)中从源结点 s 到结点 v 的唯一简单路径也是图 G 中的一条最短路径，但是，不管邻接链表里结点之间的次序如何，边集 $$E_r$$ 都不能通过在图 G 上运行 BFS 来获得。

22.2-7 职业摔跤手可以分为两种类型：“娃娃脸”(“好人”)型和“高跟鞋”(“坏人”)型。在任意一对职业摔跤手之间都有可能存在竞争关系。假定有 n 个职业摔跤手，并且有一个给出竞争关系的 r 对摔跤手的链表。请给出一个时间为 $$O(n + r)$$ 的算法来判断是否可以将某些摔跤手划分为“娃娃脸”型，而剩下的划分为“高跟鞋”型，使得所有的竞争关系均只存在于娃娃脸型和高跟鞋型选手之间。如果可以进行这种划分，则算法还应当生成一种这样的划分。

*22.2-8 我们将一棵树 $$T = (V, E)$$ 的直径定义为 $$\max_{u, v \in V} d(u, v)$$，也就是说，树中所有最短路径距离的最大值即为树的直径。请给出一个有效算法来计算树的直径，并分析算法的运行时间。

22.2-9 设 $$G = (V, E)$$ 为一个连通无向图。请给出一个 $$O(V + E)$$ 时间的算法来计算图 G 中的一条这样的路径：该路径正反向通过 E 中每条边恰好一次(该路径通过每条边两次，但这两次的方向相反)。如果给你大量的分币作为奖励，请描述如何在迷宫中找出一条路。

### 练习 22.3

22.3-1 画一个 3×3 的网格，行和列的抬头分别标记为白色、灰色和黑色。对于每个表单元 $(i, j)$，请指出在对有向图进行深度优先搜索的过程中，是否可能存在一条边，连接一个颜色为 $i$ 的结点和一个颜色为 $j$ 的结点。对于每种可能的边，指明该种边的类型。另外，请针对无向图的深度优先搜索再制作一张这样的网格。

22.3-2 给出深度优先搜索算法在图 22-6 上的运行过程。假定深度优先搜索算法的第 5~7 行的 for 循环是以字母表顺序依次处理每个结点，并假定每条邻接链表皆以字母表顺序对里面的结点进行了排序。请给出每个结点的发现时间和完成时间，并给出每条边的分类。

![image-20250119115305534](F:\software\Typora\images\image-20250119115305534.png)

22.3-3 给出图 22-4 的深度优先搜索的括号化结构。

22.3-4 证明：使用单个位来存放每个结点的颜色已经足够。这一点可以通过证明如下事实来得到：如果将 DFS-VISIT 的第 2 行删除，DFS 给出的结果相同。

22.3-5 证明边 (u, v) 是：
		a. 树边或前向边当且仅当 $$u.d < v.d < v.f < u.f$$。
		b. 后向边当且仅当 $$v.d \leqslant u.d < u.f \leqslant v.f$$。
		c. 横向边当且仅当 $$v.d < v.f < u.d < u.f$$。

22.3-6 证明：在无向图中，根据深度优先搜索算法是先探索 (u, v) 还是先探索 (v, u) 来将边 (u, v) 分类为树边或者后向边，与根据分类列表中的 4 种类型的次序进行分类是等价的。

22.3-7 请重写 DFS 算法的伪代码，以便使用栈来消除递归调用。

22.3-8 请给出如下猜想的一个反例：如果有向图 G 包含一条从结点 u 到结点 v 的路径，并且在对图 G 进行深度优先搜索时有 $$u.d < v.d$$，则结点 v 是结点 u 在深度优先森林中的一个后代。

22.3-9 请给出如下猜想的一个反例：如果有向图 G 包含一条从结点 u 到结点 v 的路径，则任何对图 G 的深度优先搜索都将导致 $$v.d \leqslant u.f$$。

22.3-10 修改深度优先搜索的伪代码，让其打印出有向图 G 的每条边及其分类。并指出，如果图 G 是无向图，要进行何种修改才能达到相同的效果。

22.3-11 请解释有向图的一个结点 u 怎样才能成为深度优先树中的唯一结点，即使结点 u 同时有人边和出边。

22.3-12 证明：我们可以在无向图 G 上使用深度优先搜索来获得图 G 的连通分量，并且深度优先森林所包含的树的棵数与 G 的连通分量数量相同。更准确地说，请给出如何修改深度优先搜索来让其给每个结点赋予一个介于 1 和 k 之间的整数值 v.cc，这里 k 是 G 的连通分量数，使得 $$u.cc = v.cc$$ 当且仅当结点 u 和结点 v 处于同一个连通分量中。

*22.3-13 对于有向图 $$G = (V, E)$$ 来说，如果 $$u \sim v$$ 意味着图 G 至多包含一条从 u 到 v 的简单路径，则图 G 是单连通图 (singly connected)。请给出一个有效算法来判断一个有向图是否是单连通图。

### 练习 22.4

22.4-1 给出算法 TOPOLOGICAL-SORT 运行于图 22-8 上时所生成的结点次序。这里的所有假设与练习 22.3-2 一样。

![image-20250119115631719](F:\software\Typora\images\image-20250119115631719.png)

22.4-2 请给出一个线性时间的算法，算法的输入为一个有向无环图 $$G = (V, E)$$ 以及两个结点 s 和 t，算法的输出是从结点 s 到结点 t 之间的简单路径的数量。例如，对于图 22-8 所示的有向无环图，从结点 p 到结点 v 一共有 4 条简单路径，分别是 pov、poryv、posryv 和 psryv。（本题仅要求计数简单路径的条数，而不要求将简单路径本身列举出来。）

22.4-3 给出一个算法来判断给定无向图 $$G = (V, E)$$ 是否包含一个环路。算法运行时间应该在 $$O(V)$$ 数量级，且与 $$|E|$$ 无关。

22.4-4 证明或反证下述论断：如果有向图 G 包含环路，则在算法 TOPOLOGICAL-SORT(G) 所生成的结点序列里，图 G 中与所生成序列不一致的“坏”边的条数最少。

22.4-5 在有向无环图 $$G = (V, E)$$ 上执行拓扑排序还有一种办法，就是重复寻找入度为 0 的结点，输出该结点，将该结点及从其发出的边从图中删除。请解释如何在 $$O(V + E)$$ 的时间内实现这种思想。如果图 G 包含环路，将会发生什么情况？

### 练习 22.5

22.5-1 如果在图 G 中加入一条新的边，G 中的强连通分量的数量会发生怎样的变化？

22.5-2 给出算法 STRONGLY-CONNECTED-COMPONENTS 在图 22-6 上的运行过程。具体要求是，给出算法第 1 行所计算出的完成时间和第 3 行所生成的森林，假定 DFS 的第 5~7 行的循环是以字母表顺序来对结点进行处理，并且连接链表中的结点也是以字母表顺序排列好的。

22.5-3 Bacon 教授声称，如果在第二次深度优先搜索时使用原始图 G 而不是图 G 的转置图 $$G^T$$，并且以完成时间的递增次序来扫描结点，则计算强连通分量的算法将会更加简单。这个更加简单的算法总是能计算出正确的结果吗？

22.5-4 证明：对于任意有向图 G 来说，$$\left(\left(G^{\prime}\right)^{\text{SCC}}\right)^{T}=G^{\text{SCC}}$$，也就是说，转置图 $$G^{\prime}$$ 的分量图的转置与图 G 的分量图相同。

22.5-5 给出一个时间复杂度为 $$O(V+E)$$ 的算法来计算有向图 $$G=(V, E)$$ 的分量图，请确保在算法所生成的分量图中，任意两个结点之间至多存在一条边。

22.5-6 给定有向图 $$G=(V, E)$$。请说明如何创建另一个图 $$G^{\prime}=(V, E^{\prime})$$，使得：(a) $$G^{\prime}$$ 的强连通分量与 G 的相同，(b) G' 的分量图与 G 的相同，以及 (c) $$E^{\prime}$$ 所包含的边尽可能少。请给出一个计算图 $$G^{\prime}$$ 的快速算法。

22.5-7 给定有向图 $$G=(V, E)$$，如果对于所有结点对 $$u, v \in V$$，我们有 $$u \sim \rightarrow v$$ 或 $$v \sim \rightarrow u$$，则 $$G^{\prime}$$ 是半连通的。请给出一个有效的算法来判断图 G 是否是半连通的。证明算法的正确性并分析其运行时间。

### 思考题

22-1 (以广度优先搜索来对圆的边进行分类) 深度优先搜索将图中的边分类为树边、后向边、前向边和横向边。广度优先搜索也可以用来进行这种分类。具体来说，广度优先搜索将从源结点可以到达的边划分为同样的 4 种类型。

a. 证明在对无向图进行的广度优先搜索中，下面的性质成立：
1. 不存在后向边，也不存在前向边。
2. 对于每条树边 (u, v)，我们有 $$u.d = u.d + 1$$。
3. 对于每条横向边 (u, v)，我们有 $$v.d = u.d$$ 或 $$v.d = u.d + 1$$。

b. 证明在对有向图进行广度优先搜索时，下面的性质成立：
1. 不存在前向边。
2. 对于每条树边 (u, v)，我们有 $$u.d = u.d + 1$$，
3. 对于每条横向边 (u, v)，我们有 $$u.d \leqslant u.d + 1$$。
4. 对于每条后向边 (u, v)，我们有 $$0 \leqslant u.d \leqslant u.d$$，

22-2 (衔接点、桥和双连通分量) 设 $$G=(V, E)$$ 为一个连通无向图，图 G 的衔接点是指图 G 中的一个结点，删除该结点将导致图不连通，图 G 的桥是指图中的一条边，删除该条边，图就不再连通，图 G 的双连通分量是指一个最大的边集合，里面的任意两条边都处于同一条简单环路中。图 22-10 描述的就是这些概念的定义。我们可以使用深度优先搜索算法来判断图 G 的衔接点、桥和双连通分量。设 $$G_{\pi}=(V, E_{\pi})$$ 为图 G 的深度优先树。

![image-20250119120316490](F:\software\Typora\images\image-20250119120316490.png)

a. 证明：$G_{\pi}$ 的根结点是图 G 的衔接点当且仅当它在 $G_{\pi}$ 中至少有两个子结点。

b. 设结点 v 为 G 的一个非根结点。证明：是 G 的衔接点当且仅当结点 v 有一个子结点 s，且没有任何从结点 s 或任何 s 的后代结点指向 v 的真祖先的后向边。

c. 定义
$$
v.low = \min \begin{cases} 
v.d \\
w.d: (u, w) \text{ 是结点 } v \text{ 的某个后代结点 } u \text{ 的一条后向边}
\end{cases}
$$
请说明如何在 $$O(E)$$ 的时间内为所有结点 $v$ 计算出 $v.low$ 的值。

d. 说明如何在 $$O(E)$$ 时间内计算出图 $G$ 的所有衔接点。

e. 证明：图 $G$ 的一条边是桥当且仅当该边不属于 $G$ 中的任何简单环路。

f. 说明如何在 $$O(E)$$ 时间内计算出图 $G$ 的所有桥。

g. 证明：G 的双连通分量是 $G$ 的非桥边的一个划分。

h. 给出一个 $$O(E)$$ 时间复杂度的算法来给图 $G$ 的每条边 $e$ 做出标记。这个标记是一个正整数 $e.bcc$ 且满足 $e.bcc = e'.bcc$ 当且仅当边 $e$ 和边 $e'$ 在同一个双连通分量中。

22-3 (欧拉回路) 强连通有向图 $$G=(V, E)$$ 中的一个欧拉回路是指一条遍历图 G 中每条边恰好一次的环路。不过，这条环路可以多次访问同一个结点。

a. 证明：图 G 有一条欧拉回路当且仅当对于图中的每个结点 v，有 in-degree(v) = out-degree(v).

b. 给出一个复杂度为 $$O(E)$$ 的算法来找出图 G 的一条欧拉回路。（提示：对边不相交环路进行归并。）

22-4 (可到达性) 设 $$G=(V, E)$$ 为一个有向图，且每个结点 $$u \in V$$ 都标有一个唯一的整数值标记 $$L(u)$$，$$L(u)$$ 的取值为集合 $\{1, 2, ..., |V|\}$。对于每个结点 $$u \in V$$，设 $$R(u) = \{v \in V : u \sim \rightarrow v\}$$ 为从结点 $u$ 可以到达的所有结点的集合。定义 $$\min(u)$$ 为 $$R(u)$$ 中标记为最小的结点，即 $$\min(u)$$ 为结点 v，满足 $$L(v) = \min(L(w) : w \in R(u))$$，请给出一个时间复杂度为 $$O(V+E)$$ 的算法来计算所有结点 $$u \in V$$ 的 $min(u)$。



## 第二十三章 最小生成树

### 练习 23.1

23.1-1 设 (u, v) 是连通图 G 中的一条权重最小的边，证明：边 (u, v) 为图 G 的某棵最小生成树中的一条边。

23.1-2 Sabatier 教授猜想出了定理 23.1 的一个逆定理如下：设 $$G=(V, E)$$ 是一个连通无向图，并有定义在边集合 E 上的实数值权重函数 w。设集合 A 为 E 的一个子集，该子集包含在图 G 的某个最小生成树中。又设 (S, V-S) 为 G 中任意尊重集合 A 的一个切割，边 (u, v) 是一条横跨切割 (S, V-S) 且对于集合 A 安全的边。那么边 (u, v) 是该切割的一条轻量级边。请通过举出反例来证明 Sabatier 教授的猜想是不正确的。

23.1-3 证明：如果图 G 的一条边 (u, v) 包含在图 G 的某棵最小生成树中，则该条边是横跨图 G 的某个切割的一条轻量级边。

23.1-4 给出一个连通图的例子，使得边集合 $$\{(u, v) : \text{存在一个切割} (S, V-S), \text{使得} (u, v) \text{是横跨该切割的一条轻量级边}\}$$ 不形成一棵最小生成树。

23.1-5 设 e 为连通图 $$G=(V, E)$$ 的某条环路上权重最大的边。证明：图 $$G'=(V, E-\{e\})$$ 中存在一棵最小生成树，它也同时是 G 的最小生成树。也就是说，图 G 中存在一棵不包含边 e 的最小生成树。

23.1-6 证明：如果对于图的每个切割，都存在一条横跨该切割的唯一的轻量级边，则该图存在一棵唯一的最小生成树。并通过举出反例来证明其逆论断不成立。

23.1-7 证明：如果一个图的所有边的权重都是正值，则任意一个连接所有结点且总权重最小的一个边集合必然形成一棵树。另外，请举出例子来证明：如果允许某些边的权重为负值，则该论断不成立。

23.1-8 设 T 为图 G 的一棵最小生成树，设 L 为树 T 中一个边权重的有序列表。证明：对于图 G 的任何其他最小生成树 $$T'$$，列表 L 也是 $$T'$$ 中一个边权重的有序列表。

23.1-9 设 T 为 $$G=(V, E)$$ 的一棵最小生成树，设 $$V'$$ 为 V 的一个子集。设 $$T'$$ 为由 $$V'$$ 所诱导的 T 的子图，设 $$G'$$ 为由 $$V'$$ 诱导的 G 的子图。证明：如果 $$T'$$ 是连通的，则 $$T'$$ 是 $$G'$$ 的一棵最小生成树。

23.1-10 给定图 G 和 G 的一棵最小生成树 T，假设减小了 T 中一条边的权重。证明：T 仍然是 G 的一棵最小生成树。更形式化地，设 T 为 G 的一棵最小生成树，G 的边权重由权重函数 w 给出。选择一条边 $$(x, y) \in T$$ 和一个正数 k，并定义下述的权重函数 $$w'$$：

$$
w'(u, v) = 
\begin{cases} 
w(u, v) & \text{若 } (u, v) \neq (x, y) \\
w(x, y) - k & \text{若 } (u, v) = (x, y)
\end{cases}
$$

证明：T 仍然是 G 的一棵最小生成树，这里 G 的边权重由函数 $$w'$$ 给出。

*23.1-11 给定图 $G$ 和一棵最小生成树 $T$, 假设减小了位于 $T$ 之外的某条边的权重。请给出一个在修改后的图中寻找最小生成树的算法。



### 练习

23.2-1 对于同一个输入图，Kruskal 算法返回的最小生成树可以不同。这种不同来源于对边进行排序时，对权重相同的边进行的不同处理。证明：对于图 G 的每棵最小生成树 T，都存在一种办法来对 G 的边进行排序，使得 Kruskal 算法所返回的最小生成树就是 T。

23.2-2 假定我们用邻接矩阵来表示图 $$G=(V, E)$$，请给出 Prim 算法的一种简单实现，使其运行时间为 $$O(V^3)$$。

23.2-3 对于稀疏图 $$G=(V, E)$$。这里 $$|E|=\theta(V)$$。使用斐波那契堆实现的 Prim 算法是否比使用二叉堆实现的算法更快？对于稠密图又如何呢？$$|E|$$ 和 $$|V|$$ 必须具备何种关系才能使斐波那契堆的实现在渐近级别上比二叉堆的实现更快？

23.2-4 假定图中的边权重全部为整数，且在范围 $$1\sim|V|$$ 内，在此种情况下，Kruskal 算法最快能多快？如果边的权重取值范围在 1 到某个常数 W 之间呢？

23.2-5 假定图中边的权重取值全部为整数，且在范围 $$1\sim|V|$$ 内。Prim 算法最快能多快？如果边的权重取值范围在 1 到某个常数 W 之间呢？

*23.2-6 假定一个图中所有的边权重均匀分布在半开区间 [0,1) 内。Prim 算法和 Kruskal 算法哪一个可以运行得更快？

*23.2-7 假定图 G 的一棵最小生成树已经被计算出来。如果在图中加入一个新结点及其相关的新边，我们需要多少时间来对最小生成树进行更新？

23.2-8 Borden 教授提出了一个新的分治算法来计算最小生成树。该算法的原理如下：给定图 $$G=(V, E)$$，将 V 划分为两个集合 $$V_1$$ 和 $$V_2$$，使得 $$|V_1|$$ 和 $$|V_2|$$ 的差最多为 1。设 $$E_1$$ 为端点全部在 $$V_1$$ 中的边的集合，$$E_2$$ 为端点全部在 $$V_2$$ 中的边的集合。我们递归地解决两个子图 $$G_1=(V_1, E_1)$$ 和 $$G_2=(V_2, E_2)$$ 的最小生成树问题。最后，在边集合 E 中选择横跨切割 $$V_1$$ 和 $$V_2$$ 的最小权重的边来将求出的两棵最小生成树连接起来，从而形成一棵最后的最小生成树。

请证明该算法能正确计算出一棵最小生成树，或者举出反例来说明该算法不正确。

### 思考题

23-1 (次优最小生成树) 设 $$G=(V, E)$$ 为一连通无向图，其权重函数为 $$w: E \rightarrow R$$，假定 $$|E|\geqslant |V|$$ 并且所有的权重都互不相同。我们定义一棵次优最小生成树如下：设 T 为 G 的所有生成树的集合。T' 为 G 的一棵最小生成树。那么次优最小生成树是生成树 T，其是 $$w(T)=\min_{T' \in T}(w(T'))$$。

a. 证明：最小生成树是唯一的，但次优最小生成树则不一定是唯一的。

b. 设 T 为 G 的一棵最小生成树。证明：图 G 包含边 $$(u, v) \in T$$ 和边 $$(x, y) \in T$$，使得 $$T-\{(u, v)\} \cup \{(x, y)\}$$ 是 G 的一棵次优最小生成树。

c. 设 T 为 G 的一棵最小生成树。对于任意两个结点 u, $$v \in V$$，设 $$\max[u, v]$$ 表示树 T 中从结点 u 到结点 v 的简单路径上最大权重的边，请给出一个 $$O(V^3)$$ 时间复杂度的算法来计算 $$\max[u, v]$$。

d. 给出一个有效算法来计算图 G 的次优最小生成树。

23-2 (稀疏图的最小生成树) 对于非常稀疏的图 $$G=(V, E)$$ 来说，我们可以对 Prim 算法进行进一步改善，改善后的时间将优于使用斐波那契堆时的 $$O(E + V \log V)$$ 的运行时间。改善所用的方法就是对图 G 进行预处理来减少结点的数量，然后在减少结点数量后的图 G 上运行 Prim 算法。具体来说，对于每个结点 w，我们选择与结点 w 邻接的边中最小权重的边 (u, v)，将其加入到正在构建的最小生成树里。然后对所有选择的边进行收缩（请参阅 B.4 节的内容）。不过，我们不是一条一条地收缩每条边，而是首先找出连接到同一个新结点的结点集合。然后创建一个新的图，这个新的图就如每次收缩这样一条边所得出的一样，但我们是通过“重新命名”来实现，重新命名是根据每条边的端点所在的结点集合来进行。原始图中的多条边可能被重命名为同样的名。在这种情况下，重名的边中只有一条边留下，这条边对应原始边中最小权重的边。

在初始时，我们把将要构建的最小生成树 T 设为空，对于每条边 $$(u, v) \in E$$，对其属性进行如下的初始化操作：$$(u, v)$$.orig = $$(u, v)$$，$$(u, v).c = w(u, v)$$，我们使用 orig 属性来引用原始图中与收缩后的图的边相关的边。属性 c 记录边的权重，随着边的收缩，我们根据上面选择边权重的方法来更新这个属性。下面的 MST-REDUCE 算法以图 G 和树 T 作为输入，返回一个收缩后的图 $$G'$$ 和更新后的属性 orig' 与 c'。该算法同时选出图 G 中的边来构成最小生成树 T。

![image-20250119122200445](F:\software\Typora\images\image-20250119122200445.png)

设 T 为算法 MST-REDUCE 所返回的边的集合，设 A 为调用 MST-Prim($$G'$$, c', r) 所生成的图 G' 的最小生成树，这里 $$c'$$ 是 $$G'.E$$ 中边的权重属性，r 是 $$G'.V$$ 中的任意结点。证明：$$T \cup ((z, y).\text{orig}': (z, y) \in A)$$ 是图 G 的一棵最小生成树。

b. 证明，$$|G'.V| \leqslant |V| / 2$$。

C. 使用本题(b)部分的算法，设计一个瓶颈生成树问题的线性时间算法，该算法将以(b)部分的算法作为子程序。（提示：考虑使用一个子程序来对边的集合进行收缩，就如思 考题 23-2 中所描述的 MST-REDUCE 算法一样。）

23-4 (第三种最小生成树算法) 在本题中，我们给出三种不同算法的伪代码。每种算法的输入都是一个连通图和一个权重函数，返回值都是一个边的集合 T。对于每种算法，要么证明 T 是一棵最小生成树，要么证明 T 不是一棵最小生成树。同时给出每种算法的最有效的实现（不管该算法是否能够计算出最小生成树）。

![image-20250119122512376](F:\software\Typora\images\image-20250119122512376.png)

## 第二十四章 单源最短路径

### 练习 24.1

24.1-1 在图 24-4 上运行 Bellman-Ford 算法，使用结点 z 作为源结点。在每一遍松弛过程中，以图中相同的次序对每条边进行松弛，给出每遍松弛操作后的 d 值和 $$\pi$$ 值。然后，把边 (z, x) 的权重改为 4，再次运行该算法，这次使用 s 作为源结点。

24.1-2 证明推论 24.3。

24.1-3 给定 $$G=(V, E)$$ 是一带权重且没有权重为负值的环路的有向图，对于所有结点 $$v \in V$$，从源结点 s 到结点 v 之间的最短路径中，包含边的条数的最大值为 m。（这里，判断最短路径的根据是权重，不是边的条数。）请对算法 BELLMAN-FORD 进行简单修改，可以让其在 m+1 遍松弛操作之后终止，即使 m 不是事先知道的一个数值。

24.1-4 修改 Bellman-Ford 算法，使其对于所有结点 v 来说，如果从源结点 s 到结点 v 的一条路径上存在权重为负值的环路，则将 v.d 的值设置为 $$-\infty$$。

*24.1-5 设 $$G=(V, E)$$ 为一带权重的有向图，其权重函数为 $$w: E \rightarrow R$$。请给出一个时间复杂度为 $$O(VE)$$ 的算法，对于每个结点 $$v \in V$$，计算出数值 $$\delta^*(v) = \min_{u \in V} \{\delta(u, v)\}$$。

*24.1-6 假定 $$G=(V, E)$$ 为一带权重的有向图，并且图中存在一个权重为负值的环路。给出一个有效的算法来列出所有属于该环路上的结点。请证明算法的正确性。

### 练习 24.2

24.2-1 请在图 24-5 上运行 DAG-SHORTEST-PATHS，使用结点 r 作为源结点。

24.2-2 假定将 DAG-SHORTEST-PATHS 的第 3 行改为：

3. for the first $$|V| - 1$$ vertices, taken in topologically sorted order
证明：该算法的正确性保持不变。

24.2-3 上面描述的 PERT 图的公式有一点不太自然。在一个更自然的结构下，图中的结点代表要执行的工作，边代表工作之间的次序限制，即边 (u, v) 表示工作 u 必须在工作 v 之前执行。在这种结构的图中，我们将权重赋给结点，而不是边。请修改 DAG-SHORTEST-PATHS 过程，使得其可以在线性时间内找出这种有向无环图中一条最长的路径。

24.2-4 给出一个有效的算法来计算一个有向无环图中的路径总数。分析你自己的算法。

### 练习 24.3

24.3-1 在图 24-2 上运行 Dijkstra 算法，第一次使用结点 s 作为源结点，第二次使用结点 z 作为源结点。以类似于图 24-6 的风格，给出每次 while 循环后的 d 值和 $$\pi$$ 值，以及集合 S 中的所有结点。

24.3-2 请举出一个包含负权重的有向图，使得 Dijkstra 算法在其上运行时将产生不正确的结果。为什么在有负权重的情况下，定理 24.6 的证明不能成立呢？

24.3-3 假定将 Dijkstra 算法的第 4 行改为：
4. while $$|Q| > 1$$
这种改变将让 while 循环的执行次数从 $$|V|$$ 次降低到 $$|V| - 1$$ 次。这样修改后的算法正确吗？

24.3-4 Gaedel 教授写了一个程序，他声称该程序实现了 Dijkstra 算法。对于每个结点 $$v \in V$$，该程序生成值 v.d 和 v. $$\pi$$。请给出一个时间复杂度为 $$O(V + E)$$ 的算法来检查教授所编写程序的输出。该算法应该判断每个结点的 d 和 $$\pi$$ 属性是否与某棵最短路径树中的信息匹配。这里可以假设所有的边权重皆为非负值。

24.3-5 Newman 教授觉得自己发现了 Dijkstra 算法的一个更简单的证明。他声称 Dijkstra 算法对最短路径上面的每条边的松弛次序与该条边在该条最短路径中的次序相同，因此，路径松弛性质适用于从源结点可以到达的所有结点。请构造一个有向图来说明 Dijkstra 算法并不一定按照最短路径中边的出现次序来对边进行松弛，从而证明教授是错的。

24.3-6 给定有向图 $$G = (V, E)$$，每条边 (u, v) ∈ E 有一个关联值 r(u, v)，该关联值是一个实数，其范围为 $$0 \leqslant r(u, v) \leqslant 1$$，其代表的意思是从结点 u 到结点 v 之间的通信链路的可靠性。可以认为，r(u, v) 代表的是从结点 u 到结点 v 的通信链路不失效的概率，并且假设这些概率之间相互独立。请给出一个有效的算法来找到任意两个结点之间最可靠的通信链路。

24.3-7 给定带权重的有向图 $$G = (V, E)$$，其权重函数为 $$w: E \rightarrow \{1, 2, \cdots, W\}$$，这里 W 为某个正整数，我们还假设图中从源结点 s 到任意两个结点之间的最短路径的权重都不相同。现在，假设定义一个没有权重的有向图 $$G' = (V \cup V', E')$$。该图是将每条边 (u, v) ∈ E 予以替换，替换所用的是 $$w(u, v)$$ 条具有单位权重的边。请问图 $$G'$$ 一共有多少个结点？现在假设在 $$G'$$ 上运行广度优先搜索算法，证明：$$G'$$ 的广度优先搜索将 V 中结点涂上黑色的次序与 Dijkstra 算法运行在图 G 上时从优先队列中抽取结点的次序相同。

24.3-8 给定带权重的有向图 $$G = (V, E)$$，其权重函数为 $$w: E \rightarrow \{0, 1, 2, \cdots, W\}$$，这里 W 为某个非负整数。请修改 Dijkstra 算法来计算从给定源结点 s 到所有结点之间的最短路径。该算法时间应为 $$O(WV + E)$$。

24.3-9 修改练习 24.3-8 中的算法，使其运行时间为 $$O((V + E) \log W)$$。（提示：在任意时刻，集合 V-S 里有多少个不同的最短路径估计？）

24.3-10 假设给定带权重的有向图 $$G = (V, E)$$，从源结点 s 发出的边的权重可以为负值，而其他所有边的权重全部是非负值，同时，图中不包含权重为负值的环路。证明：Dijkstra 算法可以正确计算出从源结点 s 到所有其他结点之间的最短路径。

### 练习 24.4

24.4-1 请给出下面差分约束系统的可行解或证明该系统没有可行解。
$$
\begin{align*}
& x_1 - x_2 \leqslant 1 \\
& x_1 - x_4 \leqslant -4 \\
& x_2 - x_3 \leqslant 2 \\
& x_2 - x_5 \leqslant 7 \\
& x_2 - x_6 \leqslant 5 \\
& x_3 - x_6 \leqslant 10 \\
& x_4 - x_2 \leqslant 2 \\
& x_5 - x_1 \leqslant -1 \\
& x_5 - x_4 \leqslant 3 \\
& x_6 - x_3 \leqslant -8
\end{align*}
$$

24.4-2 请给出下面差分约束系统的可行解或证明该系统没有可行解。
$$
\begin{align*}
& x_1 - x_2 \leqslant 4 \\
& x_1 - x_3 \leqslant 5 \\
& x_2 - x_4 \leqslant -6 \\
& x_3 - x_2 \leqslant 1 \\
& x_4 - x_1 \leqslant 3 \\
& x_4 - x_3 \leqslant 5 \\
& x_4 - x_5 \leqslant 10 \\
& x_3 - x_3 \leqslant -4 \\
& x_5 - x_4 \leqslant -8
\end{align*}
$$

24.4-3 约束图中从新结点 $$v_0$$ 到其他结点之间的最短路径权重能够为正值吗？请解释。

24.4-4 请将单源单目的地最短路径问题表示为一个线性规划问题。

24.4-5 请稍微修改 Bellman-Ford 算法，使其能够在 $$O(nm)$$ 时间内解决由 n 个未知变量和 m 个约束条件所构成的差分约束系统问题。

24.4-6 假定在除差分约束系统外，我们希望处理形式为 $$x_i = x_j + b_k$$ 的相等约束。请说明如何修改 Bellman-Ford 算法来解决这种约束系统。

24.4-7 说明如何在一个没有额外结点 $$v_0$$ 的约束图上运行类似 Bellman-Ford 的算法来求解差分约束系统。

*24.4-8 设 $$A x \leqslant b$$ 为一个有 n 个变量和 m 个约束条件的差分约束系统。证明：在对应的约束图上运行 Bellman-Ford 算法将获得 $$\sum_{i=1}^{n} x_i$$ 的最大值，这里 $$A x \leqslant b$$ 并且 $$x_i \leqslant 0$$。

*24.4-9 设 $$A x \leqslant b$$ 为一个有 n 个变量和 m 个约束条件的差分约束系统。证明：在对应的约束图上运行 Bellman-Ford 算法将获得 $$(\max\{x_i\} - \min\{x_i\})$$ 的最小值，这里 $$A x \leqslant b$$。如果该算法被用于安排建设工程的进度，请说明如何应用上述事实。

24.4-10 假定线性规划问题 $$A x \leqslant b$$ 的矩阵 A 中每一行对应一个约束条件，具体来说，对应的是一个形式为 $$x_i \leqslant b_i$$ 的单个变量的约束条件，或一个形式为 $$-x_i \leqslant b_i$$ 的单变量约束条件。请说明如何修改 Bellman-Ford 算法来解决这变差分约束系统问题。

24.4-11 给出一个有效算法来解决 $$A x \leqslant b$$ 的差分约束系统问题，这里 b 的所有元素为实数，所有的变量 $$x_i$$ 都是整数。

*24.4-12 给出一个有效算法来解决 $$A x \leqslant b$$ 的差分约束系统，这里 b 的所有元素为实数，而变量 $$x_i$$ 中某个给定的子集是整数。

### 练习

24.5-1 给出图 24-2 的与图中两棵最短路径树不同的另外两棵最短路径树。

24.5-2 设 $$G=(V, E)$$ 为一个带权重的有向图，权重函数为 $$w: E \rightarrow R$$。设 $$s \in V$$ 为某个源结点。请举出一个例子，使得图 G 满足下列条件：对于每条边 (u, v) ∈ E，存在一棵根结点为 s 的包含边 (u, v) 的最短路径树，也包含一棵根结点为 s 的不包含边 (u, v) 的最短路径树。

24.5-3 对引理 24.10 的证明进行改善，使其可以处理最短路径权重为 $$\infty$$ 和 $$-\infty$$ 的情况。

24.5-4 设 $$G=(V, E)$$ 为一个带权重的有向图，权重函数为 $$w: E \rightarrow R$$。假设调用 INITIALIZE-SINGLE-SOURCE(G, s) 算法对图 G 进行初始化。证明：如果一系列松弛操作将 s.$\pi$ 的值设置为一个非空值，则图 G 包含一个权重为负值的环路。

24.5-5 设 $$G=(V, E)$$ 为一个带权重的、无负值环路的有向图。设 $$s \in V$$ 为源结点，对于结点 $v ∈ V - {s}$，如果结点 v 可以从源结点 s 到达，我们允许 $$\pi$$ 在任一条最短路径上的前驱，如果结点 v 不可以从源结点 s 到达，则 $$v.\pi$$ 为 NIL。请举出一个图例和一种 $$\pi$$ 的赋值，使得 $G$ 中形成一条环路。（根据引理 24.16，这样的一种赋值不可能由一系列松弛操作生成。）

24.5-6 设 $$G=(V, E)$$ 为一个带权重的有向图，权重函数为 $$w: E \rightarrow R$$，且不包含权重为负值的环路。设 s ∈ V 为源结点，假定图 G 由 $INITIALIZE-SINGLE-SOURCE(G, s)$ 算法进行初始化。证明：对于任意结点 $v ∈ V$，$G$ 中存在一条从源结点 s 到结点 v 的路径，并且该性质在任何松弛操作序列中维持为不变式。

24.5-7 设 $$G=(V, E)$$ 为一个带权重的有向图，且不包含权重为负值的边。设 s ∈ V 为源结点，假定图 G 由 INITIALIZE-SINGLE-SOURCE(G, s) 算法进行初始化。证明：对于所有结点 v ∈ V，存在一个由 |V| - 个松弛步骤所组成的松弛序列生成 $$\delta(s, v)$$。

24.5-8 设 $$G=(V, E)$$ 为一个带权重的有向图，且包含一个可以从源结点 s 到达的权重为负值的环路。请说明如何构造一个 G 的松弛操作的无限序列，使得每一步松弛操作都能对某一个最短路径估计值进行更新。

### 思考题

24-1 (Yen 对 Bellman-Ford 算法的改进) 假定对 Bellman-Ford 算法中对边的每一遍松弛操作的次序做出如下规定：在第一遍松弛前，我们给输入图 $$G=(V, E)$$ 的所有结点赋予一个随机的线性次序 $$v_1, v_2, \cdots, v_{|V|}$$。然后，将边集合 E 划分为 $$E_1 \cup E_2, \cdots, \cup E_k$$，这里 $$E_i = \{(u_i, v_i) \in E : i < j\}$$，$$E_k = \{(u_k, v_k) \in E : j > i\}$$。（假定图 G 不包含自循环，因此一条边要么属于 $E_i$，要么属于 $E_{i+1}$。）定义 $$G_j = (V, E_j)$$ 和 $$G_k = (V, E_k)$$。证明：$G_k$ 是无环的，且其拓扑排序为 $$v_1, v_2, \cdots, v_{|V|}$$；$G_i$ 是有环的，且其拓扑排序为 $$v_{|V|}, v_{|V|-1}, \cdots, v_i$$。

假定我们用下面的方式来实现 Bellman-Ford 算法的每一遍松弛操作：以 $$v_1, v_2, \cdots, v_{|V|}$$ 的次序访问每个结点，并从每个结点发出的 $$\delta_i$$ 边进行松弛。然后，再以次序 $$v_{|V|}, v_{|V|-1}, \cdots, v_1$$ 来访问每个结点，并从每个结点发出的 $$\delta_i$$ 边进行松弛。

a. 证明：在上述操作方式下，如果图 G 不包含从源结点 s 可以到达的权重为负值的环路，则在 $$|V|$$ 次松弛操作后，对于所有的结点 v ∈ V，有 $$v.d = \delta(s, v)$$。

b. 上述算法是否改善了 Bellman-Ford 算法的运行时间？

24-2 (嵌套盒子) 假定有很多维度为 $d$ 的盒子，对于盒子 $x = (x_1, x_2, \cdots, x_d)$ 和 $y = (y_1, y_2, \cdots, y_d)$ 的两个盒子来说，如果集合 $\{1, 2, \cdots, d\}$ 存在一个排列 $$\pi$$，使得 $$x_{\pi(1)} \leqslant y_1, x_{\pi(2)} \leqslant y_2, \cdots, x_{\pi(d)} \leqslant y_d$$，则称盒子 $x$ 嵌套在盒子 $y$ 里面。

a. 证明：嵌套关系是传递的。

b. 给出一个有效算法来判断一个维度为 d 的盒子是否嵌套在另一个同样维度的盒子里。

c. 假定有一组 n 个 d 维的盒子 $$<B_1, B_2, \cdots, B_n>$$。请给出一个有效算法来找出最长的盒子序列 $$(B_{i_1}, B_{i_2}, \cdots, B_{i_k})$$，使得盒子 $$B_{i_j}$$ 嵌套在盒子 $$B_{i_{j+1}}$$ 里，这里 $$j = 1, 2, \cdots, k - 1$$。请以 $d$ 和 $n$ 来表述算法的运行时间。

24.3 （套利交易）套利交易指的是使用货币汇率之间的差异来将一个单位的货币转换为多于一个单位的同种货币的行为。例如，假定 1 美元可以购买 49 印度卢比，1 印度卢比可以购买 2 日元，1 日元可以购买 0.0107 美元。那么通过在货币之间进行转换，一个交易商可以从 1 美元开始，购买 49 × 2 × 0.0107 = 1.0486 美元，从而获得 4.86% 的利润。

假设给定 n 种货币 $$c_1, c_2, \cdots, c_n$$ 和一个 n × n 的汇率表 R，一个单位的 $$c_i$$ 货币可以购买 R[i, j] 单位的 $$c_j$$ 货币。

a. 给出一个有效算法来判断是否存在一个货币序列 $$(c_{i_1}, c_{i_2}, \cdots, c_{i_k})$$，使得 
$$
R[i_1, i_2] \cdot R[i_2, i_3] \cdot \cdots \cdot R[i_{k-1}, i_k] > 1
$$
请分析算法的运行时间。

b. 给出一个有效算法来打印出这样的一个序列（如果存在这样一种序列）。分析算法的运行时间。

24-4 (Gabow 的单源最短路径伸缩算法) 伸缩算法解决问题的方式如下：首先考虑相关输入值（如边的权重）的最高有效位，然后通过检查最高两个有效位来对初始解进行微调。这种算法每次检查更多的最高有效位，每次对解进行微调，直到对所有输入位进行检查并计算出正确解为止。

在本题中，我们通过对边的权重进行伸缩来计算单源最短路径。给定有向图 G=(V, E)。图的所有边的权重皆为非负整数 $$w_e$$。我们的目标是设计一个运行时间为 $$O(E \log W)$$ 的算法来计算最短路径。假设所有结点都可以从源结点到达。

该算法对边权重的二进制表示进行逐位检查，从最高有效位到最低有效位。具体来说，设 $$k = \lceil \log(W + 1) \rceil$$ W 的二进制表示所需要的位数，并且对于 $$i = 1, 2, \cdots, k$$，设 $$w_i(u, v) = \lfloor w(u, v) / 2^{i-1} \rfloor$$。也就是说，$$w_i(u, v)$$ 是由 $w(u, v)$ 的第 i 个最高有效位给出的“收缩”的 $$w(u, v)$$ 版本。（因此，对于所有边 (u, v) ∈ E，有 $$w_k(u, v) = w(u, v)$$。）例如，如果 k = 5，并且 (u, v) = (25, 4)，其二进制表示为 (11001)，则 $$w_2(u, v) = (110) = 6$$。又例如，如果 $$w_3(u, v) = (00100) = 4$$，则 $$w_2(u, v) = (001) = 1$$。定 $$\delta_i(u, v)$$ 为使用权重函数 $$w_i$$ 的情况下从结点 u 到结点 v 的最短路径权重，则对于所有的结点 u, v ∈ V，有 $$\delta_i(u, v) = \delta(u, v)$$。对于给定源结点 s，该伸缩算法首先计算出对于所有结点 u ∈ V 的所有最短路径权重 $\delta_i(s, v)$，然后再计算出 $$\delta(s, v)$$，这样一直下去，直到计算出 $$\delta(s, v)$$。假定 |E| ≥ |V| - 1，我们将看到从 $$\delta_{i-1}$$ 计算出 $$\delta_i$$ 所需要的时间为 $$O(E)$$，因此，整个算法的运行时间为 $$O(kE) = O(E \log W)$$。

a. 假定对于所有的结点 $v ∈ V$，有 $$\delta_i(s, v) \leqslant |E|$$。证明：可以在 $$O(E)$$ 的时间内计算出所有的 $$\delta_i(s, v)$$。

b. 证明：可以在 $$O(E)$$ 时间内计算出所有的 $$\delta_i(s, v)$$。

c. 证明：对于 $i = 2, 3, \cdots, k$，要么有 $$w_i(u, v) = 2w_{i-1}(u, v)$$，要么有 $$w_i(u, v) = 2w_{i-1}(u, v) + 1$$。然后再证明：对于所有的结点 $v ∈ V$，
$$
2\delta_{i-1}(s, v) \leqslant \delta_i(s, v) \leqslant 2\delta_{i-1}(s, v) + |V| - 1
$$
d. 对于所有的 $(u, v) ∈ E$ 和 $i = 2, 3, \cdots, k$，定义

$$
\hat{w}_i(u, v) = w_i(u, v) + 2\delta_{i-1}(s, u) - 2\delta_{i-1}(s, v)
$$

证明：对于所有的边 $(u, v) ∈ E$ 和 $i = 2, 3, \cdots, k$，重新计算过的边 $(u, v)$ 的权重值 $\hat{w}_i(u, v)$ 是一个非负整数。

e. 在本小题中，我们定义 $$\hat{\delta}_i(s, v)$$ 为使用权重函数 $$\hat{w}_i$$ 时从源结点 s 到结点 v 的最短路径权重。证明：对于所有的边 $v \in V$ 和 $i = 2, 3, \cdots, k$，有 $$\delta_i(s, v) = \hat{\delta}_i(s, v) + 2\delta_{i-1}(s, v)$$，并且 $$\hat{\delta}_i(s, v) \leqslant E$$。

f. 说明如何在 $$O(E)$$ 时间内从 $\delta_{i-1}(s, v)$ 计算出 $\delta_i(s, v)$，并且得出结论：可以在 $$O(E \log W)$$ 时间内计算出所有结点 v 的 $\delta(s, v)$。

24.4-5 (Karp 的最小平均权重环路算法) 设 $G=(V, E)$ 为一个带权重的有向图，权重函数为 $w: E → R$，设 $n = |V|$。定义 E 中边的环路 $c = (e_1, e_2, \cdots, e_k)$ 的平均权重为
$$
\mu(c) = \frac{1}{k} \sum_{i=1}^{k} w(e_i)
$$

设 $$\mu^* = \min_{c} \mu(c)$$，这里 $c$ 为图 $G$ 中所有的有向环路。我们称环路权重 $$\mu(c) = \mu^*$$ 的环路 $c$ 为最小平均权重环路。本题要研究的是如何高效地计算出 $$\mu^*$$。

假定在不失一般性的情况下，每个结点 v ∈ V 都可以从源结点 s 到达。设 $$\delta_i(s, v)$$ 为从源结点 s 到结点 v 的最短路径权重，设 $$\delta_i(s, v)$$ 为从源结点 s 到结点 v 的恰好包含 k 条边的最短路径权重。如果不存在恰好 k 条边的从 s 到 v 的路径，则 $$\delta_i(s, v) = \infty$$。

a. 证明：如果 $$\mu^* = 0$$，则图 G 包含非负权重的环路，并且对于所有的结点 $v ∈ V$，
$$
\delta_i(s, v) = \min_{0 \leqslant k \leqslant n-1} \delta_k(s, v)
$$
b. 证明：如果 $$\mu^* = 0$$，则对于所有的结点 $v ∈ V$，

$$
\max_{0 \leqslant k \leqslant n-1} \frac{\delta_k(s, v) - \delta_{k-1}(s, v)}{n - k} \geqslant 0
$$

（提示：使用(a)部分的两个属性。）

c. 设 c 为一个权重为 0 的环路，并设 u 和 v 为 c 上的任意两个结点。假定 $$\mu^* = 0$$ 并且环路上从结点 $u$ 到结点 $v$ 的简单路径的权重为 $x$。证明：$$\delta(s, v) = \delta(s, u) + x$$。（提示：环路上从结点 $v$ 到结点 $u$ 的简单路径的权重为 $-x$。）

d. 证明：如果 $$\mu^* = 0$$，则在每个最小平均权重环路上都存在一个结点 v，满足

$$
\max_{0 \leqslant k \leqslant n-1} \frac{\delta_n(s, v) - \delta_k(s, v)}{n - k} = 0
$$

（提示：说明如何将一条最短路径扩展到最小平均权重环路上的任意结点，以找出到环路上下一个结点的最短路径。）

e. 证明：如果 $$\mu^* = 0$$，则在每个最小平均权重环路上都存在一个结点 v，满足

$$
\min_{v \in V} \max_{0 \leqslant k \leqslant n-1} \frac{\delta_n(s, v) - \delta_k(s, v)}{n - k} = 0
$$

f. 证明：如果给图 G 的每条边的权重加一个常数 t，则 $$\mu^*$$ 也增加 t。使用该事实来证明：

$$
\mu^* = \min_{v \in V} \max_{0 \leqslant k \leqslant n-1} \frac{\delta_n(s, v) - \delta_k(s, v)}{n - k}
$$

g. 给出一个时间复杂度为 $O(VE)$ 的算法来计算 $$\mu^*$$。

24.4-6 （双调最短路径）对于一个序列来说，如果该序列为先单调增长，然后再单调递减，或者在进行循环移位后，该序列成为先单调增长然后单调递减的序列，则该序列称为双调序列。例如，序列 (1, 4, 6, 8, 3, -2), (9, 2, -4, -10, -7) 和 (1, 2, 3, 4) 都是双调序列，但 (1, 3, 12, 4, 2, 10) 则不是双调序列。（请参阅思考题 15-3 中的双调欧几里得旅行商问题。）

假设给定有向图 $G=(V, E)$，权重函数为 $w: E → R$，并且所有的权重都唯一，我们希望找到从源结点 s 出发的单源最短路径。不过，我们还有一条额外的信息：对于每个结点 $v ∈ V$，从源结点 s 到结点 v 的任意最短路径上的边的权重形成一个双调序列。

请给出最有效的算法来解决这个问题，并分析其运行时间。



## 第二十五章 所有结点对的最短路径问题

#### 练习

25.1-1 在图 25-2 所示的带权重有向图上运行算法 SLOW-ALL-PAIRS-SHORTEST-PATHS。给出循环的每次迭代所计算出的矩阵。然后用算法 FASTER-ALL-PAIRS-SHORTEST-PATHS 重新做一遍。

![image-20250119134340825](F:\software\Typora\images\image-20250119134340825.png)

25.1-2 为什么要求对于所有的 $$1 \leqslant i \leqslant n$$，有 $$w_i = 0$$？

25.1-3 在最短路径算法中使用的矩阵 $$L^{(0)}$$ 对应传统矩阵乘法里的什么？

$$
L^{(0)} = \left[
\begin{array}{cccc}
0 & \infty & \infty & \cdots & \infty \\
\infty & 0 & \infty & \cdots & \infty \\
\infty & \infty & 0 & \cdots & \infty \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
\infty & \infty & \infty & \cdots & 0
\end{array}
\right]
$$

25.1-4 证明：由 EXTEND-SHORTEST-PATHS 所定义的矩阵乘法是相关的。

25.1-5 说明如何将单源最短路径问题表示为矩阵和向量的乘积，并解释该乘积的计算过程如何对应 Bellman-Ford 算法？（请参阅 24.1 节。）

25.1-6 假定我们还希望在本节所讨论的算法里计算出最短路径上的结点。说明如何在 $$O(n^3)$$ 时间内从已经计算出的最短路径权重矩阵 L 计算出前驱矩阵 Π。

25.1-7 我们可以用计算最短路径权重的办法来计算最短路径上的结点。定义 $$\pi_j^{(m)}$$ 为从 i 到 j 的至多包含 m 条边的任意最小权重路径上结点 j 的前驱。请修改 EXTEND-SHORTEST-PATHS 和 SLOW-ALL-PAIRS-SHORTEST-PATHS，使其在计算出矩阵 $$L^{(1)}, L^{(2)}, \cdots, L^{(n-1)}$$ 的同时，计算出矩阵 $$\Pi^{(1)}, \Pi^{(2)}, \cdots, \Pi^{(n-1)}$$。

25.1-8 本节所讨论的 FASTER-ALL-PAIRS-SHORTEST-PATHS 过程要求我们保存 $$[\lg(n-1)]$$ 个矩阵，由于每个矩阵有 $$n^2$$ 个元素，总存储空间需求为 $$\Theta(n^2 \lg n)$$。请修改该算法，使其仅仅使用两个 n × n 的矩阵，从而将存储空间降至 $$\Theta(n^2)$$。

25.1-9 修改 FASTER-ALL-PAIRS-SHORTEST-PATHS，使其可以判断一个图是否包含一个权重为负值的环路。

25.1-10 给出一个有效算法来在图中找到最短长度的权重为负值的环路的长度（边的条数）。

#### 练习25.2

25.2-1 在图 25-2 所示的带权重的有向图上运行 Floyd-Warshall 算法，给出外层循环的每一次迭代所生成的矩阵 $$D^{(k)}$$。

25.2-2 说明如何使用 25.1 节的技术来计算传递闭包。

25.2-3 请修改 Floyd-Warshall 算法，以便根据式 (25.6) 和 (25.7) 计算出矩阵 $$\Pi^{(k)}$$。再请严格证明：对于所有的结点 $$i \in V$$，前驱子图 $$G_{n_i}$$ 是一棵根结点为 i 的最短路径树。（提示：为了证明 $$G_{m i}$$ 是无环的，可以首先证明根据 $$\pi_{i j}^{(k)}$$ 的定义，$$\pi_{i j}^{(k)} = l$$ 蕴涵着 $$d_{i j}^{(k)} \geqslant d_u^{(k)} + w_{i j}$$。然后，再采用引理 24.16 的证明。）

25.2-4 如前所述，Floyd-Warshall 算法的空间需求为 $$\Theta(n^3)$$，因为要计算 $$d_{ij}^{(k)}$$，其中 $i, j, k = 1, 2, \cdots, n$。请证明下面所列出的去掉所有上标的算法是正确的，从而将 Floyd-Warshall 算法的空间需求降低到 $$\Theta(n^2)$$。

![image-20250119134943687](F:\software\Typora\images\image-20250119134943687.png)

25.2-5 假定我们修改式 (25.7) 对等式的处理办法如下：
$$
\pi_{i j}^{(k)} = 
\begin{cases} 
\pi_{i j}^{(k-1)} & \text{若 } d_{i j}^{(k-1)} < d_{i k}^{(k-1)} + d_{k j}^{(k-1)} \\
\pi_{k j}^{(k-1)} & \text{若 } d_{i j}^{(k-1)} \geqslant d_{i k}^{(k-1)} + d_{k j}^{(k-1)}
\end{cases}
$$
请问这种前驱矩阵 II 的定义正确吗？

25.2-6 我们怎样才能使用 Floyd-Warshall 算法的输出来检测权重为负值的环路？

25.2-7 在 Floyd-Warshall 算法中构建最短路径的另一种办法是使用 $$\phi_0^{(k)}$$，其中 $i, j, k = 1, 2, \cdots, n$，$$\phi_0^{(k)}$$ 是从结点 i 到结点 j 的一条中间所有结点都取自集合 $\{1, 2, \cdots, k\}$ 的最短路径上编号最大的中间结点。请给出 $$\dot{A}_{i j}^{(k)}$$ 的一个递归公式，并修改 Floyd-Warshall 过程来计算 $$\dot{A}_{i j}^{(k)}$$ 的值，并重写 PRINT-ALL-PAIRS-SHORTEST-PATH 过程，使其以矩阵 $$\Phi = (\phi_{i j}^{(n)})$$ 作为输入。矩阵 $\Phi$ 与 15.2 节所讨论的链式矩阵乘法中的表格存在何种相似点？

25.2-8 给出一个 $O(VE)$ 时间复杂度的算法来计算有向图 $$G = (V, E)$$ 的传递闭包。

25.2-9 假定我们可以在 $f(|V|, |E|)$ 的时间内计算出一个有向无环图的传递闭包，其中 f 是一个自变量为 $|V|$ 和 $|E|$ 的单调递增函数。证明：计算一个通用的有向图 $$G = (V, E)$$ 的传递闭包 $$G^* = (V, E^*)$$ 的时间复杂度为 $$f(|V|, |E|) + O(V + E^*)$$。

### 练习25.3

25.3-1 请在图 25-2 上使用 Johnson 算法来找到所有结点对之间的最短路径。给出算法计算出的 $$h$$ 和 $$\hat{w}$$ 值。

25.3-2 在 Johnson 算法里，在集合 $$V$$ 中加入新结点 $$s$$ 产生 $$V'$$ 的目的是什么？

25.3-3 假定对于所有的边 $$(u, v) \in E$$，我们有 $$w(u, v) \geq 0$$。请问权重函数 $$w$$ 和 $$\hat{w}$$ 之间是什么关系？

25.3-4 Greenstreet 教授声称，他有一种比 Johnson 算法中所使用的更简单的办法来对边的权重进行重新赋值。设 $$w^* = \min_{(u, v) \in E} \{ w(u, v) \}$$，只要对所有的边 $$(u, v) \in E$$，定义 $$\hat{w}(u, v) = w(u, v) - w^*$$ 即可。请问这种重新赋值有什么错误？

25.3-5 假定在一个权重函数为 $$w$$ 的有向图 $$G$$ 上运行 Johnson 算法。证明：如果图 $$G$$ 包含一条权重为 0 的环路 $$c$$，那么对于环路 $$c$$ 上的每条边 $$(u, v)$$，$$\hat{w}(u, v) = 0$$。

25.3-6 Michener 教授声称，没有必要在 JOHNSON 算法的第 1 行创建一个新的源结点。他主张可以使用 $$G' = G$$，并设 $$s$$ 为任意结点。请给出一个带权重的有向图例子，使得当将这位教授的想法用到 JOHNSON 算法中将导致错误的结果。然后，证明：如果图 $$G$$ 是强连通的（每个结点都可以从其他每个结点到达），那么使用教授的修改意见后的 JOHNSON 算法将返回正确结果。

## 思考题

25-1 （动态图的传递闭包）假定我们希望在将边插入到集合 $$E$$ 中时维持有向图 $$G=(V, E)$$ 的传递闭包，即在插入每条边后，我们希望对到目前为止已插入边的传递闭包进行更新。假定图 $$G$$ 开始时不包含任何边，并且传递闭包用布尔矩阵来表示。

a. 说明在加入一条新边到图 $$G$$ 时，如何在 $$O(V^2)$$ 时间内更新图 $$G=(V, E)$$ 的传递闭包 $$G^*=(V, E^*)$$。

b. 给出一个图 $$G$$ 和一条边 $$e$$，使得在将边 $$e$$ 插入到图 $$G$$ 后，更新传递闭包的时间复杂性为 $$\Omega(V^2)$$，而不管使用的是何种算法。

c. 描述一个有效的算法，使得在将边加入到图 $$G$$ 中时更新传递闭包。对于任意 $$n$$ 次插入的序列，算法运行的总时间应该是 $$\sum_\limits{i=1}^n t_i = O(V^3)$$，其中 $$t_i$$ 是插入第 $$i$$ 条边时更新传递闭包所用的时间。请证明你的算法确实达到了这个时间效率。

25-2 （$$\varepsilon$$ 稠密图的最短路径）对于图 $$G=(V, E)$$ 来说，如果 $$|E|=\Theta(V^{1+\varepsilon})$$，则图 $$G$$ 为 $$\varepsilon$$ 稠密图，其中 $$\varepsilon$$ 为某个常数，且 $$0<\varepsilon\leqslant 1$$。如果在 $$\varepsilon$$ 稠密图的最短路径算法中使用 $$d$$ 叉最小堆（请参阅本书的问题 6-2），则能使算法的运行时间相当于基于斐波那契堆的算法的运行时间，同时无需引入后者所使用的复杂数据结构。

a. INSERT、EXTRACT-MIN、DECREASE-KEY 的渐近运行时间是多少？请以 $$d$$ 和元素个数 $$n$$ 为参数予以表达。如果选择 $$d=\Theta(n^\alpha)$$，其中 $$0<\alpha\leqslant 1$$，这些运行时间又是多少？请把这些时间与斐波那契堆的摊还代价进行比较。

b. 说明如何在 $$O(E)$$ 时间内，在一个 $$\varepsilon$$ 稠密的有向图中计算出单源最短路径，这里假定该图不包含权重为负值的边。（提示：选一个以 $$\varepsilon$$ 为自变量的函数作为 $$d$$。）

c. 说明如何在 $$O(VE)$$ 时间内，在一个 $$\varepsilon$$ 稠密的有向图中计算出所有结点对之间的最短路径，这里假定该图不包含权重为负值的边。

d. 说明如何在 $$O(VE)$$ 时间内，在一个 $$\varepsilon$$ 稠密的有向图中计算出所有结点对之间的最短路径，这里假定图中可以包含权重为负值的边，但不包含权重为负值的环路。



## 第二十六章 最大流

### 练习26.1

26.1-1 证明：在一个流网络中，将一条边分解为两条边所得到的是一个等价的网络。更形式化地说，假定流网络 $$G$$ 包含边 $$(u, v)$$，我们以如下方式创建一个新的流网络 $$G'$$：创建一个新结点 $$x$$，用新的边 $$(u, x)$$ 和 $$(x, v)$$ 来替换原来的边 $$(u, v)$$，并设置 $$c(u, x) = c(x, v) = c(u, v)$$。证明：$$G'$$ 中的一个最大流与 $$G$$ 中的一个最大流具有相同的值。

26.1-2 将流的性质和定义推广到多个源结点和多个汇点的流问题上。证明：在多源结点多汇点流网络中，任意流均对应于通过增加一个超级源结点和超级汇点所形成的具有相同值的一个单源结点单汇点流中，反之亦然。

26.1-3 假定流网络 $$G=(V, E)$$ 违反了对于所有结点 $$v \in V$$，网络必须包括一条路径 $$s \rightarrow v \rightarrow t$$ 的假设。设 $$u$$ 为这样一个结点：不存在路径 $$s \rightarrow u \rightarrow t$$。证明：$$G$$ 中必然存在一个最大流 $$f$$，使得对于所有结点 $$v \in V$$，$$f(u, v) = f(v, u) = 0$$。

26.1-4 设 $$f$$ 为网络中的一个流，设 $$\alpha$$ 为一个实数，则 $$\alpha f$$ 称为标量流积，该标量流积是一个从 $$V \times V$$ 到 $$R$$ 的函数，其定义如下：
$$
(\alpha f)(u, v) = \alpha \cdot f(u, v)
$$
证明：网络中的流形成一个凸集。也就是说，证明：如果 $$f_1$$ 和 $$f_2$$ 为两个流，则 $$\alpha f_1 + (1-\alpha) f_2$$ 也是一个流，这里 $$0 \leq \alpha \leq 1$$。

26.1-5 将最大流问题表述为一个线性规划问题。

26.1-6 Adam 教授有两个儿子，可不幸的是，他们互相讨厌对方。随着时间的推移，问题变得如此严重，他们之间不仅不愿意一起走到学校，而且每个人都拒绝走另一个人当天所走过的街区。两个孩子对于自己所走的路径与对方所走的路径在街角交叉并不在意。幸运的是，教授的房子和学校都位于街角上。但除此之外，教授不能肯定是否可以在满足上述条件的情况下把两个小孩送到同一所学校。教授有一份小镇的地图，试说明如何将这个问题转换为一个最大流问题，以便决定是否可以将孩子送到同一所学校。

26.1-7 假定除边的容量外，流网络还有结点容量。即对于每个结点 $$v$$，有一个极限值 $$l(v)$$，这是可以流经结点 $$v$$ 的最大流量。请说明如何将一个带有结点容量的流网络 $$G=(V, E)$$ 转换为一个等价的但没有结点容量的流网络 $$G'=(V', E')$$，使得 $$G'$$ 中的最大流与 $$G$$ 中的最大流的取值一样。图 $$G'$$ 里有多少个结点和多少条边？

### 练习26.2

26.2-1 证明式(26.6)中的和值等于式(26.7)中的和值。

26.2-2 在图 26-1(b)中，横跨切割 $$(\{s, v_2, v_4\}, \{v_1, v_3, t\})$$ 的流是多少？该切割的容量又是多少？

26.2-3 在图 26-1(a)所示的流网络上演示 Edmonds-Karp 算法的执行过程。

26.2-4 在图 26-6 的例子中，对应图中所示最大流的最小切割是什么？在例子中出现的增广路径里，哪一条路径抵消了先前被传输的流？

26.2-5 在 26.1 节中，我们通过增加具有无限容量的边，把一个多源结点多汇点的流网络转换为单源结点单汇点的流网络。证明：如果原来的多源结点多汇点网络的容量是有限的，则转换后的结果网络中任何一个流的值都是有限值。

26.2-6 假定在一个多源结点多汇点的流网络中，每个源结点 $$s_i$$ 生产出恰好 $$p_i$$ 个单位的流，因此，$$\sum_{v \in V} f(s_i, v) = p_i$$。假定每个汇点 $$t_j$$ 消费恰好 $$q_j$$ 个单位的流，因此 $$\sum_{v \in V} f(v, t_j) = q_j$$，其中 $$\sum_i p_i = \sum_j q_j$$。说明如何把寻找一个满足这些额外条件的流 $$f$$ 的问题，转换为在一个单源结点单汇点的流网络中寻找最大流的问题。

26.2-7 证明引理 26.2。

26.2-8 假定我们对残存网络进行重新定义，禁止一切进入源结点 $$s$$ 的边。证明：FORD-FULKERSON 算法仍然能够正确计算出最大流。

26.2-9 假定 $$f$$ 和 $$f'$$ 都是流网络 $$G$$ 中的流，计算流 $$f \uparrow f'$$。加增后的流满足流量守恒性质吗？满足容量限制吗？

26.2-10 说明在流网络 $$G=(V, E)$$ 中，如何使用一个最多包含 $$|E|$$ 条增广路径的序列来找到一个最大流。（提示：找到最大流后再确定路径。）

26.2-11 无向图的边连通性是指使图变为非连通图所需要删除的最少边数 $$k$$。例如，树的边连通性为 1，所有结点形成的环路的边连通性为 2。请说明如何在最多 $$|V|$$ 个流网络上运行最大流算法来确定无向图 $$G=(V, E)$$ 的边连通性，这里的每个流网络的结点数为 $$O(V)$$，边的条数为 $$O(E)$$。

26.2-12 给定一个流网络 $$G$$，$$G$$ 中包含进入源结点 $$s$$ 的边。设 $$f$$ 为网络 $$G$$ 中的一个流，在该流中，其中一条进入源结点的边 $$(v, s)$$ 有 $$f(v, s) = 1$$。证明：图 $$G$$ 中必存在另一个流 $$f'$$，满足 $$f'(v, s) = 0$$，使得 $$|f| = |f'|$$。给出一个 $$O(E)$$ 时间复杂度的算法来在给定流 $$f$$ 的情况下计算 $$f'$$，这里假定所有边的容量都是整数值。

26.2-13 假定我们希望找到一个流网络 $$G$$ 的所有最小切割中包含边的条数最少的切割，这里假定 $$G$$ 的所有容量都是整数值。说明如何修改 $$G$$ 的容量来创建一个新的流网络 $$G'$$，使得 $$G'$$ 中的任意一个最小切割是 $$G$$ 中包含边的条数最少的最小切割。

### 练习26.3

26.3-1 在图 26-8(c)上运行 Ford-Fulkerson 算法，给出每次流量递增后的残存网络。将集合 $$L$$ 中的结点从上至下编号 1～5，集合 $$R$$ 中的结点从上至下编号 6～9。对于每次迭代，选择字典次序最小的增广路径。

26.3-2 证明定理 26.10。

26.3-3 设 $$G=(V, E)$$ 是一个二分图，其结点划分为 $$V=L \cup R$$，设 $$G'=(V', E')$$ 为其对应的流网络。在 FORD-FULKERSON 执行过程中，对在 $$G'$$ 中找出的任意增广路径的长度给出一个适当的上界。

*26.3-4 完全匹配是指图中所有结点都得到匹配的匹配。设 $$G=(V, E)$$ 是结点划分为 $$V=L \cup R$$ 的无向二分图，其中 $$|L|=|R|$$。对于任意 $$X \subseteq V$$，定义 $$X$$ 的邻居为：
$$
N(X)=\{y \in V: \text{对某个} x \in X, (x, y) \in E\}
$$
即由与 $$X$$ 的某元素相邻的结点所构成的集合。请证明 Hall 定理：图 $$G$$ 中存在一个完全匹配当且仅当对于每个子集 $$A \subseteq L$$，有 $$|A| \leq |N(A)|$$。

### 练习26.4

26.4-1 证明：在算法 INITIALIZE-PREFLOW($$G, s$$) 终止后，有 $$s.e \leq -|f^*|$$，其中 $$f^*$$ 是流网络 $$G$$ 的一个最大流。

26.4-2 说明如何实现通用推送-重贴标签算法，使得每个重贴标签的操作成本为 $$O(V)$$，每个推送操作的成本为 $$O(1)$$，并且可以在 $$O(1)$$ 时间内选择一个合适的操作，从而使得整个算法的运行时间为 $$O(V^2E)$$。

26.4-3 证明：通用推送-重贴标签算法只用了总共 $$O(VE)$$ 的时间来执行所有 $$O(V^2)$$ 个重贴标签操作。

26.4-4 假定使用推送-重贴标签算法找到了流网络 $$G=(V, E)$$ 的一个最大流，给出一个快速算法来找到 $$G$$ 的一个最小切割。

26.4-5 给出一个有效的推送-重贴标签算法，使得其可以在一个二分图中找到一个最大匹配。分析你的算法的效率。

26.4-6 假定在流网络 $$G=(V, E)$$ 中所有边的容量都在集合 $$\{1, 2, \cdots, k\}$$ 里。分析通用推送-重贴标签算法的运行时间，请以 $$|V|$$、$$|E|$$ 和 $$k$$ 来予以表示。（提示：每条边在变为饱和之前可以支持多少次非饱和推送操作？）

26.4-7 证明：我们可以将 INITIALIZE-PREFLOW 算法的第 6 行改为如下：
$$
6~s.h = |G.V| - 2
$$
而不会影响通用推送-重贴标签算法的正确性和渐近性能。

26.4-8 设 $$\delta_f(u, v)$$ 为残存网络 $$G_f$$ 中从结点 $$u$$ 到结点 $$v$$ 的距离（边的条数）。证明：GENERIC-PUSH-RELABEL 算法维持 $$u.h < |V|$$ 的性质意味着 $$u.h \leq \delta_f(u, t)$$，维持性质 $$u.h \geq |V|$$ 则意味着 $$u.h - |V| \leq \delta_f(u, s)$$。

*26.4-9 如前一个练习，设 $$\delta_f(u, v)$$ 为残存网络 $$G_f$$ 中从结点 $$u$$ 到结点 $$v$$ 的距离。请说明如何修改通用推送-重贴标签算法，以使得维持 $$u.h < |V|$$ 的性质意味着 $$u.h = \delta_f(u, t)$$，维持性质 $$u.h \geq |V|$$ 意味着 $$u.h - |V| = \delta_f(u, s)$$。你所设计算法用于维持该性质所用的总时间应该为 $$O(VE)$$。

26.4-10 证明：在流网络 $$G=(V, E)$$ 上运行 GENERIC-PUSH-RELABEL 算法所执行的非饱和推送操作的总次数为 $$4|V|^2|E|$$，这里假定 $$|V| \geq 4$$。



### 练习26.5

26.5-1 请以图 26-10 所示的方式，在图 26-1(a)所示的流网络上演示前置重贴标签算法的执行过程。假设链表 L 中结点的最初顺序是 $$(v_1, v_2, v_3, v_4)$$，并且各个邻接链表的内容如下：
$$
\begin{align*}
v_1 \cdot N &= \langle s, v_2, v_3 \rangle \\
v_2 \cdot N &= \langle s, v_1, v_3, v_4 \rangle \\
v_3 \cdot N &= \langle v_1, v_2, v_4, t \rangle \\
v_4 \cdot N &= \langle v_2, v_3, t \rangle
\end{align*}
$$

*26.5-2 我们希望以如下方式来实现推送-重贴标签算法：在算法中维持一个先进先出的队列，用来存放溢出结点。算法重复将队列头部的结点进行释放，任何在释放前没有溢出但在释放后出现溢出的结点均被放置在队列的末尾。在队列头部的结点被释放后，该结点即被删除。当队列为空时，算法终止。说明如何实现该算法，以便在 $$O(V^a)$$ 时间内计算出一个最大流。

26.5-3 证明：如果 RELABEL 操作对 $$u.h$$ 的更新只是简单地计算 $$u.h = u.h + 1$$，通用算法仍然能够正确工作。另外，请说明该变化对前置重贴标签算法的分析会有何种影响？

*26.5-4 证明：如果总是释放高度最高的溢出结点，则可以使推送-重贴标签算法在 $$O(V^a)$$ 时间内完成。

26.5-5 假定在推送-重贴标签算法执行过程中的某个时刻，存在一个整数 $$0 < k \leq |V| - 1$$，使得没有任何一个结点的高度为 $$k$$（即不存在结点 $$v$$，使得 $$v_h = k$$）。证明：所有高度大于 $$k$$ 的结点都位于某个最小切割的源结点这一边。如果这样一个 $$k$$ 存在，则跨越式启发 (gap heuristic) 将对每个 $$v.h > k$$ 的结点 $$v \in V - \{s\}$$ 进行更新，将 $$v.h$$ 设置为 $$\max(v.h, |V| + 1)$$。证明：结果属性 $$h$$ 是一个高度函数。（在实际中，跨越式启发对于高效率地实现推送-重贴标签算法起着关键作用。）

### 思考题

26-1 （逃逸问题） $$n \times n$$ 的网格是由 $$n$$ 行和 $$n$$ 列结点所构成的无向图，如图 26-11 所示。我们将位于第 $$i$$ 行和第 $$j$$ 列的结点表示为 $$(i, j)$$。除了位于边界的结点外，网络中其他所有结点都有刚好 4 个邻结点。边界结点指的是满足 $$i = 1$$、$$i = n$$、$$j = 1$$ 或 $$j = n$$ 的结点 $$(i, j)$$。

在这样的网格里给定 $$m \leq n^2$$ 个起始结点 $$(x_1, y_1), (x_2, y_2), \cdots, (x_m, y_m)$$，逃逸问题要做的事情是判断是否存在从这些起始结点到任意 $$m$$ 个不同的边界结点之间的 $$m$$ 条结点分离的路径（每条路径之间没有共同结点）。例如，在图 26-11(a) 所示的网格中有一个逃逸线路，但图 26-11(b) 的网格则没有逃逸线路。

(a) 考虑一个结点和边都有容量限制的流网络。也就是说，进入任何给定结点的正流都要受到容量的限制。证明：在一个结点和边都有容量的流网络中确定最大流的问题可以归约为同等规模流网络中的普通最大流问题。

(b) 给出一个有效的算法来解决逃逸问题，并分析算法的运行时间。

26-2 （最小路径覆盖问题）有向图 $$G = (V, E)$$ 的一个路径覆盖是指一个结点不相交的路径集合 $$P$$，使得集合 $$V$$ 中的每个结点恰好在 $$P$$ 的一条路径上出现。路径的起始结点和终结点可以是任意结点，也可以有任意的长度，包括 0 长度。图 $$G$$ 的一个最小路径覆盖是一个包含路径条数最少的路径覆盖。

a. 给出一个有效算法来找到有向无环图 $$G = (V, E)$$ 的一个最小路径覆盖。（提示：假定 $$V = \{1, 2, \cdots, n\}$$，然后构建图 $$G' = (V', E')$$，其中
$$
\begin{align*}
V' &= \{x_0, x_1, \cdots, x_s\} \cup \{y_0, y_1, \cdots, y_s\} \\
E' &= \{(x_0, x_i) : i \in V\} \cup \{(y_i, y_0) : i \in V\} \cup \{(x_i, y_j) : (i, j) \in E\}
\end{align*}
$$
然后在图$G’$上运行最大流算法）

b. 你的算法是否适用于带环路的有向图，请详细解释。

26-3 （算法咨询）Gore 教授希望创办一家算法咨询公司。教授选出了算法中的 $$n$$ 个重要子领域（大概相当于本书的每个不同部分），并用集合 $$A = \{A_1, A_2, \cdots, A_n\}$$ 予以表示。在每个子领域 $$A_k$$，教授可以用 $$c_k$$ 美元聘请该领域的一位专家。咨询公司已经列出了一个潜在工作的集合 $$J = \{J_1, J_2, \cdots, J_m\}$$。为了完成工作 $$J_i$$，公司需要在子领域的子集合 $$R_i \subseteq A$$ 中聘请专家。每位专家可以同时从事多项工作。如果公司选择接受工作 $$J_i$$，则公司必须在集合 $$R_i$$ 中的所有子领域中聘请专家，同时，公司从该项目中可以收入的营业额为 $$p_i$$ 美元。

Gore 教授的工作是决定聘请哪些子领域的专家，接受哪些工作，以便使公司的净营业额达到最高，这里净营业额指的是从工作中获得的总输入减去聘请专家的总成本的差额。

考虑下面的流网络 $$G$$。该网络包含一个源结点 $$s$$，结点 $$A_1, A_2, \cdots, A_n$$，结点 $$J_1, J_2, \cdots, J_m$$，以及一个汇点 $$t$$。对于 $$k = 1, 2, \cdots, n$$，流网络包含一条边 $$(s, A_k)$$，其容量为 $$c(s, A_k) = c_k$$，而对于 $$i = 1, 2, \cdots, m$$，流网络包含一条边 $$(J_i, t)$$，容量为 $$c(J_i, t) = p_i$$。对于 $$k = 1, 2, \cdots, n$$ 和 $$i = 1, 2, \cdots, m$$，如果 $$A_k \in R_i$$，则图 $$G$$ 包含边 $$(A_k, J_i)$$，其容量为 $$c(A_k, J_i) = \infty$$。

a. 证明：如果对于一个有限容量的切割 ($$S, T$$)，有 $$J_i \in T$$，则对于每个结点 $$A_k \in R_i$$，有 $$A_k \in T$$。

b. 请说明如何从图 $$G$$ 的一个最小切割的容量和给定的 $$p_i$$ 值中计算公司的最大净收入。

c. 请给出一个有效算法来判断哪些工作应该接受，哪些专家应该聘请。分析算法的运行时间，并以 $$m$$、$$n$$ 和 $$r = \sum_{i=1}^m |R_i|$$ 来予以表示。

26-4 （最大流的更新）设 $$G = (V, E)$$ 是一个源结点为 $$s$$ 汇点为 $$t$$ 的流网络，其容量全部为整数值。假定我们已经给定 $$G$$ 的一个最大流。

a. 如果将单条边 $$(u, v) \in E$$ 的容量增加 1 个单位，请给出一个 $$O(V + E)$$ 时间的算法来对最大流进行更新。

b. 如果将单条边 $$(u, v) \in E$$ 的容量减少 1 个单位，请给出一个 $$O(V + E)$$ 时间的算法来对最大流进行更新。

26-5 （使用伸缩操作来计算最大流）设 $$G = (V, E)$$ 为一个源结点为 $$s$$ 汇点为 $$t$$ 的流网络，对于每条边 $$(u, v) \in E$$，其容量 $$c(u, v)$$ 为整数值。设 $$C = \max_{(u, v) \in E} c(u, v)$$。

a. 证明：图 $$G$$ 的一个最小切割的容量最多为 $$C|E|$$。

b. 对于给定数值 $$K$$，说明如何在 $$O(E)$$ 时间内找到一条容量至少为 $$K$$ 的增广路径，假如这样的路径存在。

使用下面的经过修改的 FORD-FULKERSON-METHOD 来计算图 $$G$$ 的最大流：

![image-20250119141539913](F:\software\Typora\images\image-20250119141539913.png)

c. 证明：算法 MAX-FLOW-BY-SCALING 返回的是一个最大流。

d. 证明：每次在算法第 4 行被执行时，残存网络 $$G_r$$ 的一个最小切割的容量最多为 $$2K|E|$$。

e. 证明：对于每个数值 $$K$$，算法第 5～6 行的内部 while 循环执行的次数为 $$O(E)$$ 次。

f. 证明：算法 MAX-FLOW-BY-SCALING 可以在 $$O(E^2 \lg C)$$ 时间内实现。

26-6 （Hopcroft-Karp 二分匹配算法）在本题中，为了找到一个二分图的最大匹配，我们将描述一个由 Hopcroft 和 Karp 提出的更快速算法。算法的运行时间为 $$O(\sqrt{V}E)$$。给定一个无向二分图 $$G=(V, E)$$，其中 $$V=L \cup R$$ 并且所有的边都恰好有一个端点在集合 $$L$$ 中。设 $$M$$ 为图 $$G$$ 的一个匹配。对于图 $$G$$ 中的一条简单路径 $$P$$，如果该路径的起点是 $$L$$ 中一个未匹配的结点，终结点是集合 $$R$$ 中一个未匹配的结点，而路径上的边交替属于 $$M$$ 和 $$E - M$$，则称路径 $$P$$ 是一条相对于 $$M$$ 的增广路径（该增广路径的定义与流网络中的增广路径相关，但并不相同）。在本题中，我们将一条路径看做是一系列的边，而不是一系列的结点。一条关于匹配 $$M$$ 的最短增广路径是一条包含最少边数的增广路径。

给定两个集合 $$A$$ 和 $$B$$，对称差 $$A \oplus B$$ 定义为 $$(A - B) \cup (B - A)$$，即仅在一个集合中出现的元素。

a. 证明：如果 $$M$$ 是图 $$G$$ 的一个匹配，$$P$$ 是一条关于 $$M$$ 的增广路径，则对称差 $$M \oplus P$$ 也是一个匹配并且 $$|M \oplus P| = |M| + 1$$。另外，证明：如果 $$P_1, P_2, \cdots, P_k$$ 为关于 $$M$$ 的结点分离的增广路径，则对称差 $$M \oplus (P_1 \cup P_2 \cup \cdots \cup P_k)$$ 是一个基数为 $$|M| + k$$ 的匹配。

下面是 Hopcroft-Karp 二分匹配算法的一般结构：

![image-20250119141702865](F:\software\Typora\images\image-20250119141702865.png)

该问题的剩余部分要求读者分析上述算法的迭代次数（即 repeat 循环的迭代次数）并给出算法第 3 行的一种实现。

b. 给定图 $$G$$ 的两个匹配 $$M$$ 和 $$M^*$$，证明：图 $$G'=(V, M \oplus M^*)$$ 中的每个结点的度数最多为 2。同时证明图 $$G'$$ 是由一些不相交的简单路径或环路组成。另外，试说明每条这样的简单路径或环中的边交替属于 $$M$$ 和 $$M^*$$。证明：如果 $$|M| \leq |M^*|$$，则 $$M \oplus M^*$$ 至少包含 $$|M^*| - |M|$$ 条关于 $$M$$ 的结点不相交的增广路径。

设 $$l$$ 为关于匹配 $$M$$ 的最短增广路径的长度，$$P_1, P_2, \cdots, P_k$$ 为关于 $$M$$ 的长度为 $$l$$ 的结点不相交增广路径的最大集合。设 $$M' = M \oplus (P_1 \cup P_2 \cup \cdots \cup P_k)$$，并且假定 $$P$$ 是相对于 $$M'$$ 的一条最短增广路径。

c. 证明：如果路径 $$P$$ 与路径 $$P_1, P_2, \cdots, P_k$$ 之间没有共同结点，则路径 $$P$$ 有多于 $$l$$ 条边。

d. 现在假定路径 $$P$$ 与路径 $$P_1, P_2, \cdots, P_k$$ 之间存在共同结点。设 $$A$$ 为边 $$(M \oplus M') \oplus P$$ 的集合。证明：$$A = (P_1 \cup P_2 \cup \cdots \cup P_k) \oplus P$$ 并且 $$|A| \geq (k+1)l$$。同时证明：路径 $$P$$ 包含的边多于 $$l$$ 条。

e. 证明：如果关于 $$M$$ 的一条最短增广路径有 $$l$$ 条边，则最大匹配的规模至多为 $$|M| + |V|/(l+1)$$。

f. 证明：Hopcroft-Karp 二分匹配算法中 repeat 循环的迭代次数至多为 $$2\sqrt{V}$$。（提示：在第 $$\sqrt{V}$$ 次迭代后，$$M$$ 能增长多少？）

g. 给出一个 $$O(E)$$ 时间复杂性的算法，可以找到一个关于给定匹配 $$M$$ 的结点不相交最短增广路径 $$P_1, P_2, \cdots, P_k$$ 的最大集合。证明：算法 HOPCROFT-KARP 的总运行时间为 $$O(\sqrt{V} E)$$。